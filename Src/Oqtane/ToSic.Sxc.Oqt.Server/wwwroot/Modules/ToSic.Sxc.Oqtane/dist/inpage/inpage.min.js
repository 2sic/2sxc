var $2sxcInpage;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 98:
/***/ (function(module, exports) {

var global = typeof self !== 'undefined' ? self : this;
var __self__ = (function () {
function F() {
this.fetch = false;
this.DOMException = global.DOMException
}
F.prototype = global;
return new F();
})();
(function(self) {

var irrelevant = (function (exports) {

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch // To enable: import fetch from 'cross-fetch'
exports["default"] = ctx.fetch // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers
exports.Request = ctx.Request
exports.Response = ctx.Response
module.exports = exports


/***/ }),

/***/ 34:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;


__webpack_unused_export__ = ({
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var defaults = {
    selectorAttr: 'data-i18n',
    targetAttr: 'i18n-target',
    optionsAttr: 'i18n-options',
    useOptionsAttr: false,
    parseDefaultValueFromContent: true,
    document: document
};

function init(i18next) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    options = _extends({}, defaults, options);
    var extendDefault = function extendDefault(o, val) {
        return options.parseDefaultValueFromContent ? _extends({}, o, { defaultValue: val }) : o;
    };
    function parse(elem, key, opts) {
        var attr = 'text';

        if (key.indexOf('[') == 0) {
            var parts = key.split(']');
            key = parts[1];
            attr = parts[0].substr(1, parts[0].length - 1);
        }

        key = key.indexOf(';') == key.length - 1 ? key.substr(0, key.length - 2) : key;

        if (attr === 'html') {
            elem.innerHTML = i18next.t(key, extendDefault(opts, elem.innerHTML));
        } else if (attr === 'text') {
            elem.textContent = i18next.t(key, extendDefault(opts, elem.textContent));
        } else if (attr === 'prepend') {
            var startIdx = elem.innerHTML.indexOf('<loc-i18n>');
            var endIdx = elem.innerHTML.indexOf('</loc-i18n>') + 11;
            if (startIdx > -1 && endIdx > 6) {
                elem.innerHTML = [elem.innerHTML.substring(0, startIdx), elem.innerHTML.slice(endIdx)].join('');
            }
            elem.innerHTML = ['<loc-i18n>', i18next.t(key, extendDefault(opts, elem.innerHTML)), '</loc-i18n>', elem.innerHTML].join('');
        } else if (attr === 'append') {
            var _startIdx = elem.innerHTML.indexOf('<loc-i18n>');
            var _endIdx = elem.innerHTML.indexOf('</loc-i18n>') + 11;
            if (_startIdx > -1 && _endIdx > 6) {
                elem.innerHTML = [elem.innerHTML.substring(0, _startIdx), elem.innerHTML.slice(_endIdx)].join('');
            }
            elem.innerHTML = [elem.innerHTML, '<loc-i18n>', i18next.t(key, extendDefault(opts, elem.innerHTML), '</loc-i18n>')].join('');
        } else if (attr.indexOf('data-') === 0) {
            var dataAttr = attr.substr('data-'.length);
            var translated = i18next.t(key, extendDefault(opts, elem.getAttribute(dataAttr)));
            // we change into the data cache
            elem.setAttribute(dataAttr, translated);
            // we change into the dom
            elem.setAttribute(attr, translated);
        } else {
            elem.setAttribute(attr, i18next.t(key, extendDefault(opts, elem.getAttribute(attr))));
        }
    };

    function relaxedJsonParse(badJSON) {
        return JSON.parse(badJSON.replace(/:\s*"([^"]*)"/g, function (match, p1) {
            return ': "' + p1.replace(/:/g, '@colon@') + '"';
        }).replace(/:\s*'([^']*)'/g, function (match, p1) {
            return ': "' + p1.replace(/:/g, '@colon@') + '"';
        }).replace(/(['"])?([a-z0-9A-Z_]+)(['"])?\s*:/g, '"$2": ').replace(/@colon@/g, ':'));
    }

    function _loc(elem, opts) {
        var key = elem.getAttribute(options.selectorAttr);
        //        if (!key && typeof key !== 'undefined' && key !== false)
        //            key = elem.textContent || elem.innerHTML;
        if (!key) return;

        var target = elem,
            targetSelector = elem.getAttribute(options.targetAttr);

        if (targetSelector != null) target = elem.querySelector(targetSelector) || elem;

        if (!opts && options.useOptionsAttr === true) opts = relaxedJsonParse(elem.getAttribute(options.optionsAttr) || '{}');

        opts = opts || {};

        if (key.indexOf(';') >= 0) {
            var keys = key.split(';');
            for (var ix = 0, l_ix = keys.length; ix < l_ix; ix++) {
                if (keys[ix] != '') parse(target, keys[ix], opts);
            }
        } else {
            parse(target, key, opts);
        }

        if (options.useOptionsAttr === true) {
            var clone = {};
            clone = _extends({ clone: clone }, opts);
            delete clone.lng;
            elem.setAttribute(options.optionsAttr, JSON.stringify(clone));
        }
    }

    function handle(selector, opts) {
        var elems = options.document.querySelectorAll(selector);
        for (var i = 0; i < elems.length; i++) {
            var elem = elems[i];
            var childs = elem.querySelectorAll('[' + options.selectorAttr + ']');
            for (var j = childs.length - 1; j > -1; j--) {
                _loc(childs[j], opts);
            }
            _loc(elem, opts);
        }
    };
    return handle;
}

exports["default"] = {
    init: init
};

/***/ }),

/***/ 837:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(34)["default"];


/***/ }),

/***/ 576:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 361:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 144:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 246:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ 249:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * Author: Alex Gibson
 * https://github.com/alexgibson/shake.js
 * License: MIT license
 */

(function(global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
            return factory(global, global.document);
        }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
} (typeof window !== 'undefined' ? window : this, function (window, document) {

    'use strict';

    function Shake(options) {
        //feature detect
        this.hasDeviceMotion = 'ondevicemotion' in window;

        this.options = {
            threshold: 15, //default velocity threshold for shake to register
            timeout: 1000 //default interval between events
        };

        if (typeof options === 'object') {
            for (var i in options) {
                if (options.hasOwnProperty(i)) {
                    this.options[i] = options[i];
                }
            }
        }

        //use date to prevent multiple shakes firing
        this.lastTime = new Date();

        //accelerometer values
        this.lastX = null;
        this.lastY = null;
        this.lastZ = null;

        //create custom event
        if (typeof document.CustomEvent === 'function') {
            this.event = new document.CustomEvent('shake', {
                bubbles: true,
                cancelable: true
            });
        } else if (typeof document.createEvent === 'function') {
            this.event = document.createEvent('Event');
            this.event.initEvent('shake', true, true);
        } else {
            return false;
        }
    }

    //reset timer values
    Shake.prototype.reset = function () {
        this.lastTime = new Date();
        this.lastX = null;
        this.lastY = null;
        this.lastZ = null;
    };

    //start listening for devicemotion
    Shake.prototype.start = function () {
        this.reset();
        if (this.hasDeviceMotion) {
            window.addEventListener('devicemotion', this, false);
        }
    };

    //stop listening for devicemotion
    Shake.prototype.stop = function () {
        if (this.hasDeviceMotion) {
            window.removeEventListener('devicemotion', this, false);
        }
        this.reset();
    };

    //calculates if shake did occur
    Shake.prototype.devicemotion = function (e) {
        var current = e.accelerationIncludingGravity;
        var currentTime;
        var timeDifference;
        var deltaX = 0;
        var deltaY = 0;
        var deltaZ = 0;

        if ((this.lastX === null) && (this.lastY === null) && (this.lastZ === null)) {
            this.lastX = current.x;
            this.lastY = current.y;
            this.lastZ = current.z;
            return;
        }

        deltaX = Math.abs(this.lastX - current.x);
        deltaY = Math.abs(this.lastY - current.y);
        deltaZ = Math.abs(this.lastZ - current.z);

        if (((deltaX > this.options.threshold) && (deltaY > this.options.threshold)) || ((deltaX > this.options.threshold) && (deltaZ > this.options.threshold)) || ((deltaY > this.options.threshold) && (deltaZ > this.options.threshold))) {
            //calculate time in milliseconds since last shake registered
            currentTime = new Date();
            timeDifference = currentTime.getTime() - this.lastTime.getTime();

            if (timeDifference > this.options.timeout) {
                window.dispatchEvent(this.event);
                this.lastTime = new Date();
            }
        }

        this.lastX = current.x;
        this.lastY = current.y;
        this.lastZ = current.z;

    };

    //event handler
    Shake.prototype.handleEvent = function (e) {
        if (typeof (this[e.type]) === 'function') {
            return this[e.type](e);
        }
    };

    return Shake;
}));


/***/ }),

/***/ 79:
/***/ (() => {

"use strict";
// The following script fixes a bug in DNN 08.00.04
// the bug tries to detect a module-ID based on classes in a tag,
// but uses a bad regex and captures the number 2 on all 2sxc-modules
// instead of the real id
// this patch changes the order of the className of 2sxc modules when
// they are accessed through '$.fn.attr'
// 'DnnModule-2sxc DnnModule-xxx' -> DNN thinks the mod id is 2 (false)
// 'DnnModule-xxx DnnModule-2sxc' -> DNN thinks the mod id is xxx (correct)
// documented here https://github.com/2sic/2sxc/issues/986
/**
 * Fix drag-drop functionality in dnn 08.00.04 - it has an incorrect regex
 * @internal
 */

(function () {
    if (window.$ == null)
        return;
    var fn = window.$.fn.attr;
    window.$.fn.attr = function () {
        var val = fn.apply(this, arguments);
        if (arguments[0] !== 'class' || typeof val !== 'string' || val.search('DnnModule-2sxc ') === -1)
            return val;
        return val.replace('DnnModule-2sxc ', '') + ' DnnModule-2sxc';
    };
})();


/***/ }),

/***/ 154:
/***/ ((module, exports, __webpack_require__) => {

var fetchApi
if (typeof fetch === 'function') {
  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.fetch) {
    fetchApi = __webpack_require__.g.fetch
  } else if (typeof window !== 'undefined' && window.fetch) {
    fetchApi = window.fetch
  }
}

if ( true && (typeof window === 'undefined' || typeof window.document === 'undefined')) {
  var f = fetchApi || __webpack_require__(98)
  if (f.default) f = f.default
  exports["default"] = f
  module.exports = exports.default
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Actions": () => (/* reexport */ Actions),
  "CmdParHlp": () => (/* reexport */ CmdParHlp),
  "CmsEngine": () => (/* reexport */ CmsEngine),
  "Command": () => (/* reexport */ Command),
  "Commands": () => (/* reexport */ Commands),
  "ContentListActionParams": () => (/* reexport */ ContentListActionParams),
  "ModifierBase": () => (/* reexport */ ModifierBase),
  "ModifierContentBlock": () => (/* reexport */ ModifierContentBlock),
  "ModifierDnnModule": () => (/* reexport */ ModifierDnnModule),
  "ModifierDnnModuleInternal": () => (/* reexport */ ModifierDnnModuleInternal),
  "PositionCoordinates": () => (/* reexport */ PositionCoordinates),
  "Positioning": () => (/* reexport */ Positioning),
  "QeSelectors": () => (/* reexport */ QeSelectors),
  "QuickE": () => (/* reexport */ QuickE),
  "QuickEClipboard": () => (/* reexport */ QuickEClipboard),
  "QuickEditConfig": () => (/* reexport */ QuickEditConfig),
  "QuickEditConfigButtons": () => (/* reexport */ QuickEditConfigButtons),
  "QuickEditConfigEnableAuto": () => (/* reexport */ QuickEditConfigEnableAuto),
  "QuickEditConfigRoot": () => (/* reexport */ QuickEditConfigRoot),
  "QuickEditOverlay": () => (/* reexport */ QuickEditOverlay),
  "RunParamsHelpers": () => (/* reexport */ RunParamsHelpers),
  "Selection": () => (/* reexport */ Selection),
  "SharedLogic": () => (/* reexport */ SharedLogic),
  "SxcCmsReal": () => (/* reexport */ SxcCmsReal),
  "SxcGlobalCms": () => (/* reexport */ SxcGlobalCms),
  "SxcTools": () => (/* reexport */ SxcTools),
  "ToolbarWorkflowManager": () => (/* reexport */ ToolbarWorkflowManager),
  "WorkflowCommands": () => (/* reexport */ WorkflowCommands),
  "WorkflowHelper": () => (/* reexport */ WorkflowHelper),
  "WorkflowPhases": () => (/* reexport */ WorkflowPhases),
  "WorkflowStepCodeArguments": () => (/* reexport */ WorkflowStepCodeArguments),
  "WorkflowStepHelper": () => (/* reexport */ WorkflowStepHelper)
});

;// CONCATENATED MODULE: ./src/constants/content-block.ts
/**
 * This just holds some constants, but it looks like _LayoutElement is unused - but I think it should be!
 * @internal
 */
var ContentBlock = /** @class */ (function () {
    function ContentBlock() {
    }
    // constants
    ContentBlock.cViewWithoutContent = '_LayoutElement'; // needed to differentiate the "select item" from the "empty-is-selected" which are both empty
    ContentBlock.UseExistingTemplate = -1;
    return ContentBlock;
}());

/**
 * ContentBlock constants
 * @internal
 */
var ContentBlockIds = {
    classes: {
        name: 'sc-content-block',
    },
    selectors: {
        ofName: '.sc-content-block',
    },
};

;// CONCATENATED MODULE: ./src/constants/debug.ts
/**
 * @internal
 */
var Debug = {
    cms: {
        autoDump: false,
        run: true,
    },
};

;// CONCATENATED MODULE: ./src/constants/dialog-paths.ts
/**
 * @internal
 */
var DialogPaths;
(function (DialogPaths) {
    DialogPaths["quickDialog"] = "dist/quickDialog/";
    DialogPaths["eavUi"] = "dist/ng-edit/";
})(DialogPaths || (DialogPaths = {}));

;// CONCATENATED MODULE: ./src/constants/ids.ts
/**
 * @internal
 */
var IDs = {
    // classes
    cls: {
        scMenu: 'sc-menu',
    },
    attr: {
        toolbar: 'toolbar',
        toolbarData: 'data-toolbar',
        settings: 'settings',
        settingsData: 'data-settings',
    },
    publishAllowed: 'DraftOptional',
    sel: {
        scMenu: '.sc-menu',
        tagScMenu: 'ul.sc-menu',
    },
};

;// CONCATENATED MODULE: ./src/constants/toolbar.ts
// The parts themselves must also be constants
/**
 * @internal
 */
var ToolbarConstants = {
    attrToMarkInitalized: '2sxc-tagtoolbar',
    attr: {
        full: 'sxc-toolbar',
        hover: 'sxc-toolbar-hover',
        disable: 'data-disable-toolbar',
    },
    classes: {
        oldHover: 'sc-element',
    },
    selectors: {
        ofOldHover: '.sc-element',
    },
    eventNames: {
        onInit: 'toolbar-init',
    },
};

;// CONCATENATED MODULE: ./src/constants/index.ts





/**
 * Attribute Names used in the HTML
 */
var Attributes = {
    InstanceId: 'data-cb-instance',
    Context: 'data-edit-context',
    ContentBlockId: 'data-cb-id',
};
/**
 * @internal
 */
var C = {
    ContentBlock: ContentBlock,
    DialogPaths: DialogPaths,
    IDs: IDs,
    AttrNames: Attributes,
    ClsNames: {
        UnInitialized: 'sc-uninitialized',
        UnAvailable: 'sc-unavailable',
    },
    Toolbar: ToolbarConstants,
    Cb: ContentBlockIds,
    Debug: Debug,
    Sel: {
        SxcDivs: "div[".concat(Attributes.Context, "]"),
    },
};

;// CONCATENATED MODULE: ../core/constants/index.ts
/** @internal */
var ToSxcName = "2sxc";
/** @internal */
var constants_SxcVersion = "14.12.00";
/** @internal */
var SxcApiUrlRoot = 'desktopmodules/2sxc/api/';
/** @internal */
var HeaderNames = {
    // 2sxc specific header
    ContentBlockId: "ContentBlockId",
    // headers as defined by DNN
    ModuleId: "ModuleId",
    TabId: "TabId",
    // Header which should replace "TabId" in the long run
    PageId: "PageId",
};
/** @internal */
var ApiUrlRoots = ['app', 'app-sys', 'app-api', 'app-query', 'app-content', 'eav', 'view', 'dnn'];
/** @internal */
var AppApiMarker = 'app';
// TODO: this should later lead to remapping of old url calls, but it's not in use yet
// note that these were always 'auto' so `app-content` would need to be come `app/auto/content`
/** @internal */
var AppApiMap = {
    'app-api': 'app/[name]/api',
    'app-query': 'app/[name]/query',
    'app-content': 'app/[name]/content'
};
// These are Not-Defined-IDs.
// Because
/**
 * This is a marker for an ID which is not defined
 * This is for situations where a 0 or even a negative number
 * could be real numbers, so this number is so big, it should never be a real ID
 * @internal
 */
var NumberNotDefinedHuge = 274200000000;

;// CONCATENATED MODULE: ../core/logging/log-entry-options.ts
/** @internal */
var LogEntryOptions;
(function (LogEntryOptions) {
    LogEntryOptions["log"] = "log";
    LogEntryOptions["warn"] = "warn";
    LogEntryOptions["error"] = "error";
    LogEntryOptions["throw"] = "throw";
})(LogEntryOptions || (LogEntryOptions = {}));

;// CONCATENATED MODULE: ../core/logging/has-log.ts

/**
 * Any object that has an own log object
 * @export
 * @interface HasLog
 * @public
 */
var HasLog = /** @class */ (function () {
    /**
     * initialize the logger
     * ideally it has a parent-logger to attach to
     * @param logName name to show in the logger
     * @param parentLog parent-logger to attach to
     * @param initialMessage optional start-message to log
     * @internal
     */
    function HasLog(logName, 
    /** @internal */
    parentLog, initialMessage) {
        var _this = this;
        this.parentLog = parentLog;
        /** @internal */
        this.initLog = function (name, parentLog, initialMessage) { return _this.initLogInternal(name, parentLog, initialMessage); };
        this.initLogInternal(logName, parentLog, initialMessage);
    }
    /** @internal */
    HasLog.prototype.initLogInternal = function (name, parentLog, initialMessage) {
        if (this.log == null)
            // standard & most common case: just create log
            this.log = new Log_Log(name, parentLog, initialMessage);
        else {
            // late-init case, where the log was already created - just reconfig keeping what was in it
            this.log.rename(name);
            this.log.linkLog(parentLog);
            if (initialMessage != null)
                this.log.add(initialMessage);
        }
    };
    return HasLog;
}());


;// CONCATENATED MODULE: ../core/logging/Log.ts

var keepData = location.search.indexOf("debug=true") !== -1;
var maxScopeLen = 3;
var maxNameLen = 6;
var liveDump = false;
var maxEntriesReached = 'Maximum amount of entries added to log, will stop adding more';
/**
 * A log object which will collect log entries for another ojbect
 * @export
 * @interface Log
 * @public
 */
var Log_Log = /** @class */ (function () {
    /**
     * Create a logger and optionally attach it to a parent logger
     * @param string name this logger should use
     * @param Log optional parrent logger to attach to
     * @param string optional initial message to log
     * @internal
     */
    function Log(name, parent, initialMessage) {
        var _this = this;
        /**
         * List of all entries added to this log
         */
        this.entries = new Array();
        /** @internal */
        this.depth = 0;
        /** @internal */
        this.callDepths = [];
        /**
         * Maximum amount of entries to add - to prevent memory hoging
         */
        this.maxEntries = 1000;
        /* if we should live-dump, can be selectively activated */
        /** @internal */
        this.liveDump = liveDump;
        /** @internal */
        this._parentHasLiveDump = false;
        /** @internal */
        this.keepData = keepData;
        /** @internal */
        this._parentHasKeepData = false;
        /**
         * Full identifier of this log-object, with full hierarchy
         * @internal
         */
        this.fullIdentifier = function () {
            return "".concat((_this.parent ? _this.parent.fullIdentifier() : '')).concat(_this.identifier());
        };
        /**
         * link this log to a parent
         * usually happens in constructor, but in rare cases
         * this must be called manually
         * @internal
         */
        this.linkLog = function (parent) {
            _this.parent = parent || _this.parent; // if new parent isn't defined, don't replace
            if (_this.parent) {
                _this._parentHasLiveDump = _this.parent.liveDump || _this.parent._parentHasLiveDump;
                _this._parentHasKeepData = _this.parent.keepData || _this.parent._parentHasKeepData;
            }
        };
        /**
         * scope of this logger - to easily see which ones
         * are about the same topic
         * @internal
         */
        this.scope = 'tdo';
        /**
         * The name of this log, for scenarios where multiple loggers are mixed
         */
        this.name = 'unknwn';
        /**
         * Unique 2-character ID of this specific log object
         * @internal
         */
        this.id = function () { return _this.idCache || (_this.idCache = _this.randomString(2)); };
        /**
         * Unique identifier of this log object, with name and ID
         * @internal
         */
        this.identifier = function () { return "".concat(_this.scope).concat(_this.name, "(").concat(_this.id(), ")"); };
        this.rename(name);
        this.linkLog(parent);
        this.startTime = new Date().getTime();
        if (initialMessage != null)
            this.add(initialMessage);
    }
    /**
     * give this logger a new name
     * usually happens in constructor, but in rare cases
     * it's called manually
     * @param name
     * @internal
     */
    Log.prototype.rename = function (name) {
        try {
            var dot = name.indexOf('.');
            this.scope = dot > 0 ? name.substr(0, Math.min(dot, maxScopeLen)) + '.' : '';
            var rest = dot > 0 ? name.substr(dot + 1) : name;
            this.name = rest.substr(0, Math.min(rest.length, maxNameLen));
            this.name = this.name.substr(0, Math.min(this.name.length, maxNameLen));
        }
        catch (e) {
            /* ignore */
        }
    };
    /**
     * Add a simple message to the log
     * @param message
     *
     * preferred usage is with string parameter:
     * log.add(`description ${ parameter }`);
     *
     * in case that we experience error with normal string parameter, we can use arrow function to enclose parameter like this () => parameter
     * but use it very rarely, because there is certainly a performance implication!
     * log.add(`description ${() => parameter}`);
     */
    Log.prototype.add = function (message, data) {
        // check if the log is already too big
        if (this.entries.length > this.maxEntries)
            return this._prepareMessage(message);
        // if we just reached the max, add special message
        if (this.entries.length === this.maxEntries)
            this._addEntry(this._prepareEntry(maxEntriesReached));
        var entry = this._prepareEntry(message, data);
        this._addEntry(entry);
        return entry.message;
    };
    /** @internal */
    Log.prototype.addData = function (message, data) {
        if (this.logData())
            this.add(message, data);
    };
    /** @internal */
    Log.prototype.logData = function () {
        return this.keepData || this._parentHasKeepData;
    };
    /** @internal */
    Log.prototype._prepareEntry = function (message, data) {
        var msg = this._prepareMessage(message);
        var time = new Date().getTime() - this.startTime;
        var entry = new LogEntry(this, msg, this.depth, time, data);
        return entry;
    };
    /** @internal */
    Log.prototype._prepareMessage = function (message) {
        if (message instanceof Function) {
            try {
                return (message());
            }
            catch (e) {
                return 'err: message undefined';
            }
        }
        return message.toString();
    };
    /** @internal */
    Log.prototype.call = function (name, callParams, message, data) {
        return new LogCall(this, name, callParams, message, data);
    };
    /** @internal */
    Log.prototype._callDepthAdd = function (name) {
        this.depth++;
        this.callDepths.push(name);
    };
    /** @internal */
    Log.prototype._callDepthRemove = function (name) {
        this.depth--;
        var last = this.callDepths.pop();
        if (last !== name) {
            console.warn("log: call depth reduced by '".concat(name, "' but last was '").concat(last, "'"));
        }
    };
    /**
     * helper to create a text-output of the log info
     * @param separator
     * @param start
     * @param end
     * @internal
     */
    Log.prototype.dump = function (one, separator) {
        if (one === void 0) { one = null; }
        if (separator === void 0) { separator = ' - '; }
        if (one)
            this.dumpOne(0, one, separator);
        else
            this.dumpList();
    };
    /** @internal */
    Log.prototype.dumpList = function (start, length) {
        var _this = this;
        if (start === void 0) { start = 0; }
        var index = start;
        this.entries
            .slice(start, length ? start + length : undefined)
            .forEach(function (e) { return _this.dumpOne(index++, e); });
    };
    /** @internal */
    Log.prototype.dumpOne = function (index, e, separator) {
        if (separator === void 0) { separator = ' - '; }
        var result = (e.result) ? ' =' + e.result : '';
        var line = ('0000' + index).slice(-4) + ' ' + e.source() + separator + '..'.repeat(e.depth) + e.message + result;
        if (e.data)
            console.log(line, e.data);
        else
            console.log(line);
    };
    /**
     * add an entry-object to this logger
     * this is often called by sub-loggers to add to parent
     * @param entry
     * @internal
     */
    Log.prototype._addEntry = function (entry) {
        if (this.liveDump)
            this.dump(entry);
        this.entries.push(entry);
        if (this.parent)
            this.parent._addEntry(entry);
    };
    /**
     * helper to generate a random 2-char ID
     * @param stringLength
     * @internal
     */
    Log.prototype.randomString = function (stringLength) {
        var chars = '0123456789abcdefghiklmnopqrstuvwxyz';
        var randomstring = '';
        for (var i = 0; i < stringLength; i++) {
            var rnum = Math.floor(Math.random() * chars.length);
            randomstring += chars.substring(rnum, rnum + 1);
        }
        return randomstring;
    };
    return Log;
}());


;// CONCATENATED MODULE: ../core/logging/log-call.ts

/** @internal */
var LogCall = /** @class */ (function () {
    function LogCall(log, name, callParams, message, data) {
        this.log = log;
        this.name = name;
        this.initialEntry = this.log._prepareEntry(name + '(' + (callParams || '') + ')');
        this.log._callDepthAdd(name);
        this.log._addEntry(this.initialEntry);
        if (typeof message === 'string')
            this.add(message);
        if (data)
            for (var key in data)
                this.data('initial:' + key, data[key]);
    }
    LogCall.prototype.add = function (message, data, behavior) {
        this.lastMessage = message;
        this.log.add(message, data);
        if (behavior)
            this.processExtraBehavior(behavior, message, data);
    };
    LogCall.prototype.onlyAddIfNew = function (message, behavior) {
        if (this.lastMessage !== message)
            this.add(message);
        if (behavior)
            this.processExtraBehavior(behavior, message, undefined);
    };
    /** Add data - but only if data logging is enabled */
    LogCall.prototype.data = function (message, data) {
        this.log.addData(message, data);
    };
    LogCall.prototype.done = function (message, behavior) {
        this.return(null, message || 'ðŸ‘', behavior);
    };
    LogCall.prototype.return = function (result, message, behavior) {
        message = message || 'ðŸ‘';
        this.initialEntry.result = message;
        this.log._callDepthRemove(this.name);
        // if we're in keep-data / debug mode, keep that
        this.initialEntry.data = result;
        // if we're in live-dump mode, then the entry was already dumped, show again
        if (this.log.liveDump || this.log._parentHasLiveDump)
            this.add(this.name + ' = ' + message, result);
        if (behavior)
            this.processExtraBehavior(behavior, message, result);
        return result;
    };
    /*
     * treat all extra output or errors
     * to allow setting a debug stop point when needed
     * then you can trace the stack-call to see where the error originated
     */
    LogCall.prototype.processExtraBehavior = function (behavior, message, data) {
        if (behavior === LogEntryOptions.log)
            console.log(message, data);
        if (behavior === LogEntryOptions.warn)
            console.warn(message, data);
        if (behavior === LogEntryOptions.error || behavior === LogEntryOptions["throw"])
            console.error(message, data);
        if (behavior === LogEntryOptions["throw"])
            throw message;
    };
    return LogCall;
}());


;// CONCATENATED MODULE: ../core/plumbing/obj.ts
/**
 * Object manipulator helpers
 * @internal
 */
var Obj = /** @class */ (function () {
    function Obj() {
    }
    /**
     * This is the same as Object.assign, but type-safe.
     * Use it as a replacetment for Object.Assign(this, ... ) in constructors
     */
    Obj.TypeSafeAssign = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        args.reduce(function (result, current) {
            return Object.keys(current).reduce(function (target, key) {
                target[key] = current[key];
                return target;
            }, result);
        }, args[0]);
    };
    Obj.DeepClone = function (original, ignoreCircular) {
        if (ignoreCircular === void 0) { ignoreCircular = false; }
        if (original === undefined || original === null)
            return original;
        var str = ignoreCircular ? JSON.stringify(original, getCircularReplacer) : JSON.stringify(original);
        if (str === undefined || str === null)
            return original;
        return JSON.parse(str);
    };
    return Obj;
}());

var getCircularReplacer = function () {
    var seen = new WeakSet();
    return function (_, value) {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return;
            }
            seen.add(value);
        }
        return value;
    };
};

;// CONCATENATED MODULE: ../core/plumbing/url.ts
/** @internal */
function urlClean(original) {
    return original.replace(/(\/+)/g, '/');
}

;// CONCATENATED MODULE: ../core/plumbing/no-jquery.ts
/** @internal */
var NoJQ = /** @class */ (function () {
    function NoJQ() {
    }
    /** https://api.jquery.com/ready/ */
    NoJQ.ready = function (callback) {
        if (document.readyState === 'complete') {
            callback();
        }
        else {
            document.addEventListener('DOMContentLoaded', function () { return callback(); }, { once: true });
        }
    };
    /** https://api.jquery.com/jquery.param/ */
    NoJQ.param = function (obj) {
        var param = Object.entries(obj)
            .map(function (_a) {
            var k = _a[0], v = _a[1];
            return "".concat(encodeURIComponent(k), "=").concat(v == null ? '' : typeof v === 'string' ? encodeURIComponent(v) : encodeURIComponent(JSON.stringify(v)));
        })
            .join('&');
        return param;
    };
    /** Build DOM elements from string */
    NoJQ.domFromString = function (string) {
        // build elements from string into dummy parent
        var dummyParent = document.createElement('div');
        dummyParent.insertAdjacentHTML('afterbegin', string);
        // scripts created from string are not executable and have to recreated manually to be executable
        Array.from(dummyParent.querySelectorAll('script')).forEach(function (brokenScript) {
            var workingScript = document.createElement('script');
            // copy attributes
            Array.from(brokenScript.attributes).forEach(function (attribute) {
                workingScript.setAttribute(attribute.nodeName, attribute.nodeValue);
            });
            // copy inline part
            workingScript.textContent = brokenScript.textContent;
            // replace a non executable script with executable one
            NoJQ.replaceWith(brokenScript, workingScript, false);
        });
        // remove created elements from dummy parent so it can be garbage collected
        var elements = Array.from(dummyParent.children);
        elements.forEach(function (element) {
            dummyParent.removeChild(element);
        });
        return elements;
    };
    /** https://api.jquery.com/offset/ */
    NoJQ.offset = function (element) {
        var clientRect = element.getBoundingClientRect();
        var offset = {
            top: clientRect.top + window.scrollY,
            left: clientRect.left + window.scrollX,
        };
        return offset;
    };
    /** https://api.jquery.com/width/ */
    NoJQ.width = function (element) {
        // jquery width === offsetWidth - borders - padding
        var computedStyle = getComputedStyle(element);
        var width = element.offsetWidth === 0
            ? 0
            : element.offsetWidth
                - (parseInt(computedStyle.getPropertyValue('border-left-width'), 10) + parseInt(computedStyle.getPropertyValue('border-right-width'), 10))
                - (parseInt(computedStyle.getPropertyValue('padding-left'), 10) + parseInt(computedStyle.getPropertyValue('padding-right'), 10));
        return width;
    };
    /** https://api.jquery.com/height/ */
    NoJQ.height = function (element) {
        // jquery height === offsetHeight - borders - padding
        var computedStyle = getComputedStyle(element);
        var height = element.offsetHeight === 0
            ? 0
            : element.offsetHeight
                - (parseInt(computedStyle.getPropertyValue('border-top-width'), 10) + parseInt(computedStyle.getPropertyValue('border-bottom-width'), 10))
                - (parseInt(computedStyle.getPropertyValue('padding-top'), 10) + parseInt(computedStyle.getPropertyValue('padding-bottom'), 10));
        return height;
    };
    /** https://api.jquery.com/outerWidth/ */
    NoJQ.outerWidth = function (element) {
        var outerWidth = element.offsetWidth;
        return outerWidth;
    };
    /** https://api.jquery.com/empty/ */
    NoJQ.empty = function (element) {
        Array.from(element.childNodes).forEach(function (n) {
            element.removeChild(n);
        });
    };
    /** https://api.jquery.com/replacewith/ */
    NoJQ.replaceWith = function (toBeReplaced, newElement, runScripts) {
        var parent = toBeReplaced.parentElement;
        // disable scripts before replacing dom
        var scripts = Array.from(newElement.querySelectorAll('script'));
        var restores = [];
        scripts.forEach(function (script) {
            restores.push({ script: script, type: script.type });
            script.type = null;
        });
        // replace dom
        parent.replaceChild(newElement, toBeReplaced);
        // enable scripts
        restores.forEach(function (restore) {
            restore.script.type = restore.type;
        });
        if (runScripts) {
            // run scripts manually to ensure proper timing
            AssetsLoader.runScripts(scripts, undefined);
        }
    };
    /** https://api.jquery.com/append/ */
    NoJQ.append = function (parent, newElements, runScripts) {
        var scripts = [];
        newElements.forEach(function (element) {
            if (element.tagName.toLocaleLowerCase() === 'script') {
                var script = element;
                // disable script before inserting to the dom
                var restoreType = script.type;
                script.type = null;
                // insert to dom
                parent.appendChild(script);
                // enable script
                script.type = restoreType;
                scripts.push(script);
            }
            else {
                parent.appendChild(element);
            }
        });
        if (runScripts && scripts.length > 0) {
            // run scripts manually to ensure proper timing
            AssetsLoader.runScripts(scripts, undefined);
        }
    };
    return NoJQ;
}());

/** @internal */
var AssetsLoader = /** @class */ (function () {
    function AssetsLoader() {
    }
    /** Asynchronously runs external and inline scripts in series */
    AssetsLoader.runScripts = function (scripts, callback) {
        var _this = this;
        var script = scripts[0];
        var others = scripts.slice(1);
        if (script == null) {
            callback === null || callback === void 0 ? void 0 : callback();
            return;
        }
        // create copy
        var copy = document.createElement('script');
        // attributes
        Array.from(script.attributes).forEach(function (attribute) {
            copy.setAttribute(attribute.nodeName, attribute.nodeValue);
        });
        // inline part
        copy.textContent = script.textContent;
        // if src then insert in head, wait for onload or onerror, remove from head and move to next one
        if (copy.type && copy.src) {
            var listener = function () {
                copy.onload = null;
                copy.onerror = null;
                document.head.removeChild(copy);
                _this.runScripts(others, callback);
            };
            copy.onload = listener;
            copy.onerror = listener;
            document.head.appendChild(copy);
            return;
        }
        // if no src then inline, insert to head and remove instantly and move to next one
        setTimeout(function () {
            document.head.appendChild(copy);
            document.head.removeChild(copy);
            _this.runScripts(others, callback);
        });
    };
    return AssetsLoader;
}());


;// CONCATENATED MODULE: ../core/plumbing/index.ts
//
// Plumbing contains some object manipulation helpers and similarly
// re-used bits of code
//





;// CONCATENATED MODULE: ../core/logging/entry.ts

/**
 * A log entry item
 * @export
 * @interface LogEntry
 * @public
 */
var LogEntry = /** @class */ (function () {
    /** @internal */
    function LogEntry(
    /** @internal */
    log, message, 
    /** @internal */
    depth, 
    /** A timestamp for this entry to better see sequences of things happening */
    time, data) {
        var _this = this;
        this.log = log;
        this.message = message;
        this.depth = depth;
        this.time = time;
        /** @internal */
        this.source = function () { return _this.log.fullIdentifier(); };
        if (data) {
            // #2492 - jQuery isn't used any more in 2sxc
            // if (data instanceof jQuery) {
            //     const jq = data as JQuery;
            //     this.data = {
            //         isJQuery: true,
            //         original: jq,
            //         html: jq.length && jq[0].outerHTML,
            //     };
            // } 
            // else
            this.data = data;
        }
    }
    Object.defineProperty(LogEntry.prototype, "data", {
        /**
         * Data which is logged - if data-logging is enabled
         * @internal
         */
        get: function () {
            return this._data;
        },
        /** @internal */
        set: function (data) {
            if (data === undefined)
                return;
            if (this.log.logData())
                this._data = Obj.DeepClone(data, true);
        },
        enumerable: false,
        configurable: true
    });
    return LogEntry;
}());


;// CONCATENATED MODULE: ../core/logging/insights.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var msgIntro = 'This is the $2sxc JS Insights - see https://r.2sxc.org/insights \n'
    + 'Add ?debug=true to the url to log more data. \n'
    + 'Copy/paste code lines below to see details. \n'
    + '----------------------------------------------------------------------\n';
/** @internal */
var InsightsSingleton = /** @class */ (function (_super) {
    __extends(InsightsSingleton, _super);
    function InsightsSingleton() {
        var _this = _super.call(this, 'Sys.Insght') || this;
        _this.history = {};
        _this.add('system', 'insights', _this.log);
        _this.log.add("this log is usually empty, as it's just a helper tool");
        return _this;
    }
    InsightsSingleton.prototype.add = function (setName, logName, log) {
        if (!(setName in this.history))
            this.history[setName] = new InsightsLogSet(setName);
        this.history[setName].logs.push({ key: logName, log: log });
    };
    InsightsSingleton.prototype.show = function (partName, index, start, length) {
        // if nothing specified, list what to do to see inner parts
        if (!partName) {
            var keys = Object.keys(this.history);
            console.log("".concat(msgIntro).concat(keys.length, " insights-sections found: \n") + keys.map(function (p) { return "$2sxc.insights('".concat(p, "');"); }).join('\n'));
            return;
        }
        // partName found, check if it exists
        var part = this.history[partName];
        if (!part) {
            console.error("part '".concat(partName, "' not found"));
            return;
        }
        // We have a partName, but no index - show list and how to get details
        if (index === undefined) {
            var count_1 = 0;
            var logNames = part.logs
                .map(function (s) { return "$2sxc.insights('".concat(partName, "', ").concat(count_1++, "); - will show for '").concat(s.key, "'"); })
                .join('\n');
            console.log("'".concat(partName, "' contains ").concat(part.logs.length, " entries. Copy/paste the code to to see the logs: \n") + logNames);
            return;
        }
        // verify the entry exists
        var logSet = part.logs.length >= index && part.logs[index];
        if (!logSet) {
            console.error("index ".concat(index, " not found in part '").concat(partName, "'"));
            return;
        }
        if (!logSet.log) {
            console.error("found index ".concat(index, " on part '").concat(partName, "' but it has no logs"));
            return;
        }
        console.log("Will dump the log for ".concat(partName, "[").concat(index, "] '").concat(logSet.key, "'"));
        var autoLimit = false;
        if (start === undefined) {
            autoLimit = true;
            start = 0;
            length = 25;
        }
        logSet.log.dumpList(start || 0, length);
        if (autoLimit && logSet.log.entries.length > length)
            console.warn("Only showing ".concat(length, " of ").concat(logSet.log.entries.length, " logs. To show all, add start param '..., 0)' or start/length '..., 0, 100)'"));
    };
    return InsightsSingleton;
}(HasLog));
// tslint:disable-next-line: max-classes-per-file
var InsightsLogSet = /** @class */ (function () {
    function InsightsLogSet(name) {
        this.name = name;
        this.logs = [];
    }
    return InsightsLogSet;
}());
// ensure it's only created once
// this is important, because the inpage code also uses this class
// and would otherwise create the object separately
var singleton = window.$2sxc && window.$2sxc._insights // try to load existing
    || new InsightsSingleton(); // otherwise create new
/** @internal */
var insights_Insights = singleton;

;// CONCATENATED MODULE: ../core/logging/index.ts







;// CONCATENATED MODULE: ../core/index.ts




;// CONCATENATED MODULE: ./src/core/index.ts
// Logging system is used from $2sxc API
/**
 * @internal
 */


;// CONCATENATED MODULE: ./src/plumbing/TypeTbD.ts
// These types here are alias-types used for conversions and casting
// We created aliases, so we can specifically see where/why we are doing this
/**
 * @internal
 */
function isNothing(thing) {
    return thing === undefined || thing === null;
}

;// CONCATENATED MODULE: ./src/plumbing/index.ts



;// CONCATENATED MODULE: ../connect-parts/inpage-quick-dialog/quick-dialog-params.ts
/**
 * These are all the url params the UI needs to function
 * @internal
 */
var urlParams = {
    // These are used in UI.html, but we keep them here so we have a full list documented
    pageId: 'tid',
    /**
     *  request verification token header name
     */
    requestVerificationTokenHeader: 'rvth',
    /**
     *  request verification token value
     */
    requestVerificationToken: 'rvt',
    api: 'api',
    /**
     * Context: App we're on.
     * This is often 0 (zero) as initially it's not known.
     */
    appId: 'appId',
    /**
     * Selection of what apps should be shown by the dialog
     * this is an optional parameter
     */
    apps: 'apps',
    /** Context: Module we're on */
    moduleId: 'mid',
    /** Context: ContentBlock we're on */
    contentBlockId: 'cbid',
};

;// CONCATENATED MODULE: ../connect-parts/inpage-quick-dialog/index.ts






;// CONCATENATED MODULE: ./src/sxc/sxc-tools.ts

/**
 * @internal
 */
var SxcTools = /** @class */ (function () {
    function SxcTools() {
    }
    SxcTools.get = function (module, cbid) {
        // 2021-09-17 spm assume this function doesn't use jquery
        var sxc = window.$2sxc(module, cbid);
        return sxc;
    };
    /**
     * get edit-context info of html element or sxc-object
     */
    SxcTools.getEditContext = function (sxc, htmlElement) {
        var editContextTag = (htmlElement)
            ? SxcTools.getContainerTag(htmlElement)
            : SxcTools.getTag(sxc);
        return SxcTools.getEditContextOfTag(editContextTag);
    };
    /**
     * get the edit-context object (a json object) of the current tag/sxc-instance
     * @returns edit-context object
     */
    SxcTools.getEditContextOfTag = function (htmlTag) {
        var attr = htmlTag === null || htmlTag === void 0 ? void 0 : htmlTag.getAttribute(C.AttrNames.Context);
        return JSON.parse(attr || '{ }');
    };
    /**
     * get nearest html tag of the sxc instance with data-edit-context
     */
    SxcTools.getContainerTag = function (htmlTag) {
        return htmlTag.closest(C.Sel.SxcDivs);
    };
    /**
     * get a html tag of the sxc instance
     * @returns resulting html
     */
    SxcTools.getTag = function (sxci) {
        return document.querySelector("div[".concat(C.AttrNames.ContentBlockId, "='").concat(sxci.cbid, "']"));
    };
    return SxcTools;
}());


;// CONCATENATED MODULE: ./src/html/dom-tools.ts


/**
 * @internal
 */
var HtmlTools = /** @class */ (function () {
    function HtmlTools() {
    }
    HtmlTools.disable = function (tag) {
        tag.setAttribute(C.Toolbar.attr.disable, 'true');
    };
    HtmlTools.isDisabled = function (sxc) {
        var tag = SxcTools.getTag(sxc);
        return !!tag.getAttribute(C.Toolbar.attr.disable);
    };
    /**
     * Find the text of one or more attributes in fallback order, till we found one
     */
    HtmlTools.getFirstAttribute = function (toolbar, name1, name2) {
        return HtmlTools.tryGetAttrText(toolbar, name1) || HtmlTools.tryGetAttrText(toolbar, name2) || '{}';
    };
    /**
     * Get text-content of an attribute (or return null)
     */
    HtmlTools.tryGetAttrText = function (tag, name) {
        var item1 = tag.attributes.getNamedItem(name);
        return item1 && item1.textContent;
    };
    /**
     * Add html classes to a DOM element
     */
    HtmlTools.addClasses = function (element, classes) {
        if (!classes)
            return;
        if (classes.indexOf(','))
            classes = classes.replace(',', ' ');
        var classessArray = classes.split(' ');
        for (var c = 0; c < classessArray.length; c++)
            if (classessArray[c])
                element.classList.add(classessArray[c]);
    };
    return HtmlTools;
}());


;// CONCATENATED MODULE: ./src/commands/command.ts
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * @internal
 */
var Command = /** @class */ (function () {
    function Command(name) {
        this.name = name;
    }
    /**
     *
     * @internal
     */
    Command.prototype.mergeDefaults = function (translateKey, icon, uiOnly, partOfPage, more) {
        if (typeof (partOfPage) !== 'boolean')
            throw 'partOfPage in commands not provided, order will be wrong!';
        this.buttonDefaults = __assign({ icon: function (_) { return "icon-sxc-".concat(icon); }, title: function (_) { return "Toolbar.".concat(translateKey); }, uiActionOnly: function (_) { return uiOnly; }, partOfPage: function (_) { return partOfPage; } }, more);
    };
    /**
     *
     * @returns
     * @internal
     */
    Command.build = function (name, translateKey, icon, uiOnly, partOfPage, more) {
        var cmd = new Command(name);
        // Toolbar API v2
        cmd.mergeDefaults(translateKey, icon, uiOnly, partOfPage, more);
        return cmd;
    };
    /**
     * @internal
     */
    Command.clone = function (command, name) {
        var clone = new Command(name);
        clone.buttonDefaults = command.buttonDefaults;
        return clone;
    };
    return Command;
}());


;// CONCATENATED MODULE: ./src/commands/commands.ts
var commands_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Singleton Catalog of all commands
 * @internal
 */
var Commands = /** @class */ (function (_super) {
    commands_extends(Commands, _super);
    function Commands() {
        var _this = _super.call(this, 'Cmd.Catlog') || this;
        _this.commandList = [];
        _this.list = {}; // hash - table of action definitions, to be used a list()["action - name"]
        _this.get = function (name) { return _this.list[name]; }; // a specific action definition
        insights_Insights.add('system', 'command-catalog', _this.log);
        return _this;
    }
    /** Singleton */
    Commands.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new Commands());
    };
    Commands.add = function (name, translateKey, icon, uiOnly, partOfPage, more) {
        return this.singleton().add(name, translateKey, icon, uiOnly, partOfPage, more);
    };
    Commands.addCommand = function (command) {
        return this.singleton().addCommand(command);
    };
    Commands.prototype.add = function (name, translateKey, icon, uiOnly, partOfPage, more) {
        var cmd = this.addDef(Command.build(name, translateKey, icon, uiOnly, partOfPage, more));
        this.log.add("add command '".concat(name, "'"), cmd);
        return cmd;
    };
    Commands.prototype.addCommand = function (command) {
        var cmd = this.addDef(command);
        this.log.add("add command '".concat(cmd.name, "'"), cmd);
    };
    Commands.prototype.addDef = function (def) {
        if (!this.list[def.name]) {
            // add
            this.commandList.push(def);
            this.list[def.name] = def;
        }
        else if (this.list[def.name] !== def) {
            // update
            this.list[def.name] = def;
        }
        return def;
    };
    return Commands;
}(HasLog));


;// CONCATENATED MODULE: ./src/commands/command/shared-logic.ts

/**
 * Shared logic like for deciding if we show list buttons
 * here
 * @internal
 */
var SharedLogic = /** @class */ (function () {
    function SharedLogic() {
    }
    SharedLogic.isPartOfBlockList = function (context) {
        return !!(context.contentBlock.isList &&
            context.button.command.params.useModuleList &&
            CmdParHlp.getIndex(context) !== -1); // -1 is the header item
    };
    /**
     * This will tell us, if the item is being referenced (like in a list)
     * It's similar to isBlockList, but will return true even if it's
     * a non-list (single item only)
     */
    SharedLogic.isBlockReference = function (context) {
        return !!context.button.command.params.useModuleList; // -1 is the header item
    };
    SharedLogic.isFieldList = function (context) {
        var _a;
        var params = (_a = context.button) === null || _a === void 0 ? void 0 : _a.command.params;
        return !!((params === null || params === void 0 ? void 0 : params.fields) && (params === null || params === void 0 ? void 0 : params.parent));
    };
    SharedLogic.isList = function (context) {
        return this.isPartOfBlockList(context) || this.isFieldList(context);
    };
    SharedLogic.isReferencedItem = function (context) {
        return this.isBlockReference(context) || this.isFieldList(context);
    };
    return SharedLogic;
}());


;// CONCATENATED MODULE: ./src/commands/command/content-list-actions.ts


//#region WebApi Endpoints used: 2sxc
var webApiAdd = 'cms/block/item';
var webApiRemoveFromList = 'cms/list/delete';
var webApiReorder = 'cms/list/move';
var webApiItemPublish = 'cms/edit/publish';
var webApiBlockPublish = 'cms/block/publish';
//#endregion
/**
 * These actions make changes to a content-block - like adding, removing or publishing items in the block
 * @internal
 */
var ContentListActions = /** @class */ (function () {
    function ContentListActions() {
    }
    /**
     * add an item to the list at this position
     * @param {ContextComplete} context
     * @param {number} index
     */
    ContentListActions.prototype.addItem = function (context, index) {
        return doAndReload(context, webApiAdd, { index: index }, 'post');
    };
    /**
     * remove an item from a list, then reload
     */
    ContentListActions.prototype.removeFromList = function (context) {
        var params = context.button.command.params;
        return doAndReload(context, webApiRemoveFromList, {
            index: CmdParHlp.getIndex(params),
            parent: params.parent,
            fields: params.fields,
        }, 'delete');
    };
    /**
     * change the order of an item in a list, then reload
     */
    ContentListActions.prototype.changeOrder = function (context, index, toIndex) {
        var params = context.button.command.params;
        return doAndReload(context, webApiReorder, {
            parent: params.parent,
            fields: params.fields,
            index: index,
            toIndex: toIndex,
        }, 'post');
    };
    /**
     * set a content-item in this block to published, then reload
     */
    ContentListActions.prototype.publish = function (context, part, index) {
        return doAndReload(context, webApiBlockPublish, {
            part: part,
            index: index,
        }, 'post');
    };
    /**
     * publish an item using it's ID
     */
    ContentListActions.prototype.publishId = function (context, entityId) {
        return doAndReload(context, webApiItemPublish, { id: entityId }, 'post');
    };
    return ContentListActions;
}());
/**
 * @internal
 */
var Actions = new ContentListActions();
/*
 * this is a content block in the browser
 *
 * A Content Block is a stand alone unit of content, with it's own definition of
 * 1. content items
 * 2. template
 * + some other stuff
 *
 * it should be able to render itself
 */
/**
 * internal helper, to do something and reload the content block
 */
function doAndReload(context, url, params, verb, postData) {
    if (verb === void 0) { verb = 'get'; }
    if (postData === void 0) { postData = {}; }
    return (verb === 'post'
        ? context.sxc.webApi.fetchRaw(context.sxc.webApi.url(url, params), postData, 'POST')
        : verb === 'delete'
            ? context.sxc.webApi.fetchRaw(context.sxc.webApi.url(url, params), undefined, 'DELETE')
            : context.sxc.webApi.fetchJson(context.sxc.webApi.url(url, params)))
        .then(function () {
        renderer.reloadAndReInitialize(context);
    });
}

;// CONCATENATED MODULE: ../$2sxc/src/data/target-types.ts
/**
 * Metadata Target Types
 *
 * These are constants to determine what something is assigned to (e.g. it describes an Entity, a file, etc.)
 *
 * Use it for the @see MetadataFor objects
 * @public
 */
var MetadataTargetTypes;
(function (MetadataTargetTypes) {
    /**
     * Undefined Type (0) - included for completeness.
     * Not usually used, actually None (1) is the default
     */
    MetadataTargetTypes[MetadataTargetTypes["Undefined"] = 0] = "Undefined";
    /**
     * Things that are not used as Metadata (1). This is the default for most Entities.
     */
    MetadataTargetTypes[MetadataTargetTypes["None"] = 1] = "None";
    /**
     * Metadata of attributes / fields (2). This is used to store configuration like the field label, amount-of-rows, etc.
     * Remarks =
     * The key is always a number (int) pointing to the Attribute ID in the DB.
     */
    MetadataTargetTypes[MetadataTargetTypes["Attribute"] = 2] = "Attribute";
    /**
     * App metadata (3). Used to give Apps additional properties.
     * Remarks =
     * The key should always be an int ID of the App.
     */
    MetadataTargetTypes[MetadataTargetTypes["App"] = 3] = "App";
    /**
     * Metadata of entities / data-items (4).
     * This lets us enhance entities with additional information.
     * Remarks =
     * The Key should always be a GUID
     */
    MetadataTargetTypes[MetadataTargetTypes["Entity"] = 4] = "Entity";
    /**
     * Metadata of a content-type / data-schema (5). Used to give it a description etc.
    */
    MetadataTargetTypes[MetadataTargetTypes["ContentType"] = 5] = "ContentType";
    /**
     * Zone metadata (6) - used to give a Zone additional information.
     * Only used in very special cases, best not use.
     */
    MetadataTargetTypes[MetadataTargetTypes["Zone"] = 6] = "Zone";
    /**
     * Item / Object of the Platform, like a File or Folder etc. (10)
     * Remarks =
     * * The key is usually a string to further specify what it's describing, like "file:72"
     * * The text equivalent is CmsObject
     */
    MetadataTargetTypes[MetadataTargetTypes["CmsItem"] = 10] = "CmsItem";
    /**
     * The entire system / platform - so Metadata for the current Dnn/Oqtane installation (11).
     * Remarks =
     * This is not in use as of now, just added for completeness sakes.
     * New in v13
     */
    MetadataTargetTypes[MetadataTargetTypes["System"] = 11] = "System";
    /**
     * A Site - like the current site (12)
     * Remarks = New in v13</remarks>
     */
    MetadataTargetTypes[MetadataTargetTypes["Site"] = 12] = "Site";
    /**
     * A Site - like the current site (13)
     * Remarks = New in v13 / beta</remarks>
     */
    // [PrivateApi]
    MetadataTargetTypes[MetadataTargetTypes["SiteVariant"] = 13] = "SiteVariant";
    /**
     * A Page - like the current page (14)
     * Remarks = New in v13</remarks>
     */
    MetadataTargetTypes[MetadataTargetTypes["Page"] = 14] = "Page";
    /**
     * A Page - like the current page (15)
     * Remarks = New in v13 / beta</remarks>
     */
    // [PrivateApi]
    MetadataTargetTypes[MetadataTargetTypes["PageVariant"] = 15] = "PageVariant";
    /**
     * A Module - like a module containing some content (16)
     * Remarks = New in v13</remarks>
     */
    MetadataTargetTypes[MetadataTargetTypes["Module"] = 16] = "Module";
    /**
     * A Module - like a module containing some content (17)
     * Remarks = New in v13 / beta</remarks>
     */
    // [PrivateApi]
    MetadataTargetTypes[MetadataTargetTypes["ModuleVariant"] = 17] = "ModuleVariant";
    /**
     * A User - like the admin-user (18)
     * Remarks = New in v13</remarks>
     */
    MetadataTargetTypes[MetadataTargetTypes["User"] = 18] = "User";
    /** Custom target (90). This is what you should use for basic apps which have a custom target that's none of the other defaults. */
    MetadataTargetTypes[MetadataTargetTypes["Custom"] = 90] = "Custom";
    /** Custom target (91). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom1"] = 91] = "Custom1";
    /** Custom target (92). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom2"] = 92] = "Custom2";
    /** Custom target (93). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom3"] = 93] = "Custom3";
    /** Custom target (94). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom4"] = 94] = "Custom4";
    /** Custom target (95). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom5"] = 95] = "Custom5";
    /** Custom target (96). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom6"] = 96] = "Custom6";
    /** Custom target (97). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom7"] = 97] = "Custom7";
    /** Custom target (98). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom8"] = 98] = "Custom8";
    /** Custom target (99). Use this for basic apps which need multiple different custom targets (advanced, rare use case) */
    MetadataTargetTypes[MetadataTargetTypes["Custom9"] = 99] = "Custom9";
})(MetadataTargetTypes || (MetadataTargetTypes = {}));

;// CONCATENATED MODULE: ../$2sxc/src/data/index.ts



;// CONCATENATED MODULE: ../$2sxc/src/tools/obj2url.ts
// Test code
// window.beta.toUrl({ hello: 7, name: "daniel", sub: { subname: "mettler", subage: 27, subsub: { and: "like"} }, final: 42, null: null}, "test")
// $2sxc.urlParams.toObj($2sxc.urlParams.toUrl({ v1: 1, v2: 2, v3: { v31: 0, v32: { v321: "daniel" } }, v4: 4}));
var equals = '=';
var dot = '.';
var separator = '~';
var sepEsc = '~~';
var stringPrefix = separator;
var space = ' ';
var spaceMarker = '_';
var spaceMarkerEsc = '~_';
var restoreSep = '#'; // can never exist unencoded in the fragment
var innerStringPrefix = 'Â¶';
var bools = ['true', 'false'];
var specialValues = bools.concat(['null']);
/**
 * Custom converter to pass objects into a URL and back.
 * @internal
 */
var ToolUrlObjects = /** @class */ (function () {
    function ToolUrlObjects() {
    }
    ToolUrlObjects.prototype.toUrl = function (obj, encode) {
        if (encode === void 0) { encode = true; }
        if (!obj)
            return '';
        if (Array.isArray(obj))
            throw new Error("only objects can be toUrl(), arrays don't work. Put the array in an object property.");
        var result = this
            .toUrlRecursive(obj, null, 0, encode)
            .filter(function (x) { return x != null && x.length > 0; });
        var urlParam = result.join(separator);
        return urlParam ? separator + urlParam : '';
    };
    ToolUrlObjects.prototype.toObj = function (value, decode, debug) {
        if (decode === void 0) { decode = true; }
        if (debug === void 0) { debug = false; }
        var parts = this.back(value, decode);
        if (debug)
            return parts;
        return unflatStringsToObj(parts);
    };
    /**
     * Converts an object to a compact notation with dots.
     * Recursive, as it needs to also handle sub-objects
     * @param obj
     * @param key
     * @param depth
     * @returns
     */
    ToolUrlObjects.prototype.toUrlRecursive = function (obj, key, depth, encode) {
        var _this = this;
        if (obj == null)
            return [];
        var prefix = depth > 0 ? dot.repeat(depth) : '';
        if (typeof obj !== 'object')
            return ["".concat(prefix).concat(key, "=").concat(encode ? customEncode(obj) : obj)];
        var subItem = Object.keys(obj)
            .map(function (key) { return _this.toUrlRecursive(obj[key], key, depth + 1, encode); });
        if (subItem.length === 0)
            return [];
        var all = subItem.reduce(function (acc, val) {
            return acc.concat(Array.isArray(val) ? arrayFlat(val, 2) : val);
        }, []);
        // Add header entry so the object structure is complete
        var header = depth > 0 ? ["".concat(prefix).concat(key), null] : [];
        return header.concat(all);
    };
    ToolUrlObjects.prototype.back = function (val, decode) {
        if (!val || val.length === 0)
            return [];
        var parts = val
            .replaceAll(equals + stringPrefix, equals + innerStringPrefix) // prot. string prefix
            .replaceAll(sepEsc, restoreSep) // Protect escaped separators
            .split(separator + dot)
            .map(function (v) { return v === null || v === void 0 ? void 0 : v.replaceAll(restoreSep, separator); }) // Restore escaped separators
            .filter(function (x) { return x.length > 0; });
        var result = {};
        var stack = [];
        for (var i = 0; i < parts.length; i++) {
            var pair = parts[i].split(equals);
            var key = pair[0];
            // count leading dots
            var dotCount = key.match(/^\.*/g)[0].length;
            // Reset stack?
            if (dotCount === 0) {
                stack = key.split(dot); // could have multiple components
            }
            else {
                if (dotCount > stack.length)
                    throw new Error("Invalid key: ".concat(key, " when current stack is ").concat(stack.join(dot)));
                var subKey = key.substring(dotCount);
                stack = stack.slice(0, dotCount);
                stack.push(subKey);
                pair[0] = stack.join(dot);
            }
            result[pair[0]] = pair.length > 1
                ? (decode ? restoreValue(decodeURIComponent(pair[1])) : pair[1])
                : null;
        }
        return result;
    };
    return ToolUrlObjects;
}());

// Recursively reduce sub-arrays to the specified depth
function arrayFlat(arr, depth) {
    // If depth is 0, return the array as-is
    if (depth < 1)
        return arr.slice();
    // Otherwise, concatenate into the parent array
    return arr.reduce(function (acc, val) {
        return acc.concat(Array.isArray(val) ? arrayFlat(val, depth - 1) : val);
    }, []);
}
;
// https://stackoverflow.com/questions/42694980/how-to-unflatten-a-javascript-object-in-a-daisy-chain-dot-notation-into-an-objec
function unflatStringsToObj(data) {
    var result = {};
    for (var rec in data) {
        var keys = rec.split(dot);
        keys.reduce(function (list, key, j) {
            return list[key] || (list[key] = isNaN(Number(keys[j + 1])) ? (keys.length - 1 == j ? data[rec] : {}) : []);
        }, result);
    }
    return result;
}
// https://stackoverflow.com/questions/175739/how-can-i-check-if-a-string-is-a-valid-number
function isNumeric(str) {
    if (typeof str != "string")
        return false; // we only process strings!
    return !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
        !isNaN(parseFloat(str)); // ...and ensure strings of whitespace fail
}
/**
 * Mark strings which contain values that look like a bool/number
 */
function customEncode(value) {
    var mark = false;
    // Not a string (a bool/number) - leave as is
    if (typeof value === 'string') { // return value;
        // Escape strings which look like booleans or numbers
        if (specialValues.includes(value) || isNumeric(value))
            mark = true;
        // return `${innerStringPrefix}${value}`;
        // Mark any characters which look like the encoding chars
        value = value
            .replaceAll(separator, sepEsc)
            .replaceAll(spaceMarker, spaceMarkerEsc)
            .replaceAll(' ', spaceMarker);
    }
    var enc = encodeURIComponent(value);
    // marc after encoding
    return (mark ? stringPrefix : '') + enc;
}
/**
 * Restore a value to the real type.
 * Explicitly marked strings will not be re-typed
 */
function restoreValue(value) {
    // if explicitly marked string, unwrap and return string
    if ((value === null || value === void 0 ? void 0 : value.length) > 0 && value[0] === innerStringPrefix)
        return restoreString(value.slice(1));
    if (bools.includes(value))
        return value === 'true';
    if (isNumeric(value))
        return parseFloat(value);
    return restoreString(value);
}
function restoreString(value) {
    var spaceMarkerTemp = String.fromCharCode(1);
    return value
        .replaceAll(spaceMarkerEsc, spaceMarkerTemp)
        .replaceAll(spaceMarker, space)
        .replaceAll(spaceMarkerTemp, spaceMarker);
}

;// CONCATENATED MODULE: ../$2sxc/src/tools/url-params.ts

/**
 * Helper object to read url params.
 * Available on `$2sxc.urlParams`
 * @public
 */
var url_params_UrlParams = /** @class */ (function () {
    function UrlParams() {
    }
    /**
     * Get a param from the url, no matter if it's behind ? or #
     * If not found, will return an empty string `''`
     * @param name
     */
    UrlParams.prototype.get = function (name) {
        // warning: this method is duplicated in 2 places - keep them in sync.
        // locations are eav and 2sxc4ng
        name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
        var searchRx = new RegExp('[\\?&]' + name + '=([^&#]*)', 'i');
        var results = searchRx.exec(location.search);
        var strResult;
        if (results === null) {
            var hashRx = new RegExp('[#&]' + name + '=([^&#]*)', 'i');
            results = hashRx.exec(location.hash);
        }
        // if nothing found, try normal URL because DNN places parameters in /key/value notation
        if (results === null) {
            // Otherwise try parts of the URL
            var matches = location.pathname.match(new RegExp('/' + name + '/([^/]+)', 'i'));
            // Check if we found anything, if we do find it, we must reverse the
            // results so we get the "last" one in case there are multiple hits
            if (matches && matches.length > 1)
                strResult = matches.reverse()[0];
        }
        else
            strResult = results[1];
        return strResult == null
            ? ''
            : decodeURIComponent(strResult.replace(/\+/g, ' '));
    };
    /**
     * Get a required param from the url, no matter if it's behind ? or #
     * Will throw an error if not found
     * @param name
     */
    UrlParams.prototype.require = function (name) {
        var found = this.get(name);
        if (found === '') {
            var message = "Required parameter (".concat(name, ") missing from url - cannot continue");
            alert(message);
            throw message;
        }
        return found;
    };
    /**
     * Checks if debug is enabled in the URL
     * @returns
     */
    UrlParams.prototype.isDebug = function () {
        var _a;
        return ((_a = this.get('debug')) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === 'true';
    };
    /**
     * Convert an object to be used in a URL.
     * Uses a custom, brief syntax which can change at any time.
     * So to unwrap, always use the toObj method.
     * @param obj
     * @returns
     * @internal
     */
    UrlParams.prototype.toUrl = function (obj) {
        return new ToolUrlObjects().toUrl(obj, true);
    };
    /**
     * Convert a url which was created by toUrl back to an object.
     * @param url
     * @returns
     * @internal
     */
    UrlParams.prototype.toObj = function (url) {
        return new ToolUrlObjects().toObj(url, true);
    };
    return UrlParams;
}());


;// CONCATENATED MODULE: ../$2sxc/src/tools/total-popup.ts
/** @internal */
var total_popup_TotalPopup = /** @class */ (function () {
    function TotalPopup() {
        this.frame = undefined;
        this.callback = undefined;
    }
    TotalPopup.prototype.open = function (url, callback) {
        // count parents to see how high the z-index needs to be
        var z = 10000010; // Needs at least 10000000 to be on top of the DNN9 bar
        var p = window;
        while (p !== window.top && z < 10000100) {
            z++;
            p = p.parent;
        }
        var wrapper = document.createElement('div');
        wrapper.setAttribute('style', ' top: 0;left: 0;width: 100%;height: 100%; position:fixed; z-index:' + z);
        document.body.appendChild(wrapper);
        var ifrm = document.createElement('iframe');
        ifrm.setAttribute('allowtransparency', 'true');
        ifrm.setAttribute('style', 'top: 0;left: 0;width: 100%;height: 100%;');
        ifrm.setAttribute('src', url);
        wrapper.appendChild(ifrm);
        document.body.className += ' sxc-popup-open';
        this.frame = ifrm;
        this.callback = callback;
    };
    TotalPopup.prototype.close = function () {
        if (this.frame) {
            document.body.className = document.body.className.replace('sxc-popup-open', '');
            var frm = this.frame;
            frm.parentNode.parentNode.removeChild(frm.parentNode);
            this.callback();
        }
    };
    TotalPopup.prototype.closeThis = function () {
        window.parent.$2sxc.totalPopup.close();
    };
    return TotalPopup;
}());


;// CONCATENATED MODULE: ../$2sxc/src/tools/index.ts



;// CONCATENATED MODULE: ../$2sxc/src/Stats.ts
/** @internal */
var Stats_Stats = /** @class */ (function () {
    function Stats() {
        this.watchDomChanges = 0;
    }
    return Stats;
}());


;// CONCATENATED MODULE: ../$2sxc/src/constants/index.ts
/**
 * This is a placeholder in the settings, which must be replaced with "2sxc" or another term for other dnn extensions
 * @internal
 */
var ApiExtensionPlaceholder = 'e.x.t';
/**
 * The special header meta tag containing settings for 2sxc
 * @internal
 */
var MetaHeaderJsApi = '_jsApi';
/**
 * The fallback path to the UI
 * @internal
 */
var DnnUiRoot = '/desktopmodules/tosic_sexycontent/';
/**
 * @internal
 */
var PlatformOqtane = 'oqtane';
/**
 * @internal
 */
var PlatformDnn = 'dnn';
/**
 * The fallback AntiForgery token header name (as in Dnn)
 * @internal
 */
var AntiForgeryTokenHeaderNameDnn = 'RequestVerificationToken';

;// CONCATENATED MODULE: ../$2sxc/src/environment/env-loader-dnn-sf.ts
var env_loader_dnn_sf_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var helpAutoDetect = 'You must either include jQuery on the page or inject the jsApi parameters to prevent auto-detection.';
/**
 * This helps load environment information from DNN ServicesFramework - it's a fallback in case the other mechanisms fail
 * @internal
 */
var EnvironmentDnnSfLoader = /** @class */ (function (_super) {
    env_loader_dnn_sf_extends(EnvironmentDnnSfLoader, _super);
    function EnvironmentDnnSfLoader(env) {
        var _this = _super.call(this, 'Env.DnnLdr', env.log) || this;
        _this.env = env;
        return _this;
    }
    /**
     * This will assume the new parameter injection failed and it will attempt to fallback
     * it's for backward compatibility, in case something is using $2sxc and doesn't provide the new
     * implementation
     */
    EnvironmentDnnSfLoader.prototype.dnnSfFallback = function () {
        var _this = this;
        var cl = this.log.call('dnnSfFallback');
        // await page-ready to then initialize the stuff
        NoJQ.ready(function () { return _this.dnnSfLoadWhenDocumentReady(); });
        cl.done('started dom-ready watcher');
    };
    EnvironmentDnnSfLoader.prototype.dnnSfLoadWhenDocumentReady = function () {
        var cl = this.log.call('dnnSfLoadWhenDocumentReady');
        if (typeof window.$ === 'undefined') {
            cl.done('error');
            throw "Can't load pageid, moduleid, etc. and $ is not available. \n ".concat(helpAutoDetect);
        }
        var sf = window.$.ServicesFramework;
        if (typeof sf === 'undefined') {
            cl.done('error');
            throw "Can't load pageid, moduleid etc. and DNN SF is not available. \n ".concat(helpAutoDetect);
        }
        var dnnSf = sf(0);
        var apiRoot = dnnSf.getServiceRoot('2sxc');
        var sfJsInfo = {
            page: dnnSf.getTabId(),
            root: 'unknown',
            api: apiRoot,
            appApi: apiRoot,
            rvtHeader: AntiForgeryTokenHeaderNameDnn,
            rvt: dnnSf.getAntiForgeryValue(),
            uiRoot: DnnUiRoot,
            platform: PlatformDnn,
        };
        this.env.load(sfJsInfo, 'dnn SF');
        cl.done();
    };
    return EnvironmentDnnSfLoader;
}(HasLog));


;// CONCATENATED MODULE: ../$2sxc/src/environment/env-loader-dynamic.ts

var InputValue = 'value';
var SelectorInputRvt = "input[name=__RequestVerificationToken]";
/**
 * Special loader for dynamic pages like Oqtane, where content can change at runtime
 * @internal
 */
var EnvironmentLoaderDynamic = /** @class */ (function () {
    function EnvironmentLoaderDynamic(mainLoader) {
        this.mainLoader = mainLoader;
        this.log = new Log_Log('ldr.dynmic', mainLoader.log);
    }
    /**
     * Watch for changes in our special meta header, to update the variables.
     * Important for Oqtane, which changes the page on the fly without reloading.
     */
    EnvironmentLoaderDynamic.prototype.startMetaTagObserver = function (attribute) {
        var _this = this;
        if (!!this.observer)
            return;
        this.observer = new MutationObserver(function (mutationsList) {
            for (var _i = 0, mutationsList_1 = mutationsList; _i < mutationsList_1.length; _i++) {
                var mut = mutationsList_1[_i];
                if (mut.type === 'attributes' && mut.attributeName === attribute)
                    _this.mainLoader.updateEnv(JSON.parse(_this.mainLoader.getMetaContent()));
            }
        });
        this.log.add('start observing meta tag');
        this.observer.observe(this.mainLoader.getJsApiMetaTag(), { attributes: true, childList: false, subtree: false });
    };
    /**
     * Load RequestVerificationToken from the hidden form-field in Oqtane
     */
    EnvironmentLoaderDynamic.prototype.startInputRvtObserver = function () {
        var _this = this;
        if (!!this.inputRvtObserver)
            return;
        this.inputRvtObserver = new MutationObserver(function (mutationsList) {
            for (var _i = 0, mutationsList_2 = mutationsList; _i < mutationsList_2.length; _i++) {
                var mut = mutationsList_2[_i];
                if (mut.type === 'attributes' && mut.attributeName === InputValue)
                    _this.loadRvtFromHiddenInput(mut.target);
            }
        });
        this.log.add('start observing Rvt Input');
        var hiddenField = document.querySelector(SelectorInputRvt);
        if (hiddenField == null) {
            console.error("Can't find Oqtane RVT field with selector ".concat(SelectorInputRvt, "\n") + "So we cannot watch it for changes.\n" + "This will probably cause the $2sxc to fail.");
            return;
        }
        this.loadRvtFromHiddenInput(hiddenField);
        this.inputRvtObserver.observe(hiddenField, { attributes: true, childList: false, subtree: false });
    };
    EnvironmentLoaderDynamic.prototype.loadRvtFromHiddenInput = function (input) {
        this.log.add('Input Rvt updated');
        if (input && input.value)
            this.mainLoader.env.updateRvt(input.value);
    };
    return EnvironmentLoaderDynamic;
}());


;// CONCATENATED MODULE: ../$2sxc/src/environment/env-loader-meta.ts
var env_loader_meta_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




// temp: usually 10, but because Oqtane has some delays, we'll temporarily increase to 100 till we're safe
var maxRetries = 100;
var retryMs = 10;
var MetaSourceId = 'meta header';
var MetaProperty = 'content';
function logTest() {
    console.log('test');
    return true;
}
/**
 * This loads environment information from the meta-header tag.
 * Because of timing issues, it will try multiple times
 * @internal
 */
var EnvironmentMetaLoader = /** @class */ (function (_super) {
    env_loader_meta_extends(EnvironmentMetaLoader, _super);
    function EnvironmentMetaLoader(env) {
        var _this = _super.call(this, 'Env.MetaLd', logTest ? env.log : env.log) || this;
        _this.env = env;
        _this.retries = 0;
        _this.dynamicPageHelper = new EnvironmentLoaderDynamic(_this);
        return _this;
    }
    EnvironmentMetaLoader.prototype.loadMetaFromHeader = function (forceFallback) {
        var _this = this;
        if (forceFallback === void 0) { forceFallback = false; }
        var cl = this.log.call('loadMetaFromHeader', "".concat(forceFallback));
        // avoid duplicate execution
        if (this.env.ready)
            return cl.done('loadMeta - ready');
        this.log.add('loadMetaFromHeader: start, retry:' + this.retries + ', force fallback: ' + forceFallback);
        var meta = this.getMetaContent();
        if (!meta) {
            this.retries++;
            if (forceFallback || this.retries >= maxRetries) {
                new EnvironmentDnnSfLoader(this.env).dnnSfFallback();
                return cl.done();
            }
            setTimeout(function () { _this.loadMetaFromHeader(); }, retryMs);
            return cl.done('will retry');
        }
        // Load the settings
        this.updateEnv(JSON.parse(meta));
        // monitor setting changes - important for Oqtane
        this.dynamicPageHelper.startMetaTagObserver(MetaProperty);
        cl.done();
    };
    EnvironmentMetaLoader.prototype.updateEnv = function (newJsInfo) {
        this.log.add('meta env info updated');
        this.env.load(newJsInfo, MetaSourceId);
        if (newJsInfo.platform === PlatformOqtane)
            this.dynamicPageHelper.startInputRvtObserver();
    };
    EnvironmentMetaLoader.prototype.getMetaContent = function () {
        var ourMeta = this.getJsApiMetaTag();
        if (!ourMeta)
            return null;
        return ourMeta.getAttribute(MetaProperty);
    };
    EnvironmentMetaLoader.prototype.getJsApiMetaTag = function () {
        return document.querySelector("meta[name=".concat(MetaHeaderJsApi, "]"));
    };
    /**
     * Watch for changes in our special meta header, to update the variables.
     * Important for Oqtane, which changes the page on the fly without reloading.
     */
    EnvironmentMetaLoader.prototype.startMetaTagObserver = function () {
        var _this = this;
        if (!!this.observer)
            return;
        this.observer = new MutationObserver(function (mutationsList) {
            for (var _i = 0, mutationsList_1 = mutationsList; _i < mutationsList_1.length; _i++) {
                var mut = mutationsList_1[_i];
                if (mut.type === 'attributes' && mut.attributeName === MetaProperty)
                    _this.updateEnv(JSON.parse(_this.getMetaContent()));
            }
        });
        this.log.add('start observing meta tag');
        this.observer.observe(this.getJsApiMetaTag(), { attributes: true, childList: false, subtree: false });
    };
    return EnvironmentMetaLoader;
}(HasLog));


;// CONCATENATED MODULE: ../$2sxc/src/environment/sxc-global-environment.ts
var sxc_global_environment_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * Provides environment information to $2sxc - usually page-id, api-root and stuff like that
 * @public
 */
var sxc_global_environment_SxcGlobalEnvironment = /** @class */ (function (_super) {
    sxc_global_environment_extends(SxcGlobalEnvironment, _super);
    /** @internal */
    function SxcGlobalEnvironment() {
        var _this = _super.call(this, 'Environment', null, 'starting') || this;
        /**
         * Flag to determine if the environment information is available.
         */
        _this.ready = false;
        /**
         * Where the environment information came from.
         */
        _this.source = '';
        _this.log.keepData = true; // always keep here for clarity
        insights_Insights.add('system', 'environment', _this.log);
        _this.metaLoader = new EnvironmentMetaLoader(_this);
        // check if a global variable was already set which we should use
        if (typeof _jsApi !== typeof undefined) {
            _this.log.add('found _jsApi, will use');
            _this.load(_jsApi, 'global variable _jsApi');
        }
        else {
            _this.log.add('will start initializing');
            _this.metaLoader.loadMetaFromHeader();
        }
        return _this;
    }
    /**
     * Manually load a new EnvironmentSpecs in cases where the page cannot provide them.
     * This is only used in scenarios outside of Dnn / Oqtane, you will usually not need this.
     * @param envSpecs new info to load
     * @param source _optional_ name where the data came from
     */
    SxcGlobalEnvironment.prototype.load = function (envSpecs, source) {
        var cl = this.log.call('load');
        if (envSpecs.root && !envSpecs.api) {
            cl.add('root provided, api missing, will auto-complete');
            var addSlash = (envSpecs.root.endsWith('/') ? '' : '/');
            envSpecs.api = "".concat(envSpecs.root).concat(addSlash).concat(SxcApiUrlRoot);
        }
        this.header = envSpecs;
        // in some cases the UpdateRvt may already have been called before
        // in which case it's probably more relevant
        // so we should set it again
        if (this.replacedRvt)
            this.header.rvt = this.replacedRvt;
        this.ready = true;
        this.source = source || 'external/unknown' + (this.replacedRvt ? '+rvt' : '');
        cl.return(envSpecs, 'loaded from ' + this.source);
    };
    /** @internal */
    SxcGlobalEnvironment.prototype.updateRvt = function (newRvt) {
        if (!newRvt)
            return;
        this.replacedRvt = newRvt;
        this.header.rvt = newRvt;
    };
    /**
     * The API endpoint url from the environment
     */
    SxcGlobalEnvironment.prototype.api = function () {
        this.ensureReadyOrThrow('api');
        return this.header.api;
    };
    // WIP - may return undefined
    /** @internal */
    SxcGlobalEnvironment.prototype.appApi = function () {
        // WIP - must get it to work without 'appApi' but only 'api' to ensure ...
        this.ensureReadyOrThrow('appApi');
        return this.header.appApi;
    };
    /**
     * The current page ID - often needed in API calls
     */
    SxcGlobalEnvironment.prototype.page = function () {
        this.ensureReadyOrThrow('page');
        return this.header.page;
    };
    /**
     * The request verification token header name for internal WebAPI calls
     */
    SxcGlobalEnvironment.prototype.rvtHeader = function () {
        this.ensureReadyOrThrow('rvtHeader');
        return this.header.rvtHeader || AntiForgeryTokenHeaderNameDnn;
    };
    /**
     * The request-verification token for internal WebAPI calls
     */
    SxcGlobalEnvironment.prototype.rvt = function () {
        this.ensureReadyOrThrow('rvt');
        return this.header.rvt;
    };
    /**
     * The uiRoot path
     * @internal
     */
    SxcGlobalEnvironment.prototype.uiRoot = function () {
        this.ensureReadyOrThrow('uiRoot');
        return this.header.uiRoot || DnnUiRoot;
    };
    /**
     * The platform code like 'oqt' or 'dnn' in case the JS needs to know the difference
     */
    SxcGlobalEnvironment.prototype.platform = function () {
        this.ensureReadyOrThrow('platform');
        return this.header.platform || PlatformDnn;
    };
    /**
     * The dialogQuery added in 14.08 because of issues with opening the dialog on sub-portals
     * ATM very internal
     * Don't check if it was initialized, because it's valid if it doesn't exist
     * @internal
     */
    SxcGlobalEnvironment.prototype.dialogQuery = function () {
        var _a;
        return (_a = this.header.dialogQuery) !== null && _a !== void 0 ? _a : null;
    };
    /** @internal */
    SxcGlobalEnvironment.prototype.ensureReadyOrThrow = function (partRequested) {
        if (this.ready)
            return;
        // try one last time - usually it should really be ready by now
        this.log.add('ensureReady - force last attempt to load MetaHeader for ' + partRequested);
        this.metaLoader.loadMetaFromHeader(true);
        // if still not ready, throw exception to console log
        if (this.ready)
            return;
        throw "Can't find ".concat(partRequested, " - something went wrong, pls contact 2sxc.org");
    };
    return SxcGlobalEnvironment;
}(HasLog));


;// CONCATENATED MODULE: ../$2sxc/src/environment/index.ts




;// CONCATENATED MODULE: ../$2sxc/src/sxc/web-api/ajax-promise.ts

/** @internal */
var AjaxPromise = /** @class */ (function () {
    function AjaxPromise(api, sxc) {
        this.api = api;
        this.sxc = sxc;
    }
    /**
     * Make a jQuery style promise request
     * @param settings: settings
     * @returns JQueryPromise<any>
     */
    AjaxPromise.prototype.makePromise = function (settings) {
        var headers = this.api.headers();
        // debugger;
        if (window.$ == null) {
            throw new Error('JQuery is now removed from 2sxc installation. Please use newer api like fetch or include JQuery in your project');
        }
        var promise = window.$.ajax({
            async: true,
            dataType: settings.dataType || 'json',
            data: JSON.stringify(settings.data),
            contentType: 'application/json',
            type: settings.method,
            url: this.getActionUrl(settings),
            beforeSend: function (xhr) {
                for (var key in headers)
                    if (headers.hasOwnProperty(key))
                        xhr.setRequestHeader(key, headers[key]);
            },
        });
        if (!settings.preventAutoFail)
            promise.fail(this.sxc.showDetailedHttpError);
        return promise;
    };
    /**
     * Generate the correct WebApi url
     * @param settings the settings as they would be in jQuery
     */
    AjaxPromise.prototype.getActionUrl = function (settings) {
        var url = settings.url || 'app/auto/api/' + settings.controller + '/' + settings.action;
        // 2020-03-13 stop adding 2sxc endpoint-name, it's already happening in apiUrl so with this it happens 2x
        // var endpoint = settings.endpoint || ToSxcName;
        var base = this.sxc.root.http.apiUrl(url, settings.endpoint);
        return base + (!settings.params ? '' : ('?' + NoJQ.param(settings.params)));
    };
    return AjaxPromise;
}());


;// CONCATENATED MODULE: ../$2sxc/src/sxc/web-api/sxc-web-api.ts
var sxc_web_api_assign = (undefined && undefined.__assign) || function () {
    sxc_web_api_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return sxc_web_api_assign.apply(this, arguments);
};


/**
 * helper API to run ajax / REST calls to the server
 * it will ensure that the headers etc. are set correctly
 * and that urls are rewritten
 * @public
 */
var SxcWebApi = /** @class */ (function () {
    /**
     *
     * @param sxc
     * @internal
     */
    function SxcWebApi(sxc) {
        this.sxc = sxc;
        this.env = sxc.root.env;
    }
    /**
     * **Deprecated** - docs in the separate interface
     * @deprecated use fetchJson instead
     */
    SxcWebApi.prototype.get = function (settingsOrUrl, params, data, preventAutoFail) {
        return this.request(settingsOrUrl, params, data, preventAutoFail, 'GET');
    };
    /**
     * **Deprecated** - docs in the separate interface
     * @deprecated use fetchJson instead
     */
    SxcWebApi.prototype.post = function (settingsOrUrl, params, data, preventAutoFail) {
        return this.request(settingsOrUrl, params, data, preventAutoFail, 'POST');
    };
    /**
     * **Deprecated** - docs in the separate interface
     * @deprecated use fetchJson instead
     */
    SxcWebApi.prototype.delete = function (settingsOrUrl, params, data, preventAutoFail) {
        return this.request(settingsOrUrl, params, data, preventAutoFail, 'DELETE');
    };
    /**
     * **Deprecated** - docs in the separate interface
     * @deprecated use fetchJson instead
     */
    SxcWebApi.prototype.put = function (settingsOrUrl, params, data, preventAutoFail) {
        return this.request(settingsOrUrl, params, data, preventAutoFail, 'PUT');
    };
    /**
     * **Deprecated** - docs in the separate interface
     * @deprecated use fetchJson instead
     */
    SxcWebApi.prototype.request = function (settings, params, data, preventAutoFail, method) {
        // url parameter: auto convert a single value (instead of object of values) to an id=... parameter
        // tslint:disable-next-line:curly
        if (typeof params !== 'object' && typeof params !== 'undefined')
            params = { id: params };
        // if the first parameter is a string, resolve settings
        if (typeof settings === 'string') {
            var controllerAction = settings.split('/');
            var controllerName = controllerAction[0];
            var actionName = controllerAction[1];
            if (controllerName === '' || actionName === '')
                console.warn('Error: controller or action not defined. Will continue with likely errors.');
            settings = {
                controller: controllerName,
                action: actionName,
                params: params,
                data: data,
                url: controllerAction.length > 2 ? settings : null,
                preventAutoFail: preventAutoFail,
            };
        }
        var defaults = {
            method: method === null ? 'POST' : method,
            params: null,
            preventAutoFail: false,
        };
        // new 10.25
        var http = new AjaxPromise(this, this.sxc);
        settings = Object.assign({}, defaults, settings);
        var promise = http.makePromise(settings);
        return promise;
    };
    /**
     * Will retrieve data from the backend using a standard fetch.
     * @param url a full url or short-hand like `controller/method?params` `app/auto/api/controller/method?params`. Note that params would also be specified on the url.
     * @param data optional POST data
     * @param method optional method, defaults to `GET` unless it has data, in which case it defaults to `POST`
     * @returns a Promise containing a Response object, just like a normal fetch would.
     * example: webApi.fetchRaw('Rss/Feed');
     * example: webApi.fetchRaw(webApi.url('Rss/Feed', { id: 47 })); // url params
     * example: webApi.fetchRaw('Rss/Feed', { id: 47 }); // post params
     * example: webApi.fetchRaw(webApi.url('Rss/Feed', { id: 47 }), { something: 'this is a test' }); // url & post params
     * maybe: webApi.fetchRaw({url: 'Rss/Feed', params: { id: 47 }})
     * maybe: webApi.fetchRaw({url: ..., params: { ...}, body: { ...}, method: 'GET' })
     */
    SxcWebApi.prototype.fetchRaw = function (url, data, method) {
        var ctxParams = {};
        var ctx = this.sxc.ctx;
        var urlLower = url.toLocaleLowerCase();
        // Note: #_autoAppIdsInUrl is only used in edit-ui formulas
        if ((ctx === null || ctx === void 0 ? void 0 : ctx._autoAppIdsInUrl) && urlLower.includes('app/auto/')) {
            if ((ctx === null || ctx === void 0 ? void 0 : ctx.appId) && !urlLower.includes('appid='))
                ctxParams.appId = ctx.appId;
            if ((ctx === null || ctx === void 0 ? void 0 : ctx.zoneId) && !urlLower.includes('zoneid='))
                ctxParams.zoneId = ctx.zoneId;
        }
        url = this.url(url, ctxParams);
        method = method || (data ? 'POST' : 'GET');
        var headers = this.headers(method);
        if (data) {
            // test if data is a json. If it's not, convert it to json
            try {
                JSON.parse(data);
            }
            catch (_a) {
                data = JSON.stringify(data);
            }
        }
        return fetch(url, sxc_web_api_assign({ headers: headers, method: method }, (data && { body: data })));
    };
    // Note: fetch was documented in v12.10 (December 2021) but will probably never be used externally
    // So we rename it to fetchRaw and later will make fetch just be the json implementation.
    // Renamed and added this warning in 13.04 (2022-03-14), will drop in v14 and probably make it do fetchJson by default
    // Changed functionality in 13.10 (2022-05-04) to make it do fetchJson by default
    // Changed functionality back in 13.11 (2022-05-10) because it seems that Mobius was published using fetch
    // Important: Do not document in the docs, as it shouldn't be used
    /** @internal */
    SxcWebApi.prototype.fetch = function (url, data, method) {
        console.warn("You are calling 'fetch' on the sxc.webApi. This is deprecated will stop in 2sxc v15, please use fetchRaw(...) or fetchJson(...) instead.");
        return this.fetchJson(url, data, method);
    };
    /**
     * Will retrieve data from the backend using a standard fetch and give you an object.
     * @param url a full url or short-hand like `controller/method?params` `app/auto/api/controller/method?params`. Note that params would also be specified on the url.
     * @param data optional POST data
     * @param method optional method, defaults to `GET` unless it has data, in which case it defaults to `POST`
     * @returns a Promise containing any object.
     */
    SxcWebApi.prototype.fetchJson = function (url, data, method) {
        return this.fetchRaw(url, data, method).then(function (response) { return response.json(); });
    };
    /**
     * All the headers which are needed in an ajax call for this to work reliably.
     * Use this if you need to get a list of headers in another system
     */
    SxcWebApi.prototype.headers = function (method) {
        var headers = this.sxc.root.http.headers(this.sxc.id, this.sxc.cbid, this.sxc.ctx);
        if (!method) {
            return headers;
        }
        switch (method.toLocaleUpperCase()) {
            case 'GET':
                headers['Accept'] = 'application/json';
                break;
            default:
                headers['Accept'] = 'application/json';
                headers['Content-Type'] = 'application/json';
        }
        return headers;
    };
    /**
     *
     * @param url A short, medium or long url.
     * Short like `controller/method`,
     * medium like `app/auto/api/controller/method`
     * long like `https://xyz.
     * In all cases it can also have ?params etc.
     * @param params Optional parameters as string or object, will be added to url-params.
     * @returns In the cases of a short/medium url,
     * it will auto-expand to have the full url as needed for an API call.
     */
    SxcWebApi.prototype.url = function (url, params) {
        if (url == null)
            return url;
        var urlAndParams = url.split('#')[0].split('?');
        // url fixes
        url = urlAndParams[0];
        var urlParts = url.split('/');
        if (urlParts.length === 2 && urlParts[0] && urlParts[1]) {
            var controller = urlParts[0];
            var action = urlParts[1];
            url = "app/auto/api/".concat(controller, "/").concat(action);
        }
        url = this.sxc.root.http.apiUrl(url);
        // params fixes
        params = "".concat(urlAndParams[1] || '', "&").concat(params ? typeof params === 'string' ? params : NoJQ.param(params) : '')
            .split('&')
            .filter(function (p) { return !!p; })
            .join('&');
        // result
        url = [url, params].filter(function (p) { return !!p; }).join('?');
        return url;
    };
    return SxcWebApi;
}());


;// CONCATENATED MODULE: ../$2sxc/src/sxc/sxc-part.ts
/**
 * Base class for anything attached to an sxc-instance.
 * This is internal and not important, but we can't keep it out of the docs.
 * @public
 */
var SxcPart = /** @class */ (function () {
    /**
    * Creates an instance of SxcData.
    * @param sxc: sxc
    * @param partName: name of the part
    * @internal
    */
    function SxcPart(
    /** @internal */
    sxc, 
    /** @internal */
    partName) {
        this.sxc = sxc;
        this.partName = partName;
    }
    return SxcPart;
}());


;// CONCATENATED MODULE: ../$2sxc/src/sxc/data/sxc-data-service-base.ts
var sxc_data_service_base_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Base class doing common checks.
 * This is internal and not important, but we can't keep it out of the docs.
 * @public
 */
var SxcDataServiceBase = /** @class */ (function (_super) {
    sxc_data_service_base_extends(SxcDataServiceBase, _super);
    /**
    * Creates an instance of SxcData.
    * @param sxc:
    * @param name: the content-type name
    * @internal
    */
    function SxcDataServiceBase(sxc, name, nameInError) {
        var _this = _super.call(this, sxc, 'data') || this;
        _this.name = name;
        _this.webApi = sxc.webApi;
        // Fail early if something is wrong
        nameInError += ' name ';
        if (name == null)
            throw nameInError + 'is empty';
        if (name.indexOf("/") != -1 || name.indexOf("\\") != -1)
            throw nameInError + 'has slashes - not allowed';
        if (name.indexOf("?") != -1)
            throw nameInError + 'has "?" - not allowed';
        return _this;
    }
    return SxcDataServiceBase;
}(SxcPart));


;// CONCATENATED MODULE: ../$2sxc/src/sxc/data/sxc-data.ts
var sxc_data_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ContentApiRoot = 'app/auto/data';
/**
* Data Service for an App / Sxc-Instance to get/create data of a specific Content-Type
* @public
*/
var SxcData = /** @class */ (function (_super) {
    sxc_data_extends(SxcData, _super);
    /**
    * Creates an instance of SxcData.
    * @param sxc:
    * @param name: the content-type name
    * @internal
    */
    function SxcData(sxc, name) {
        var _this = _super.call(this, sxc, name, 'ContentType') || this;
        _this.name = name;
        return _this;
    }
    /**
     * Get all items of this type.
     */
    SxcData.prototype.getAll = function () {
        return this.getInternal();
    };
    /**
     * Get the specific item with the ID. It will return null if not found
     */
    SxcData.prototype.getOne = function (id) {
        return this.getInternal(id);
    };
    ;
    /** Future
     *  @internal
     */
    SxcData.prototype.getMany = function (criteria, fields) {
        throw 'not implemented - probably v13.5 or something';
    };
    /**
     * Get all or one data entity from the backend
     * @param id optional id as number or string - if not provided, will get all
     * @param params optional parameters - ATM not usefuly but we plan to support more filters etc.
     * @returns an array with 1 or n entities in the simple JSON format
     * @internal
     */
    SxcData.prototype.getInternal = function (id, params) {
        var path = "".concat(ContentApiRoot, "/").concat(this.name);
        if (id && (typeof id === 'string' || typeof id === 'number'))
            path += "/" + id;
        return this.webApi.fetchJson(this.webApi.url(path, params));
    };
    /** @internal */
    SxcData.prototype.create = function (values, metadataFor) {
        var path = "".concat(ContentApiRoot, "/").concat(this.name);
        if (metadataFor != null) {
            if (typeof (metadataFor) === 'string')
                metadataFor = { Target: MetadataTargetTypes.Entity, Guid: metadataFor };
            try {
                values.For = metadataFor;
            }
            catch (_a) { }
        }
        return this.webApi.fetchJson(this.webApi.url(path), values, 'POST');
    };
    /**
     * Update an existing entity with the values supplied
     */
    SxcData.prototype.update = function (id, values) {
        var path = "".concat(ContentApiRoot, "/").concat(this.name, "/").concat(id);
        return this.webApi.fetchJson(this.webApi.url(path), values, 'POST');
    };
    /** @internal */
    SxcData.prototype.delete = function (idOrGuid) {
        var path = "".concat(ContentApiRoot, "/").concat(this.name, "/").concat(idOrGuid);
        return this.webApi.fetchRaw(this.webApi.url(path), undefined, 'DELETE').then(function (response) { return null; });
    };
    return SxcData;
}(SxcDataServiceBase));


;// CONCATENATED MODULE: ../$2sxc/src/sxc/data/sxc-query.ts
var sxc_query_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Instance Query Service
 * @public
 */
var SxcQuery = /** @class */ (function (_super) {
    sxc_query_extends(SxcQuery, _super);
    /**
     * Creates an instance of SxcQuery.
     * @internal
     */
    function SxcQuery(sxc, name) {
        var _this = _super.call(this, sxc, name, 'Query') || this;
        _this.name = name;
        return _this;
    }
    /**
     * Retrieve the entire query with all streams
     *
     * @template T
     * @returns {Promise<T>} containing a object with stream-names and items in the streams.
     */
    SxcQuery.prototype.getAll = function (urlParams, data) {
        return this.getInternal(undefined, urlParams, data);
    };
    SxcQuery.prototype.getStream = function (stream, urlParams, data) {
        if (stream.indexOf(',') !== -1)
            throw "parameter 'stream' can only contain one stream name for 'getStream'";
        return this.getInternal(stream, urlParams, data).then(function (data) {
            if (data == null || !data.hasOwnProperty(stream))
                return [];
            return data[stream];
        });
    };
    /**
     * Get a query but only the mentioned streams.
     * This will reduce the amount of data retrieved on queries that have many streams.
     *
     * @template T The schema/interfaces of what will be returned
     * @param streams name of streams to get, comma separated
     * @param urlParams additional parameters for the URL, either as a string or as a object
     * @param data data to include in case of a POST call - if this is provided, it will use a post
     * @returns {Promise<T>} Promise containing a object with stream-names and items in the streams.
     */
    SxcQuery.prototype.getStreams = function (streams, urlParams, data) {
        return this.getInternal(streams, urlParams, data);
    };
    /**
     * Get all or one data entity from the backend
     * @param id optional id as number or string - if not provided, will get all
     * @param params optional parameters - ATM not usefuly but we plan to support more filters etc.
     * @returns an array with 1 or n entities in the simple JSON format
     * @internal
     */
    SxcQuery.prototype.getInternal = function (streams, params, data) {
        var path = "app/auto/query/" + this.name;
        if (streams && (typeof streams === 'string'))
            path += "?stream=" + streams;
        return this.webApi.fetchJson(this.webApi.url(path, params), data);
    };
    return SxcQuery;
}(SxcDataServiceBase));


;// CONCATENATED MODULE: ../$2sxc/src/sxc/sxc-cms.ts
var sxc_cms_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * This is in charge of sxc.cms on the instance level.
 * ATM it just has the run command.
 * In future, it may also have dedicated command like `layout` etc.
 * @public
 */
var SxcCms = /** @class */ (function (_super) {
    sxc_cms_extends(SxcCms, _super);
    /** @internal */
    function SxcCms(sxc) {
        return _super.call(this, sxc, "cms") || this;
    }
    /**
     * Run a command on this sxc-instance.
     * Requires edit mode to be on, which would enable the edit-JS parts.
     * To use, remember to activate `2sxc.JsCms` on the page
     * @param runParams - real type is actually RunParams
     */
    SxcCms.prototype.run = function (runParams) {
        throw 'cms.run() requires editing to be on, or page-feature "2sxc.JsCms" to be enabled to work';
    };
    return SxcCms;
}(SxcPart));


;// CONCATENATED MODULE: ../$2sxc/src/sxc/sxc.ts
var sxc_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





/**
* The typical sxc-instance object for a specific DNN module or content-block
* @public
*/
var sxc_Sxc = /** @class */ (function (_super) {
    sxc_extends(Sxc, _super);
    /** @internal */
    function Sxc(
    /** the sxc-instance ID, which is usually the DNN Module Id */
    id, 
    /**
     * content-block ID, which is either the module ID, or the content-block definition entity ID
     * this is an advanced concept you usually don't care about, otherwise you should research it
     */
    cbid, 
    /**
     * the id/key of this instance in the cache for reset
     * @internal
     */
    cacheKey, 
    /**
     * The environment information, important for http-calls
     * @internal
     */
    root, 
    /**
     * Custom context information provided by the constructor - will replace auto-context detection
     * @internal
     */
    ctx) {
        var _this = _super.call(this, 'SxcInstance', null, 'Generating for ' + id + ':' + cbid) || this;
        _this.id = id;
        _this.cbid = cbid;
        _this.cacheKey = cacheKey;
        _this.root = root;
        _this.ctx = ctx;
        /** @internal */
        _this._isSxcInstance = true;
        /**
         * manage object which provides access to additional content-management features
         * it only exists if 2sxc is in edit mode (otherwise the JS are not included for these features)
         * @internal
         */
        _this.manage = null; // initialize correctly later on
        /**
         * CMS operations on this sxc-instance, such as opening the edit dialog etc.
         */
        _this.cms = new SxcCms(_this);
        _this.webApi = new SxcWebApi(_this);
        // add manage property, but not within initializer, because inside the manage-initializer it may reference 2sxc again
        try { // sometimes the manage can't be built, like before installing
            if (root._manage)
                root._manage.initInstance(_this);
        }
        catch (e) {
            console.error('error in 2sxc - will only log but not throw', e);
        }
        // ensure that data-APIs used incorrectly shows good warnings
        patchDataWithWarnings(_this.data);
        // this only works when manage exists (not installing) and translator exists too
        if (root._translateInit && _this.manage)
            // ensure that we really have a manage context, otherwise we can't initialize i18n and it doesn't make sense
            if (_this.manage.context && _this.manage.context.app && _this.manage.context.app.currentLanguage)
                root._translateInit(_this.manage); // init translate, not really nice, but ok for now
        return _this;
    }
    /**
     * TypeGuard for TypeScript to verify this is a SxcInstance
     * @param thing
     * @internal
     */
    Sxc.is = function (thing) {
        return thing._isSxcInstance;
    };
    /**
     * Get a data service for a specific content-type.
     *
     * @param contentType: name of the content type which this service will get
     */
    Sxc.prototype.data = function (contentType) {
        return new SxcData(this, contentType);
    };
    /**
     *
     * @param query
     */
    Sxc.prototype.query = function (query) {
        return new SxcQuery(this, query);
    };
    /**
    * converts a short api-call path like "/app/Blog/query/xyz" to the DNN full path
    * which varies from installation to installation like "/desktopmodules/api/2sxc/app/..."
    * @deprecated use http.apiUrl instead
    * @param virtualPath
    * @returns mapped path
    * @internal
    */
    Sxc.prototype.resolveServiceUrl = function (virtualPath) {
        var scope = virtualPath.split('/')[0].toLowerCase();
        // stop if it's not one of our special paths
        if (ApiUrlRoots.indexOf(scope) === -1)
            return virtualPath;
        return this.root.http.apiRoot(ToSxcName) + scope + '/' + virtualPath.substring(virtualPath.indexOf('/') + 1);
    };
    /**
     * Show a nice error with more infos around 2sxc
     * @param result
     * @returns
     * @internal
     */
    Sxc.prototype.showDetailedHttpError = function (result) {
        if (window.console)
            console.log(result);
        // check if the error was just because a language file couldn't be loaded - then don't show a message
        if (result.status === 404 &&
            result.config &&
            result.config.url &&
            result.config.url.indexOf('/dist/i18n/') > -1) {
            if (window.console)
                console.log('just fyi: failed to load language resource; will have to use default');
            return result;
        }
        // if it's an unspecified 0-error, it's probably not an error but a cancelled request,
        // (happens when closing popups containing angularJS)
        if (result.status === 0 || result.status === -1)
            return result;
        // let's try to show good messages in most cases
        var infoText = 'Had an error talking to the server (status ' + result.status + ').';
        var srvResp = result.responseText
            ? JSON.parse(result.responseText) // for jquery ajax errors
            : result.data; // for angular $http
        if (srvResp) {
            var msg = srvResp.Message;
            if (msg)
                infoText += '\nMessage: ' + msg;
            var msgDet = srvResp.MessageDetail || srvResp.ExceptionMessage;
            if (msgDet)
                infoText += '\nDetail: ' + msgDet;
            if (msgDet && msgDet.indexOf('No action was found') === 0)
                if (msgDet.indexOf('that matches the name') > 0)
                    infoText += '\n\nTip from 2sxc: you probably got the action-name wrong in your JS.';
                else if (msgDet.indexOf('that matches the request.') > 0)
                    infoText += '\n\nTip from 2sxc: Seems like the parameters are the wrong amount or type.';
            if (msg && msg.indexOf('Controller') === 0 && msg.indexOf('not found') > 0)
                infoText +=
                    // tslint:disable-next-line:max-line-length
                    "\n\nTip from 2sxc: you probably spelled the controller name wrong or forgot to remove the word 'controller' from the call in JS. To call a controller called 'DemoController' only use 'Demo'.";
        }
        // tslint:disable-next-line:max-line-length
        infoText += '\n\nif you are an advanced user you can learn more about what went wrong - discover how on 2sxc.org/help?tag=debug';
        alert(infoText);
        return result;
    };
    /**
     * Test if the current code is in edit-mode and additional javascripts have been loaded to make it work
     * @returns true if we are in edit-mode
     */
    Sxc.prototype.isEditMode = function () {
        var _a;
        return ((_a = this.manage) === null || _a === void 0 ? void 0 : _a._isEditMode()) === true;
    };
    /**
     *
     * @param resetCache
     * @returns
     * @internal
     */
    Sxc.prototype.recreate = function (resetCache) {
        if (resetCache)
            delete this.root._controllers[this.cacheKey]; // clear cache
        return this.root(this.id, this.cbid); // generate new
    };
    return Sxc;
}(HasLog));

// Help cach error on call of old code
// Background: From v3 to v12 data had a unusualy system for retrieving data belonging to the module
// We believe it's almost never used, but the TimelineJs App always used it, and we believe
// 2-3 other examples may have as well. 
// Now in v13 sxc.data is used to get any kind of data,
// and we want to make sure that old code will show a warning helping people fix this
// All the old code would have started with sxc.data.on('load', ...) so this is where we give them the error
// We only do this if it hasn't been done already
function patchDataWithWarnings(data) {
    if (!data.on) {
        data.on = function () { throw warning; };
        Object.defineProperty(data, 'sourceUrl', {
            get: function () { throw warning; }
        });
    }
}
var warning = 'Warning Obsolete Feature on 2sxc JS: the .data has been obsolete for a long time and is repurposed. \n'
    + 'If you are calling ".data.on(...)" or ".data.sourceUrl" you are running very old code. \n'
    + 'Guidance to fix this: https://r.2sxc.org/brc-13-id.';

;// CONCATENATED MODULE: ../$2sxc/src/sxc/index.ts












;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/context-identifier.ts
/**
 * ContextIdentifier is used to initialize a Sxc object outside of the default context.
 * @public
 */
var context_identifier_ContextIdentifier = /** @class */ (function () {
    function ContextIdentifier() {
    }
    /**
     * Type Guard to determine if an object is a ContextIdentifier
     * @param original
     * @returns
     * @internal
     */
    ContextIdentifier.is = function (original) {
        var origAsContextId = original;
        return origAsContextId.zoneId !== undefined && origAsContextId.appId !== undefined;
    };
    /**
     * Internal
     * @param ctx
     * @internal
     */
    ContextIdentifier.ensureCompleteOrThrow = function (ctx) {
        // if it's fulfills the minimum requirements
        if (ctx.zoneId && ctx.appId)
            return ctx;
        var msg = "It looks like the id given is a ContextIdentifier, but it's missing either zoneId or appId.";
        console.error(msg, ctx);
        throw msg;
    };
    /**
     * Create a string-id to identify in a cache.
     * @param ctx
     * @returns
     * @internal
     */
    ContextIdentifier.toCacheKey = function (ctx) {
        this.ensureCompleteOrThrow(ctx);
        return "".concat(ctx.zoneId, "/").concat(ctx.appId, "/").concat(ctx.pageId, "/").concat(ctx.moduleId, "/").concat(ctx.blockId);
    };
    return ContextIdentifier;
}());


;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/sxc-global-debug.ts

var urlManager = new url_params_UrlParams();
var urlDebugState = urlManager.isDebug() === true;
/** @internal */
var sxc_global_debug_SxcGlobalDebug = /** @class */ (function () {
    function SxcGlobalDebug() {
        this.load = urlDebugState;
        this.uncache = urlManager.get('sxcver');
    }
    return SxcGlobalDebug;
}());


;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/sxc-global-get.ts


// TODO: copied from selectors in inpage project. Probably best to move selectors from inpage to core
var toolbarSelector = ".sc-menu[toolbar],.sc-menu[data-toolbar],[sxc-toolbar]";
var sxcDivsSelector = 'div[data-edit-context]';
/**
 * returns a 2sxc-instance of the id or html-tag passed in
 * @param id
 * @param cbid
 * @returns {}
 * @internal
 */
function sxc_global_get_$2sxcGet(id, cbid) {
    var _a;
    var $2sxc = window.$2sxc;
    $2sxc.log.add('FindSxcInstance(' + id + ',' + cbid);
    if (!$2sxc._controllers)
        throw new Error('$2sxc not initialized yet');
    // Test if it already is such an instance, in which case we just preserve it and return it
    // Used in cases where the $2sxc(something) is just used to ensure it really is this
    if (Sxc.is(id))
        return id;
    // check if it's a context identifier
    var ctx = null;
    if (ContextIdentifier.is(id)) {
        ctx = ContextIdentifier.ensureCompleteOrThrow(id);
        // get moduleId or create fake, based on zone and app because this is used to identify the object in the cache
        id = (_a = ctx.moduleId) !== null && _a !== void 0 ? _a : ctx.zoneId * 100000 + ctx.appId;
    }
    else if (id instanceof HTMLElement && id.matches(toolbarSelector) && !id.closest(sxcDivsSelector)) {
        // for toolbars that are not inside 2sxc modules (e.g. in skin)
        var contextAttr = 'sxc-context';
        var contextAttribute = id.getAttribute(contextAttr);
        var ctxTlbAttribute = JSON.parse(contextAttribute);
        if (ctxTlbAttribute == null)
            throw new Error("Toolbar outside of module without ".concat(contextAttr, " attribute found."));
        return sxc_global_get_$2sxcGet(ctxTlbAttribute);
    }
    // HTMLElement or anything else, try to auto-find...
    if (typeof id === 'object') {
        // if it's a dom-element, use auto-find
        var idTuple = autoFind(id);
        id = idTuple[0];
        cbid = idTuple[1];
    }
    // if content-block is unknown, use id of module, and create an ID in the cache
    if (!cbid)
        cbid = id;
    var cacheKey = ctx != null ? ContextIdentifier.toCacheKey(ctx) : id + ':' + cbid;
    // either get the cached controller from previous calls, or create a new one
    if ($2sxc._controllers[cacheKey]) {
        $2sxc.log.add('Cache found for: ' + cacheKey);
        return $2sxc._controllers[cacheKey];
    }
    return ($2sxc._controllers[cacheKey]
        = new Sxc(id, cbid, cacheKey, $2sxc, ctx));
}
function autoFind(domElement) {
    var containerTag = domElement.closest('.sc-content-block');
    if (!containerTag)
        return null;
    var iid = containerTag.getAttribute('data-cb-instance');
    var cbid = containerTag.getAttribute('data-cb-id');
    if (!iid || !cbid)
        return null;
    return [parseInt(iid, 10), parseInt(cbid, 10)];
}

;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/sxc-global-http.ts
var sxc_global_http_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * Global HTTP Service for information and helpers on `$2sxc.http`
 * @public
 */
var sxc_global_http_SxcGlobalHttp = /** @class */ (function (_super) {
    sxc_global_http_extends(SxcGlobalHttp, _super);
    /** @internal */
    function SxcGlobalHttp(env) {
        var _this = _super.call(this, 'Sxc.Http') || this;
        _this.env = env;
        return _this;
    }
    /**
     * All the headers which are needed in an ajax call.
     * Uses a module and content-block context (but these could also be null)
     * and a full context identifier for advanced operations.
     * @param id _optional_ module ID
     * @param cbid _optional_ content block ID
     * @param ctx _optional_ context information to include in the header
     * @returns Dictionary / Record of headers
     */
    SxcGlobalHttp.prototype.headers = function (id, cbid, ctx) {
        var _a, _b, _c;
        var cl = this.log.call('headers', "".concat(id, ", ").concat(cbid));
        var fHeaders = {};
        var pageId = ((_a = ctx === null || ctx === void 0 ? void 0 : ctx.pageId) !== null && _a !== void 0 ? _a : this.env.page()).toString();
        id = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.moduleId) !== null && _b !== void 0 ? _b : id;
        cbid = (_c = ctx === null || ctx === void 0 ? void 0 : ctx.blockId) !== null && _c !== void 0 ? _c : cbid;
        // TODO: THE #_ignoreHeaders is only used in edit-ui, and should be changed to somehow say use-in-URL
        if (!(ctx === null || ctx === void 0 ? void 0 : ctx._noContextInHttpHeaders)) {
            if (id)
                fHeaders[HeaderNames.ModuleId] = id.toString();
            if (cbid)
                fHeaders[HeaderNames.ContentBlockId] = cbid.toString();
            fHeaders[HeaderNames.TabId] = pageId;
            fHeaders[HeaderNames.PageId] = pageId;
        }
        fHeaders[this.env.rvtHeader()] = this.env.rvt();
        return cl.return(fHeaders, "headers(id:".concat(id, ", cbid:").concat(cbid, ")"));
    };
    /**
     * Get the API-Root path for a specific extension/endpoint
     * @returns
     * @internal Not relevant for 2sxc, only used if calling platform endpoints
     */
    SxcGlobalHttp.prototype.apiRoot = function (endpointName) {
        var cl = this.log.call('apiRoot');
        var result = this.env.api().replace(ApiExtensionPlaceholder, endpointName);
        return cl.return(result, "apiRoot('".concat(endpointName, "')"));
    };
    /**
     * Get the API-Root path for Apps
     * new in v12
     * @internal
     */
    SxcGlobalHttp.prototype.appApiRoot = function () {
        var _a;
        var cl = this.log.call('appApiRoot');
        // try to get it, or fall back to the previous / old convention
        var result = (_a = this.env.appApi()) !== null && _a !== void 0 ? _a : this.apiRoot(ToSxcName);
        return cl.return(result, "appApiRoot()");
    };
    /**
     * Convert short urls like `app/auto/api/Posts/All` to the full URL needed.
     * Will ignore urls which clearly already are the full url.
     * @param url short URL like `app/auto/api/Posts/All`
     * @param endpointName _optional_ endpoint name if accessing a different exotic endpoint
     * @returns the converted, long url with the full endpoint
     */
    SxcGlobalHttp.prototype.apiUrl = function (url, endpointName) {
        var cl = this.log.call('apiUrl');
        this.log.add("apiUrl(url:'".concat(url, "', endpointName:'").concat(endpointName, "')"));
        // null/undefined check
        if (url == null)
            return url;
        // if starts with http: or https: then ignore
        if (!url || url.indexOf('http:') == 0 || url.indexOf('https:') == 0 || url.indexOf('//') == 0)
            return cl.return(url);
        // if no endpoint specified, then also skip absolute and relative urls
        if (!endpointName && (url.indexOf('/') == 0 || url.indexOf('.') == 0))
            return cl.return(url);
        var baseUrl = url.toLocaleLowerCase().startsWith(AppApiMarker)
            ? this.appApiRoot()
            : this.apiRoot(endpointName || ToSxcName);
        // ensure base ends with slash
        if (baseUrl[baseUrl.length - 1] != '/')
            baseUrl += '/';
        // ensure url doesn't start with slash
        if (url[0] == '/')
            url = url.slice(1);
        return cl.return(baseUrl + url);
    };
    return SxcGlobalHttp;
}(HasLog));


;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/sxc-global-bootstrap.ts







/**
 * Build a SXC Controller for the page. Should only ever be executed once
 * @internal
 */
function buildSxcRoot() {
    var rootApiV2 = getRootPartsV2();
    var urlManager = new UrlParams();
    var debug = new SxcGlobalDebug();
    var stats = new Stats();
    var addOn = {
        get: $2sxcGet,
        _controllers: {},
        beta: {},
        // 2022-06-01 2dm disabled, believe this is for the old .data
        // _data: {},
        // this creates a full-screen iframe-popup and provides a close-command to finish the dialog as needed
        totalPopup: new TotalPopup(),
        urlParams: urlManager,
        // note: I would like to remove this from $2sxc, but it's currently
        // used both in the inpage-edit and in the dialogs
        // debug state which is needed in various places
        debug: debug,
        stats: stats,
        insights: function (partName, index, start, length) { return Insights.show(partName, index, start, length); },
        _insights: Insights,
        // 2022-06-01 2dm removed, don't think this is used anywhere
        // mini-helpers to manage 2sxc parts, a bit like a dependency loader
        // which will optimize to load min/max depending on debug state
        // parts: {
        //     getUrl(url: string, preventUnmin: boolean) {
        //         // let r = url;// (preventUnmin || !debug.load) ? url : url.replace('.min', ''); // use min or not
        //         if (debug.uncache && url.indexOf('sxcver') === -1)
        //             return url + ((url.indexOf('?') === -1) ? '?' : '&') + 'sxcver=' + debug.uncache;
        //         return url;
        //     },
        // },
    };
    var merged = Object.assign($2sxcGet, addOn, rootApiV2);
    merged.log.add('sxc controller built');
    console.log("$2sxc ".concat(SxcVersion, " with insights-logging - see https://r.2sxc.org/insights"));
    return merged;
}
/** @internal */
function getRootPartsV2() {
    var log = new Log('$2sxc', null, 'building');
    var env = new SxcGlobalEnvironment();
    return {
        sysinfo: {
            version: SxcVersion,
            description: 'The 2sxc Controller - read more about it on docs.2sxc.org',
        },
        env: env,
        http: new SxcGlobalHttp(env),
        log: log,
    };
}

;// CONCATENATED MODULE: ../$2sxc/src/sxc-global/index.ts







;// CONCATENATED MODULE: ../$2sxc/src/index.ts
/*
    This is just a type-index entry point.
    The purpose is that other 2sxc projects in this repo can access all the types
    in this project from here, without having to know the exact code files

    Note that the order of things in this file can cause trouble
    As webpack needs the order to be correct, meaning some depedencies need to be early
*/
// early things without dependencies, which may be needed by others










;// CONCATENATED MODULE: ./src/context/parts/context-app.ts
/**
 * this will be about the current app, settings of the app, app - paths, etc.
 * @internal
 */
var ContextOfApp = /** @class */ (function () {
    function ContextOfApp(editCtx, sxc) {
        var _a, _b, _c, _d, _e, _f;
        // ContentGroup
        /**
         * IsContent is used for 2 things
         * 1. Determine if certain buttons should be enabled in the toolbar
         * 2. To forward to the quick-dialog, which changes behavior based on this
         * Should default to true, because that's the more basic/restricted mode
         */
        this.isContent = true;
        this.settingsId = null;
        this.resourcesId = null;
        this.supportsAjax = false;
        // Initialize Content-Group App information
        if (editCtx.contentBlock) {
            this.id = editCtx.contentBlock.AppId;
            this.isContent = (_a = editCtx.contentBlock.IsContent) !== null && _a !== void 0 ? _a : true;
            this.resourcesId = (_b = editCtx.contentBlock.AppResourcesId) !== null && _b !== void 0 ? _b : null;
            this.settingsId = (_c = editCtx.contentBlock.AppSettingsId) !== null && _c !== void 0 ? _c : null;
            this.appPath = editCtx.contentBlock.AppUrl; // this is the only value which doesn't have a slash by default. note that the app-root doesn't exist when opening "manage-app"
            this.hasContent = editCtx.contentBlock.HasContent;
            this.supportsAjax = (_d = editCtx.contentBlock.SupportsAjax) !== null && _d !== void 0 ? _d : false;
            this.zoneId = editCtx.contentBlock.ZoneId;
        }
        // if we have more context information, use this to provide possibly missing data
        if (sxc && sxc.ctx) {
            this.id = (_e = this.id) !== null && _e !== void 0 ? _e : sxc.ctx.appId;
            this.zoneId = (_f = this.id) !== null && _f !== void 0 ? _f : sxc.ctx.zoneId;
        }
        // Initialize language information
        if (editCtx.Language) {
            this.currentLanguage = editCtx.Language.Current;
            this.primaryLanguage = editCtx.Language.Primary;
            this.allLanguages = editCtx.Language.All;
        }
    }
    return ContextOfApp;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-content-block.ts
/**
 * information related to the current contentBlock, incl
 * @internal
 */
var ContextOfContentBlock = /** @class */ (function () {
    function ContextOfContentBlock(editCtx) {
        // Initialize Content-Group Values
        var cb = editCtx.contentBlock;
        if (!cb)
            return;
        this.isCreated = cb.IsCreated;
        this.isList = cb.IsList;
        this.queryId = cb.QueryId;
        this.templateId = cb.TemplateId;
        this.templatePath = cb.TemplatePath;
        this.TemplateIsShared = cb.TemplateIsShared;
        this.edition = cb.Edition;
        this.contentTypeId = cb.ContentTypeName;
        this.contentGroupId = cb.Guid;
    }
    return ContextOfContentBlock;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-instance.ts


/**
 * information related to the current DNN module, incl.instanceId,
 * @internal
 */
var ContextOfInstance = /** @class */ (function () {
    function ContextOfInstance(editCtx, sxc) {
        var _a, _b, _c, _d, _e;
        this.isEditable = false;
        this.allowPublish = true;
        // sxc
        this.sxcVersion = constants_SxcVersion;
        this.parameters = null;
        this.sxcRootUrl = '';
        if (editCtx.Environment) {
            this.id = editCtx.Environment.InstanceId;
            this.isEditable = (_a = editCtx.Environment.IsEditable) !== null && _a !== void 0 ? _a : false;
            // sxc
            this.sxcVersion = (_b = editCtx.Environment.SxcVersion) !== null && _b !== void 0 ? _b : constants_SxcVersion;
            this.parameters = editCtx.Environment.parameters;
            this.sxcRootUrl = (_c = editCtx.Environment.SxcRootUrl) !== null && _c !== void 0 ? _c : '';
        }
        if (!this.id)
            // if the module isn't known, check the additional context.
            // Otherwise give it a real number but an obvious fallback
            // This is for integration into other systems which don't need a module-id
            this.id = (_e = (_d = sxc === null || sxc === void 0 ? void 0 : sxc.ctx) === null || _d === void 0 ? void 0 : _d.moduleId) !== null && _e !== void 0 ? _e : -2742;
        if (editCtx.contentBlockReference)
            this.allowPublish = editCtx.contentBlockReference.publishingMode === C.IDs.publishAllowed;
    }
    return ContextOfInstance;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-item.ts
/**
 * information about the current item
 * ATM empty, not sure if it serves a purpose...
 * @internal
 */
var ContextOfItem = /** @class */ (function () {
    // tslint:disable-next-line: no-empty
    function ContextOfItem(editCtx) {
    }
    return ContextOfItem;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-page.ts
/**
 * this will be information related to the current page
 * @internal
 */
var ContextOfPage = /** @class */ (function () {
    // 2020-11-28 #cleanup11.11 2dm - not used, disabled - keep till Jan 2021, then remove from backend-json and drop these comments
    // url: string;
    function ContextOfPage(editCtx, sxc) {
        var _a, _b, _c, _d;
        if (editCtx.Environment) {
            this.id = editCtx.Environment.PageId;
            // 2020-11-28 #cleanup11.11 2dm - not used, disabled - keep till Jan 2021, then remove from backend-json and drop these comments
            // this.url = editCtx.Environment.PageUrl;
        }
        // catch cases where it wasn't provided
        this.id = (_d = (_c = (_a = this.id) !== null && _a !== void 0 ? _a : (_b = sxc === null || sxc === void 0 ? void 0 : sxc.ctx) === null || _b === void 0 ? void 0 : _b.pageId) !== null && _c !== void 0 ? _c : window.$2sxc.env.page()) !== null && _d !== void 0 ? _d : -2742;
    }
    return ContextOfPage;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-system.ts
/**
 * this will be everything about the current system, like system / api -paths etc.
 * @internal
 */
var ContextOfSystem = /** @class */ (function () {
    function ContextOfSystem(editCtx) {
        if (editCtx.error) {
            this.error = editCtx.error.type;
        }
    }
    return ContextOfSystem;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-tenant.ts
/**
 * this will be something about the current tenant(the dnn portal)
 * @internal
 */
var ContextOfTenant = /** @class */ (function () {
    // 2020-11-28 #cleanup11.11 2dm - not used, disabled - keep till Jan 2021, then remove from backend-json and drop these comments
    // id: number;
    // url: string;
    function ContextOfTenant(editCtx) {
        if (editCtx.Environment) {
            // 2020-11-28 #cleanup11.11 2dm - not used, disabled - keep till Jan 2021, then remove from backend-json and drop these comments
            // this.id = editCtx.Environment.WebsiteId;
            // this.url = editCtx.Environment.WebsiteUrl;
        }
    }
    return ContextOfTenant;
}());


;// CONCATENATED MODULE: ./src/context/parts/context-ui.ts
/**
 * ensure that the UI will load the correct assets to enable editing
 * @internal
 */
var ContextOfUi = /** @class */ (function () {
    function ContextOfUi(editCtx) {
        if (editCtx.Ui) {
            this.autoToolbar = editCtx.Ui.AutoToolbar; // toolbar auto-show
            if (editCtx.Ui.Form)
                this.form = editCtx.Ui.Form; // decide which dialog opens, eg ng8
        }
    }
    return ContextOfUi;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/content-block.ts


/**
 * This contains a pointer to a content-block. The data is always provided by the server,
 * so this class is never really instantiated.
 * @internal
 */
var ContentBlockReference = /** @class */ (function () {
    function ContentBlockReference(original) {
        /** How changes are published - draft required/optional */
        this.publishingMode = IDs.publishAllowed;
        /** ID of the reference item - very rarely used */
        this.id = NumberNotDefinedHuge;
        /** GUID of the parent item referencing this Content Block */
        this.parentGuid = null;
        /** Field in which this content block is references */
        this.parentField = null;
        /** Index of the reference - what position it's in in the list of that field */
        this.parentIndex = 0;
        /** If this content is part of the page */
        this.partOfPage = false;
        Object.assign(this, original);
    }
    return ContentBlockReference;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/content-group.ts
/**
 * @internal
 */
var AttrJsonContentGroup = /** @class */ (function () {
    function AttrJsonContentGroup() {
    }
    return AttrJsonContentGroup;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/edit-context-root.ts
/**
 * @internal
 */
var AttrJsonEditContext = /** @class */ (function () {
    function AttrJsonEditContext() {
    }
    return AttrJsonEditContext;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/environment.ts
/**
 * @internal
 */
var AttrJsonEnvironment = /** @class */ (function () {
    function AttrJsonEnvironment() {
    }
    return AttrJsonEnvironment;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/error.ts
/**
 * @internal
 */
var AttrJsonError = /** @class */ (function () {
    function AttrJsonError() {
    }
    return AttrJsonError;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/language.ts
/**
 * @internal
 */
var AttrJsonLanguage = /** @class */ (function () {
    function AttrJsonLanguage() {
    }
    return AttrJsonLanguage;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/parameters-entity.ts
/**
 * @internal
 */
var AttrJsonEntity = /** @class */ (function () {
    function AttrJsonEntity() {
    }
    return AttrJsonEntity;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/ui.ts
/**
 * @internal
 */
var AttrJsonUi = /** @class */ (function () {
    function AttrJsonUi() {
    }
    return AttrJsonUi;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/parts/user.ts
/**
 * @internal
 */
var AttrJsonUser = /** @class */ (function () {
    function AttrJsonUser() {
    }
    return AttrJsonUser;
}());


;// CONCATENATED MODULE: ./src/context/html-attribute/index.ts










;// CONCATENATED MODULE: ./src/context/parts/context-user.ts
var context_user_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * things about the user
 * ~~note that the properties are also used in url-params and ajax calls, so don't rename~~
 * 2022-02-23 2dm - renamed to upper case now, assume it shouldn't have a side effect because
 * it shouldn't be used in ajax calls, since the dialogs get the settings from the backend
 * @internal
 */
var ContextOfUser = /** @class */ (function (_super) {
    context_user_extends(ContextOfUser, _super);
    function ContextOfUser(editCtx) {
        var _this = _super.call(this) || this;
        if (!editCtx || !editCtx.User)
            return _this;
        _this.CanDevelop = editCtx.User.CanDevelop;
        _this.CanAdmin = editCtx.User.CanAdmin;
        return _this;
    }
    ContextOfUser.fromContext = function (context) {
        var user = new ContextOfUser();
        user.CanDevelop = context.user.CanDevelop;
        user.CanAdmin = context.user.CanAdmin;
        return user;
    };
    return ContextOfUser;
}(AttrJsonUser));


;// CONCATENATED MODULE: ./src/context/parts/index.ts










;// CONCATENATED MODULE: ./src/context/bundles/context-bundle-instance.ts



/**
 * @public
 */
var ContextBundleInstance = /** @class */ (function () {
    /** @internal */
    function ContextBundleInstance(editCtx, sxc) {
        this._isContext = true;
        // this will be about the current app, settings of the app, app - paths, etc.
        this.app = new ContextOfApp(editCtx, sxc);
        // information related to the current DNN module, incl.instanceId, etc.
        this.instance = new ContextOfInstance(editCtx, sxc);
        // things about the user
        this.user = new ContextOfUser(editCtx);
        // this will be information related to the current page
        this.page = new ContextOfPage(editCtx, sxc);
        // this will be everything about the current system, like system / api -paths etc.
        this.system = new ContextOfSystem(editCtx);
        // this will be something about the current tenant(the dnn portal)
        this.tenant = new ContextOfTenant(editCtx);
        // ensure that the UI will load the correct assets to enable editing
        this.ui = new ContextOfUi(editCtx);
    }
    /** @internal */
    ContextBundleInstance.is = function (thing) {
        var maybeButton = thing;
        return maybeButton.sxc !== undefined && maybeButton.instance !== undefined;
    };
    return ContextBundleInstance;
}());


;// CONCATENATED MODULE: ./src/context/index.ts














;// CONCATENATED MODULE: ./src/context/bundles/context-bundle-content.ts
var context_bundle_content_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @public
 */
var ContextBundleContent = /** @class */ (function (_super) {
    context_bundle_content_extends(ContextBundleContent, _super);
    /** @internal */
    function ContextBundleContent(editCtx, sxc) {
        var _this = _super.call(this, editCtx, sxc) || this;
        // information about the current item
        _this.item = new ContextOfItem(editCtx);
        _this.contentBlockReference = new ContentBlockReference(editCtx.contentBlockReference);
        // information related to the current contentBlock
        _this.contentBlock = new ContextOfContentBlock(editCtx);
        return _this;
    }
    return ContextBundleContent;
}(ContextBundleInstance));


;// CONCATENATED MODULE: ./src/context/bundles/index.ts





;// CONCATENATED MODULE: ./src/context/bundles/context-bundle-toolbar.ts
var context_bundle_toolbar_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var context_bundle_toolbar_assign = (undefined && undefined.__assign) || function () {
    context_bundle_toolbar_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return context_bundle_toolbar_assign.apply(this, arguments);
};

/**
 * @public
 */
var ContextBundleToolbar = /** @class */ (function (_super) {
    context_bundle_toolbar_extends(ContextBundleToolbar, _super);
    /** @internal */
    function ContextBundleToolbar(editCtx, sxc) {
        return _super.call(this, editCtx, sxc) || this;
        // note that the toolbar will not be filled here, as it will be filled somewhere else
    }
    /** @internal */
    ContextBundleToolbar.prototype.forButton = function (button) {
        // the ContextBundleButton is the same as toolbar, just with .button
        var clone = context_bundle_toolbar_assign({}, this);
        clone.button = button;
        return clone;
    };
    return ContextBundleToolbar;
}(ContextBundleContent));


;// CONCATENATED MODULE: ./src/context/bundles/context-bundle-button.ts
var context_bundle_button_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * @public
 */
var ContextComplete = /** @class */ (function (_super) {
    context_bundle_button_extends(ContextComplete, _super);
    /** @internal */
    function ContextComplete(editCtx, sxc) {
        var _this = _super.call(this, editCtx, sxc) || this;
        /** @internal */
        _this._isCtxComplete = true;
        return _this;
        // note that the button will not be filled here, as it will be filled somewhere else
    }
    /**
     * Primary API to get the context (context is cached)
     * @internal
     */
    ContextComplete.findContext = function (tagOrSxc, cbid) {
        var sxc;
        var containerTag = null;
        if (sxc_Sxc.is(tagOrSxc)) { // it is SxcInstance
            sxc = tagOrSxc;
        }
        else if (typeof tagOrSxc === 'number') { // it is number
            sxc = window.$2sxc(tagOrSxc, cbid);
        }
        else { // it is HTMLElement
            sxc = window.$2sxc(tagOrSxc);
            containerTag = SxcTools.getContainerTag(tagOrSxc);
        }
        var contextOfButton = ContextComplete.getContextInstance(sxc, containerTag);
        contextOfButton.sxc = sxc;
        return contextOfButton;
    };
    /**
     * Create copy of context, so it can be modified before use
     * @internal
     */
    ContextComplete.contextCopy = function (htmlElementOrId, cbid) {
        var contextOfButton = ContextComplete.findContext(htmlElementOrId, cbid);
        // set sxc to null because of cyclic reference, so we can serialize it
        contextOfButton.sxc = null;
        // make a copy
        var copyOfContext = Obj.DeepClone(contextOfButton);
        // bring sxc back to context
        contextOfButton.sxc = window.$2sxc(htmlElementOrId);
        return copyOfContext;
    };
    /**
     * Create new context
     * @param sxc
     * @param htmlElement
     * @internal
     */
    ContextComplete.getContextInstance = function (sxc, htmlElement) {
        var editContext = SxcTools.getEditContext(sxc, htmlElement);
        return new ContextComplete(editContext, sxc);
    };
    /**
     * @internal
     */
    ContextComplete.is = function (thing) {
        return thing._isCtxComplete;
    };
    return ContextComplete;
}(ContextBundleToolbar));


;// CONCATENATED MODULE: ./src/commands/cmd-par-hlp.ts

/**
 * @internal
 */
var CmdParHlp = /** @class */ (function () {
    function CmdParHlp() {
    }
    CmdParHlp.getIndex = function (params) {
        var _a;
        var realParams = (ContextComplete.is(params)) ? params.button.command.params : params;
        return (_a = realParams.index) !== null && _a !== void 0 ? _a : realParams.sortOrder;
    };
    return CmdParHlp;
}());


;// CONCATENATED MODULE: ./src/commands/command/command-add.ts




/**
 * add brings no dialog, just add an empty item
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("add" /* CommandNames.add */, 'AddDemo', 'plus-circled', false, true, {
    showCondition: function (context) { return SharedLogic.isList(context); },
    code: function (context) {
        return Actions.addItem(context, CmdParHlp.getIndex(context) + 1);
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-add-existing.ts


/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("add-existing" /* CommandNames.addExisting */, 'AddExisting', 'add-existing', false, true, {
    dialog: function (_) { return 'replace'; },
    showCondition: function (context) {
        return SharedLogic.isList(context);
    },
    configureLinkGenerator: function (context, linkGenerator) {
        if (SharedLogic.isFieldList(context)) {
            var params = context.button.command.params;
            linkGenerator.items = [{
                    Add: true,
                    Index: CmdParHlp.getIndex(params) + 1,
                    Parent: params.parent,
                    Field: params.fields,
                }];
        }
        else if (SharedLogic.isPartOfBlockList(context)) {
            var topItem = linkGenerator.items[0];
            topItem.Add = true;
            topItem.Index++;
            linkGenerator.items = [topItem];
        }
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-app.ts

/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("app" /* CommandNames.app */, 'App', 'settings', true, false, {
    showCondition: function (context) {
        return context.user.CanAdmin;
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-app-import.ts

/**
 * open the import dialog
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("app-import" /* CommandNames.appImport */, 'Dashboard', '', true, false, {});

;// CONCATENATED MODULE: ./src/commands/command/command-app-resources.ts

/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("app-resources" /* CommandNames.appResources */, 'AppResources', 'translate', true, false, {
    dialog: function (_) { return "edit" /* CommandNames.edit */; },
    disabled: function (context) { return context.app.resourcesId === null; },
    title: function (context) { return "Toolbar.AppResources".concat(context.app.resourcesId === null ? 'Disabled' : ''); },
    // only if resources exist or are 0 (to be created)...
    showCondition: function (context) { return !!context.user.CanAdmin; },
    configureLinkGenerator: function (context, linkGenerator) {
        linkGenerator.items = [{ EntityId: context.app.resourcesId }];
    },
    // if it doesn't have a query, make the button faded
    dynamicClasses: function (context) { return context.app.resourcesId !== null ? '' : 'empty'; },
});

;// CONCATENATED MODULE: ./src/commands/command/command-app-settings.ts

/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("app-settings" /* CommandNames.appSettings */, 'AppSettings', 'sliders', true, false, {
    dialog: function () { return "edit" /* CommandNames.edit */; },
    disabled: function (context) { return context.app.settingsId === null; },
    title: function (context) {
        return "Toolbar.AppSettings".concat(context.app.settingsId === null ? 'Disabled' : '');
    },
    // only if settings exist, or are 0 (to be created)
    showCondition: function (context) { return context.user.CanAdmin; },
    configureLinkGenerator: function (context, linkGenerator) {
        linkGenerator.items = [{ EntityId: context.app.settingsId }];
    },
    // if it doesn't have a settings, make it less strong
    dynamicClasses: function (context) { return context.app.settingsId !== null ? '' : 'empty'; },
});

;// CONCATENATED MODULE: ./src/commands/command/command-apps.ts

/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("apps" /* CommandNames.apps */, 'Zone', 'manage', true, false, {
    showCondition: function (context) {
        return !!context.user.CanAdmin;
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-content-type.ts

/**
 * import this module to commands.ts
 * @internal
 */
var cmd = Command.build("fields" /* CommandNames.fields */, 'ContentType', 'fields', true, false, {
    dialog: function (_) { return "contenttype" /* CommandNames.fields_old_contenttype */; },
    addParamsToLink: createContentTypeParams,
    // only show to admin-users and in cases where we know the content-type
    showCondition: function (context) {
        return !!context.user.CanDevelop && !!createContentTypeParams(context).contentType;
    },
});
Commands.addCommand(cmd);
Commands.addCommand(Command.clone(cmd, "contenttype" /* CommandNames.fields_old_contenttype */));
/**
 * @internal
 */
function createContentTypeParams(context) {
    var result = {
        contentType: context.button.command.params.contentType
            || context.contentBlock.contentTypeId,
    };
    return result;
}

;// CONCATENATED MODULE: ./src/commands/command/command-data.ts


/**
 * import this module to commands.ts
 * @internal
 */
var command_data_cmd = Command.build("data" /* CommandNames.data */, 'ContentItems', 'table', true, false, {
    dialog: function (_) { return "contentitems" /* CommandNames.data_old_contentItems */; },
    addParamsToLink: createContentTypeParams,
    // only show to admin-users and in cases where we know the content-type
    showCondition: function (context) {
        return !!context.user.CanAdmin && !!createContentTypeParams(context).contentType;
    },
    configureLinkGenerator: function (context, linkGenerator) {
        if (context.button.command.params.filters) {
            var enc = JSON.stringify(context.button.command.params.filters);
            // special case - if it contains a "+" character, this won't survive
            // encoding through the hash as it's always replaced with a space, even if it would be pre converted to %2b
            // so we're base64 encoding it - see https://github.com/2sic/2sxc/issues/1061
            if (enc.indexOf('+') > -1)
                enc = btoa(enc);
            linkGenerator.urlParams.filters = enc;
        }
    },
});
Commands.addCommand(command_data_cmd);
Commands.addCommand(Command.clone(command_data_cmd, "contentitems" /* CommandNames.data_old_contentItems */));

;// CONCATENATED MODULE: ./src/commands/command/command-copy.ts


/**
 * open an edit-item dialog
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("copy" /* CommandNames.copy */, 'Copy', 'copy', false, true, {
    dialog: function (_) { return "edit" /* CommandNames.edit */; },
    showCondition: function (ctx) {
        // needs to have an existing entityId to work
        return !!ctx.button.command.params.entityId;
    },
    configureLinkGenerator: function (ctx, linkGenerator) {
        var originalId = ctx.button.command.params.entityId;
        var typeName = createContentTypeParams(ctx).contentType;
        if (!typeName)
            throw new Error("can't copy: missing contentType");
        linkGenerator.items = [{ DuplicateEntity: originalId, ContentTypeName: typeName }];
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-code.ts
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

/**
 * @internal
 */
var paramsName = 'params';
var ctxName = 'context';
var evtName = 'event';
var errPrefix = "Running 'code' command, ";
var errNoCode = "".concat(errPrefix, "but no 'call' found to run - see console for debug info.");
var errCodeNotString = "".concat(errPrefix, "but 'call' doesn't seem to be a string.");
/**
 * import this module to commands.ts
 * This is only available in v14+, before it was called 'custom' and that still exists
 * @internal
 */
var command_code_cmd = Command.build("code" /* CommandNames.code */, 'Custom', 'bomb', true, false, {
    code: function (context, event) {
        return new Promise(function (resolve, reject) {
            var params = context.button.command.params;
            function errAndResolve(message) {
                console.warn(message, params);
                alert(message + '\n See console for details.');
                resolve();
            }
            var code = params.call;
            if (!code)
                return errAndResolve(errNoCode);
            if (typeof code !== 'string')
                return errAndResolve(errCodeNotString);
            if (code.indexOf('(') !== -1 || code.indexOf(' ') !== -1)
                return errAndResolve("".concat(errPrefix, "but 'call' contained '(' or ' ' characters - not allowed."));
            // Make it a signature for the (not good) Function structure
            code += "(".concat(paramsName, ", ").concat(ctxName, ", ").concat(evtName, ")");
            // new signature v14.04 when using 'code' has params first, old had context first
            // 1. clean params from all functions which were added by code in the entire pipeline
            var clean = {};
            Object.entries(params).forEach(function (_a) {
                var k = _a[0], v = _a[1];
                if (typeof v !== 'function')
                    clean[k] = v;
            });
            var action = clean.action, call = clean.call, cleanest = __rest(clean, ["action", "call"]); // remove 'action' and 'call'
            try {
                // Todo: rework to not use 'Function' - use turnOn concept
                var fnNew = new Function(paramsName, ctxName, evtName, code);
                resolve(fnNew(cleanest, context, event));
            }
            catch (err) {
                console.error('error in custom button-code: ', params);
                reject(err);
            }
        });
    },
});
Commands.addCommand(command_code_cmd);

;// CONCATENATED MODULE: ./src/commands/command/old-command-custom.ts

/**
 * @internal
 */
var old_command_custom_ctxName = 'context';
var old_command_custom_evtName = 'event';
var old_command_custom_errNoCode = "Trying to run Custom-Code action, but no 'call' (v10+, recommended) or 'customCode' (v9, old) found to run - see console for debug info.";
/**
 * import this module to commands.ts
 * @internal
 * @deprecated - obsolete in v14.04 but of course still supported
 */
Commands.add("custom" /* CommandNames.code_old_custom */, 'Custom', 'bomb', true, false, {
    code: function (context, event) {
        return new Promise(function (resolve, reject) {
            var actPar = context.button.command.params;
            // the old V9 name
            var code = actPar.customCode;
            // also try the V10 edition - uses `call`
            if (!code) {
                code = actPar.call;
                if (typeof code === 'string' && code.indexOf(' ') === -1 && code.indexOf('(') === -1)
                    code += "(".concat(old_command_custom_ctxName, ", ").concat(old_command_custom_evtName, ")");
            }
            if (!code) {
                console.warn(old_command_custom_errNoCode, actPar);
                alert(old_command_custom_errNoCode);
                resolve();
            }
            try {
                var fn = new Function(old_command_custom_ctxName, old_command_custom_evtName, code);
                resolve(fn(context, event));
            }
            catch (err) {
                console.error('error in custom button-code: ', actPar);
                reject(err);
            }
        });
    },
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toArray.js




function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./node_modules/i18next/dist/esm/i18next.js










function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var consoleLogger = {
  type: 'logger',
  log: function log(args) {
    this.output('log', args);
  },
  warn: function warn(args) {
    this.output('warn', args);
  },
  error: function error(args) {
    this.output('error', args);
  },
  output: function output(type, args) {
    if (console && console[type]) console[type].apply(console, args);
  }
};

var Logger = function () {
  function Logger(concreteLogger) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Logger);

    this.init(concreteLogger, options);
  }

  _createClass(Logger, [{
    key: "init",
    value: function init(concreteLogger) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options.prefix || 'i18next:';
      this.logger = concreteLogger || consoleLogger;
      this.options = options;
      this.debug = options.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this.forward(args, 'log', '', true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this.forward(args, 'warn', '', true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.forward(args, 'error', '');
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }]);

  return Logger;
}();

var baseLogger = new Logger();

var EventEmitter = function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    this.observers = {};
  }

  _createClass(EventEmitter, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;

      events.split(' ').forEach(function (event) {
        _this.observers[event] = _this.observers[event] || [];

        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;

      if (!listener) {
        delete this.observers[event];
        return;
      }

      this.observers[event] = this.observers[event].filter(function (l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function (observer) {
          observer.apply(void 0, args);
        });
      }

      if (this.observers['*']) {
        var _cloned = [].concat(this.observers['*']);

        _cloned.forEach(function (observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);

  return EventEmitter;
}();

function defer() {
  var res;
  var rej;
  var promise = new Promise(function (resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null) return '';
  return '' + object;
}
function copy(a, s, t) {
  a.forEach(function (m) {
    if (s[m]) t[m] = s[m];
  });
}

function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
  }

  function canNotTraverseDeeper() {
    return !object || typeof object === 'string';
  }

  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty) object[key] = new Empty();

    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }

  if (canNotTraverseDeeper()) return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}

function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object),
      obj = _getLastOfPath.obj,
      k = _getLastOfPath.k;

  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object),
      obj = _getLastOfPath2.obj,
      k = _getLastOfPath2.k;

  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path),
      obj = _getLastOfPath3.obj,
      k = _getLastOfPath3.k;

  if (!obj) return undefined;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);

  if (value !== undefined) {
    return value;
  }

  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== '__proto__' && prop !== 'constructor') {
      if (prop in target) {
        if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var _entityMap = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;'
};
function i18next_escape(data) {
  if (typeof data === 'string') {
    return data.replace(/[&<>"'\/]/g, function (s) {
      return _entityMap[s];
    });
  }

  return data;
}
var isIE10 = typeof window !== 'undefined' && window.navigator && typeof window.navigator.userAgentData === 'undefined' && window.navigator.userAgent && window.navigator.userAgent.indexOf('MSIE') > -1;
var chars = [' ', ',', '?', '!', ';'];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || '';
  keySeparator = keySeparator || '';
  var possibleChars = chars.filter(function (c) {
    return nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0;
  });
  if (possibleChars.length === 0) return true;
  var r = new RegExp("(".concat(possibleChars.map(function (c) {
    return c === '?' ? '\\?' : c;
  }).join('|'), ")"));
  var matched = !r.test(key);

  if (!matched) {
    var ki = key.indexOf(keySeparator);

    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }

  return matched;
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';
  if (!obj) return undefined;
  if (obj[path]) return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;

  for (var i = 0; i < paths.length; ++i) {
    if (!current) return undefined;

    if (typeof current[paths[i]] === 'string' && i + 1 < paths.length) {
      return undefined;
    }

    if (current[paths[i]] === undefined) {
      var j = 2;
      var p = paths.slice(i, i + j).join(keySeparator);
      var mix = current[p];

      while (mix === undefined && paths.length > i + j) {
        j++;
        p = paths.slice(i, i + j).join(keySeparator);
        mix = current[p];
      }

      if (mix === undefined) return undefined;
      if (mix === null) return null;

      if (path.endsWith(p)) {
        if (typeof mix === 'string') return mix;
        if (p && typeof mix[p] === 'string') return mix[p];
      }

      var joinedPath = paths.slice(i + j).join(keySeparator);
      if (joinedPath) return deepFind(mix, joinedPath, keySeparator);
      return undefined;
    }

    current = current[paths[i]];
  }

  return current;
}

var ResourceStore = function (_EventEmitter) {
  _inherits(ResourceStore, _EventEmitter);

  var _super = _createSuper(ResourceStore);

  function ResourceStore(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ['translation'],
      defaultNS: 'translation'
    };

    _classCallCheck(this, ResourceStore);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.data = data || {};
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    if (_this.options.ignoreJSONStructure === undefined) {
      _this.options.ignoreJSONStructure = true;
    }

    return _this;
  }

  _createClass(ResourceStore, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);

      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns];
      if (key && typeof key !== 'string') path = path.concat(key);
      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
      }

      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== 'string') return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined) keySeparator = '.';
      var path = [lng, ns];
      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        value = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options.silent) this.emit('added', lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };

      for (var m in resources) {
        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
      }

      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];

      if (lng.indexOf('.') > -1) {
        path = lng.split('.');
        deep = resources;
        resources = ns;
        ns = path[1];
      }

      this.addNamespaces(ns);
      var pack = getPath(this.data, path) || {};

      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }

      setPath(this.data, path, pack);
      if (!options.silent) this.emit('added', lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }

      this.removeNamespaces(ns);
      this.emit('removed', lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === 'v1') return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n = data && Object.keys(data) || [];
      return !!n.find(function (v) {
        return data[v] && Object.keys(data[v]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);

  return ResourceStore;
}(EventEmitter);

var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options, translator) {
    var _this = this;

    processors.forEach(function (processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var checkedLoadedFor = {};

var Translator = function (_EventEmitter) {
  _inherits(Translator, _EventEmitter);

  var _super = _createSuper$1(Translator);

  function Translator(services) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Translator);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], services, _assertThisInitialized(_this));
    _this.options = options;

    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = '.';
    }

    _this.logger = baseLogger.create('translator');
    return _this;
  }

  _createClass(Translator, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };

      if (key === undefined || key === null) {
        return false;
      }

      var resolved = this.resolve(key, options);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options) {
      var nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === undefined) nsSeparator = ':';
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
      var namespaces = options.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);

      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m = key.match(this.interpolator.nestingRegexp);

        if (m && m.length > 0) {
          return {
            key: key,
            namespaces: namespaces
          };
        }

        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }

      if (typeof namespaces === 'string') namespaces = [namespaces];
      return {
        key: key,
        namespaces: namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options, lastKey) {
      var _this2 = this;

      if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
        options = this.options.overloadTranslationOptionHandler(arguments);
      }

      if (!options) options = {};
      if (keys === undefined || keys === null) return '';
      if (!Array.isArray(keys)) keys = [String(keys)];
      var returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;
      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;

      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
          key = _this$extractFromKey.key,
          namespaces = _this$extractFromKey.namespaces;

      var namespace = namespaces[namespaces.length - 1];
      var lng = options.lng || this.language;
      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

      if (lng && lng.toLowerCase() === 'cimode') {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options.nsSeparator || this.options.nsSeparator;

          if (returnDetails) {
            resolved.res = "".concat(namespace).concat(nsSeparator).concat(key);
            return resolved;
          }

          return "".concat(namespace).concat(nsSeparator).concat(key);
        }

        if (returnDetails) {
          resolved.res = key;
          return resolved;
        }

        return key;
      }

      var resolved = this.resolve(keys, options);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
        if (!options.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn('accessing an object - but returnObjects options is not enabled!');
          }

          var r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");

          if (returnDetails) {
            resolved.res = r;
            return resolved;
          }

          return r;
        }

        if (keySeparator) {
          var resTypeIsArray = resType === '[object Array]';
          var copy = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy[m] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy[m] === deepKey) copy[m] = res[m];
            }
          }

          res = copy;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
        var hasDefaultValue = Translator.hasDefaultValue(options);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : '';
        var defaultValue = options["defaultValue".concat(defaultValueSuffix)] || options.defaultValue;

        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }

        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }

        var missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;

        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? defaultValue : res);

          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options), {}, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn('Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.');
          }

          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === 'all') {
            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
          } else {
            lngs.push(options.lng || this.language);
          }

          var send = function send(l, k, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;

            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
            }

            _this2.emit('missingKey', l, namespace, k, res);
          };

          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function (language) {
                _this2.pluralResolver.getSuffixes(language, options).forEach(function (suffix) {
                  send([language], key + suffix, options["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }

        res = this.extendTranslation(res, keys, options, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);

        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== 'v1') {
            res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? "".concat(namespace, ":").concat(key) : key, usedDefault ? res : undefined);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }

      if (returnDetails) {
        resolved.res = res;
        return resolved;
      }

      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options, resolved, lastKey) {
      var _this3 = this;

      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved: resolved
        });
      } else if (!options.skipInterpolation) {
        if (options.interpolation) this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options), {
          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options.interpolation)
        }));
        var skipOnVariables = typeof res === 'string' && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;

        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }

        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
        if (this.options.interpolation.defaultVariables) data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options.lng || this.language, options);

        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options.nest = false;
        }

        if (options.nest !== false) res = this.interpolator.nest(res, function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));

            return null;
          }

          return _this3.translate.apply(_this3, args.concat([key]));
        }, options);
        if (options.interpolation) this.interpolator.reset();
      }

      var postProcess = options.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options) : options, this);
      }

      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === 'string') keys = [keys];
      keys.forEach(function (k) {
        if (_this4.isValidLookup(found)) return;

        var extracted = _this4.extractFromKey(k, options);

        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

        var needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && _this4.pluralResolver.shouldUseIntlApi();

        var needsContextHandling = options.context !== undefined && (typeof options.context === 'string' || typeof options.context === 'number') && options.context !== '';
        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
        namespaces.forEach(function (ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;

          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;

            _this4.logger.warn("key \"".concat(usedKey, "\" for languages \"").concat(codes.join(', '), "\" won't get resolved as namespace \"").concat(usedNS, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
          }

          codes.forEach(function (code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKeys = [key];

            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count, options);
              var zeroSuffix = "".concat(_this4.options.pluralSeparator, "zero");

              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);

                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }

              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options.context);
                finalKeys.push(contextKey);

                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);

                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }

            var possibleKey;

            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey: usedKey,
        exactUsedKey: exactUsedKey,
        usedLng: usedLng,
        usedNS: usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
      return this.resourceStore.getResource(code, ns, key, options);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options) {
      var prefix = 'defaultValue';

      for (var option in options) {
        if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {
          return true;
        }
      }

      return false;
    }
  }]);

  return Translator;
}(EventEmitter);

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

var LanguageUtil = function () {
  function LanguageUtil(options) {
    _classCallCheck(this, LanguageUtil);

    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create('languageUtils');
  }

  _createClass(LanguageUtil, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return null;
      var p = code.split('-');
      if (p.length === 2) return null;
      p.pop();
      if (p[p.length - 1].toLowerCase() === 'x') return null;
      return this.formatLanguageCode(p.join('-'));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf('-') < 0) return code;
      var p = code.split('-');
      return this.formatLanguageCode(p[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === 'string' && code.indexOf('-') > -1) {
        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
        var p = code.split('-');

        if (this.options.lowerCaseLng) {
          p = p.map(function (part) {
            return part.toLowerCase();
          });
        } else if (p.length === 2) {
          p[0] = p[0].toLowerCase();
          p[1] = p[1].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
        } else if (p.length === 3) {
          p[0] = p[0].toLowerCase();
          if (p[1].length === 2) p[1] = p[1].toUpperCase();
          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
        }

        return p.join('-');
      }

      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === 'languageOnly' || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }

      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;

      if (!codes) return null;
      var found;
      codes.forEach(function (code) {
        if (found) return;

        var cleanedLng = _this.formatLanguageCode(code);

        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });

      if (!found && this.options.supportedLngs) {
        codes.forEach(function (code) {
          if (found) return;

          var lngOnly = _this.getLanguagePartFromCode(code);

          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function (supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }

      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === 'function') fallbacks = fallbacks(code);
      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
      if (!code) return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;

      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];

      var addCode = function addCode(c) {
        if (!c) return;

        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };

      if (typeof code === 'string' && code.indexOf('-') > -1) {
        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === 'string') {
        addCode(this.formatLanguageCode(code));
      }

      fallbackCodes.forEach(function (fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);

  return LanguageUtil;
}();

var sets = [{
  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'tl', 'ti', 'tr', 'uz', 'wa'],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kk', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ['ay', 'bo', 'cgg', 'fa', 'ht', 'id', 'ja', 'jbo', 'ka', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
  nr: [1],
  fc: 3
}, {
  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ['ar'],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ['cs', 'sk'],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ['csb', 'pl'],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ['cy'],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ['fr'],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ['ga'],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ['gd'],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ['is'],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ['jv'],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ['kw'],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ['lt'],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ['lv'],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ['mk'],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ['mnk'],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ['mt'],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ['or'],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ['ro'],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ['sl'],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ['he', 'iw'],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n) {
    return Number(n > 1);
  },
  2: function _(n) {
    return Number(n != 1);
  },
  3: function _(n) {
    return 0;
  },
  4: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function _(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function _(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function _(n) {
    return Number(n >= 2);
  },
  10: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function _(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function _(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function _(n) {
    return Number(n !== 0);
  },
  14: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function _(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function _(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function _(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function _(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function _(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function _(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ['v1', 'v2', 'v3'];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};

function createRules() {
  var rules = {};
  sets.forEach(function (set) {
    set.lngs.forEach(function (l) {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}

var PluralResolver = function () {
  function PluralResolver(languageUtils) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, PluralResolver);

    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create('pluralResolver');

    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === 'v4') && (typeof Intl === 'undefined' || !Intl.PluralRules)) {
      this.options.compatibilityJSON = 'v3';
      this.logger.error('Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.');
    }

    this.rules = createRules();
  }

  _createClass(PluralResolver, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options.ordinal ? 'ordinal' : 'cardinal'
          });
        } catch (_unused) {
          return;
        }
      }

      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rule = this.getRule(code, options);

      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }

      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.getSuffixes(code, options).map(function (suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rule = this.getRule(code, options);

      if (!rule) {
        return [];
      }

      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function (pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function (pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }

      return rule.numbers.map(function (number) {
        return _this.getSuffix(code, number, options);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var rule = this.getRule(code, options);

      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }

        return this.getSuffixRetroCompatible(rule, count);
      }

      this.logger.warn("no plural rule found for: ".concat(code));
      return '';
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;

      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];

      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = 'plural';
        } else if (suffix === 1) {
          suffix = '';
        }
      }

      var returnSuffix = function returnSuffix() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };

      if (this.options.compatibilityJSON === 'v1') {
        if (suffix === 1) return '';
        if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === 'v2') {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }

      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);

  return PluralResolver;
}();

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var Interpolator = function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Interpolator);

    this.logger = baseLogger.create('interpolator');
    this.options = options;

    this.format = options.interpolation && options.interpolation.format || function (value) {
      return value;
    };

    this.init(options);
  }

  _createClass(Interpolator, [{
    key: "init",
    value: function init() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options.interpolation) options.interpolation = {
        escapeValue: true
      };
      var iOpts = options.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : i18next_escape;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ',';
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, 'g');
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options) {
      var _this = this;

      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};

      function regexSafe(val) {
        return val.replace(/\$/g, '$$$$');
      }

      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, undefined, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
            interpolationkey: key
          })) : path;
        }

        var p = key.split(_this.formatSeparator);
        var k = p.shift().trim();
        var f = p.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options), data), {}, {
          interpolationkey: k
        }));
      };

      this.resetRegExp();
      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function (todo) {
        replaces = 0;

        while (match = todo.regex.exec(str)) {
          var matchedVar = match[1].trim();
          value = handleFormat(matchedVar);

          if (value === undefined) {
            if (typeof missingInterpolationHandler === 'function') {
              var temp = missingInterpolationHandler(str, match, options);
              value = typeof temp === 'string' ? temp : '';
            } else if (options && options.hasOwnProperty(matchedVar)) {
              value = '';
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));

              value = '';
            }
          } else if (typeof value !== 'string' && !_this.useRawValueToEscape) {
            value = makeString(value);
          }

          var safeValue = todo.safeValue(value);
          str = str.replace(match[0], safeValue);

          if (skipOnVariables) {
            todo.regex.lastIndex += value.length;
            todo.regex.lastIndex -= match[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }

          replaces++;

          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;

      var clonedOptions = _objectSpread$3({}, options);

      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;

      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');

        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e);
          return "".concat(key).concat(sep).concat(optionsString);
        }

        delete clonedOptions.defaultValue;
        return key;
      }

      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;

        if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function (elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }

        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== 'string') return value;
        if (typeof value !== 'string') value = makeString(value);

        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = '';
        }

        if (doReduce) {
          value = formatters.reduce(function (v, f) {
            return _this2.format(v, f, options.lng, _objectSpread$3(_objectSpread$3({}, options), {}, {
              interpolationkey: match[1].trim()
            }));
          }, value.trim());
        }

        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }

      return str;
    }
  }]);

  return Interpolator;
}();

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};

  if (formatStr.indexOf('(') > -1) {
    var p = formatStr.split('(');
    formatName = p[0].toLowerCase().trim();
    var optStr = p[1].substring(0, p[1].length - 1);

    if (formatName === 'currency' && optStr.indexOf(':') < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === 'relativetime' && optStr.indexOf(':') < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(';');
      opts.forEach(function (opt) {
        if (!opt) return;

        var _opt$split = opt.split(':'),
            _opt$split2 = _toArray(_opt$split),
            key = _opt$split2[0],
            rest = _opt$split2.slice(1);

        var val = rest.join(':').trim().replace(/^'+|'+$/g, '');
        if (!formatOptions[key.trim()]) formatOptions[key.trim()] = val;
        if (val === 'false') formatOptions[key.trim()] = false;
        if (val === 'true') formatOptions[key.trim()] = true;
        if (!isNaN(val)) formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }

  return {
    formatName: formatName,
    formatOptions: formatOptions
  };
}

var Formatter = function () {
  function Formatter() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Formatter);

    this.logger = baseLogger.create('formatter');
    this.options = options;
    this.formats = {
      number: function number(val, lng, options) {
        return new Intl.NumberFormat(lng, options).format(val);
      },
      currency: function currency(val, lng, options) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options), {}, {
          style: 'currency'
        })).format(val);
      },
      datetime: function datetime(val, lng, options) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options)).format(val);
      },
      relativetime: function relativetime(val, lng, options) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options)).format(val, options.range || 'day');
      },
      list: function list(val, lng, options) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options)).format(val);
      }
    };
    this.init(options);
  }

  _createClass(Formatter, [{
    key: "init",
    value: function init(services) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
    }
  }, {
    key: "add",
    value: function add(name, fc) {
      this.formats[name.toLowerCase().trim()] = fc;
    }
  }, {
    key: "format",
    value: function format(value, _format, lng, options) {
      var _this = this;

      var formats = _format.split(this.formatSeparator);

      var result = formats.reduce(function (mem, f) {
        var _parseFormatStr = parseFormatStr(f),
            formatName = _parseFormatStr.formatName,
            formatOptions = _parseFormatStr.formatOptions;

        if (_this.formats[formatName]) {
          var formatted = mem;

          try {
            var valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
            var l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
            formatted = _this.formats[formatName](mem, l, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options), valOptions));
          } catch (error) {
            _this.logger.warn(error);
          }

          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }

        return mem;
      }, value);
      return result;
    }
  }]);

  return Formatter;
}();

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function removePending(q, name) {
  if (q.pending[name] !== undefined) {
    delete q.pending[name];
    q.pendingCount--;
  }
}

var Connector = function (_EventEmitter) {
  _inherits(Connector, _EventEmitter);

  var _super = _createSuper$2(Connector);

  function Connector(backend, store, services) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Connector);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options;
    _this.logger = baseLogger.create('backendConnector');
    _this.waitingReads = [];
    _this.maxParallelReads = options.maxParallelReads || 10;
    _this.readingCalls = 0;
    _this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    _this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    _this.state = {};
    _this.queue = [];

    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options.backend, options);
    }

    return _this;
  }

  _createClass(Connector, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options, callback) {
      var _this2 = this;

      var toLoad = {};
      var pending = {};
      var toLoadLanguages = {};
      var toLoadNamespaces = {};
      languages.forEach(function (lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function (ns) {
          var name = "".concat(lng, "|").concat(ns);

          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
            if (pending[name] === undefined) pending[name] = true;
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending[name] === undefined) pending[name] = true;
            if (toLoad[name] === undefined) toLoad[name] = true;
            if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;
          }
        });
        if (!hasAllNamespaces) toLoadLanguages[lng] = true;
      });

      if (Object.keys(toLoad).length || Object.keys(pending).length) {
        this.queue.push({
          pending: pending,
          pendingCount: Object.keys(pending).length,
          loaded: {},
          errors: [],
          callback: callback
        });
      }

      return {
        toLoad: Object.keys(toLoad),
        pending: Object.keys(pending),
        toLoadLanguages: Object.keys(toLoadLanguages),
        toLoadNamespaces: Object.keys(toLoadNamespaces)
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      if (err) this.emit('failedLoading', lng, ns, err);

      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }

      this.state[name] = err ? -1 : 2;
      var loaded = {};
      this.queue.forEach(function (q) {
        pushPath(q.loaded, [lng], ns);
        removePending(q, name);
        if (err) q.errors.push(err);

        if (q.pendingCount === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function (l) {
            if (!loaded[l]) loaded[l] = {};
            var loadedKeys = q.loaded[l];

            if (loadedKeys.length) {
              loadedKeys.forEach(function (ns) {
                if (loaded[l][ns] === undefined) loaded[l][ns] = true;
              });
            }
          });
          q.done = true;

          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit('loaded', loaded);
      this.queue = this.queue.filter(function (q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;

      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length) return callback(null, {});

      if (this.readingCalls >= this.maxParallelReads) {
        this.waitingReads.push({
          lng: lng,
          ns: ns,
          fcName: fcName,
          tried: tried,
          wait: wait,
          callback: callback
        });
        return;
      }

      this.readingCalls++;
      return this.backend[fcName](lng, ns, function (err, data) {
        _this3.readingCalls--;

        if (_this3.waitingReads.length > 0) {
          var next = _this3.waitingReads.shift();

          _this3.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
        }

        if (err && data && tried < _this3.maxRetries) {
          setTimeout(function () {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }

        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;

      if (!this.backend) {
        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
        return callback && callback();
      }

      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === 'string') namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options, callback);

      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }

      toLoad.toLoad.forEach(function (name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;

      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var s = name.split('|');
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, 'read', undefined, undefined, function (err, data) {
        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn("did not save key \"".concat(key, "\" as the namespace \"").concat(namespace, "\" was not yet loaded"), 'This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!');
        return;
      }

      if (key === undefined || key === null || key === '') return;

      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options), {}, {
          isUpdate: isUpdate
        }));
      }

      if (!languages || !languages[0]) return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);

  return Connector;
}(EventEmitter);

function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: 'all',
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: 'fallback',
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (_typeof(args[1]) === 'object') ret = args[1];
      if (typeof args[1] === 'string') ret.defaultValue = args[1];
      if (typeof args[2] === 'string') ret.tDescription = args[2];

      if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
        var options = args[3] || args[2];
        Object.keys(options).forEach(function (key) {
          ret[key] = options[key];
        });
      }

      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options) {
        return value;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      nestingOptionsSeparator: ',',
      maxReplaces: 1000,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === 'string') options.ns = [options.ns];
  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS];

  if (options.supportedLngs && options.supportedLngs.indexOf('cimode') < 0) {
    options.supportedLngs = options.supportedLngs.concat(['cimode']);
  }

  return options;
}

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function noop() {}

function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function (mem) {
    if (typeof inst[mem] === 'function') {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}

var I18n = function (_EventEmitter) {
  _inherits(I18n, _EventEmitter);

  var _super = _createSuper$3(I18n);

  function I18n() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;

    _classCallCheck(this, I18n);

    _this = _super.call(this);

    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }

    _this.options = transformOptions(options);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));

    if (callback && !_this.isInitialized && !options.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options, callback);

        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }

      setTimeout(function () {
        _this.init(options, callback);
      }, 0);
    }

    return _this;
  }

  _createClass(I18n, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!options.defaultNS && options.defaultNS !== false && options.ns) {
        if (typeof options.ns === 'string') {
          options.defaultNS = options.ns;
        } else if (options.ns.indexOf('translation') < 0) {
          options.defaultNS = options.ns[0];
        }
      }

      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options));

      if (this.options.compatibilityAPI !== 'v1') {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }

      if (options.keySeparator !== undefined) {
        this.options.userDefinedKeySeparator = options.keySeparator;
      }

      if (options.nsSeparator !== undefined) {
        this.options.userDefinedNsSeparator = options.nsSeparator;
      }

      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === 'function') return new ClassOrObject();
        return ClassOrObject;
      }

      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }

        var formatter;

        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== 'undefined') {
          formatter = Formatter;
        }

        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });

        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }

        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on('*', function (event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });

        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }

        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }

        this.translator = new Translator(this.services, this.options);
        this.translator.on('*', function (event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function (m) {
          if (m.init) m.init(_this2);
        });
      }

      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;

      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== 'dev') this.options.lng = codes[0];
      }

      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn('init: no languageDetector is used and no lng is defined');
      }

      var storeApi = ['getResource', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
      storeApi.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store;

          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ['addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle'];
      storeApiChained.forEach(function (fcName) {
        _this2[fcName] = function () {
          var _this2$store2;

          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);

          return _this2;
        };
      });
      var deferred = defer();

      var load = function load() {
        var finish = function finish(err, t) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce) _this2.logger.warn('init: i18next is already initialized. You should call init just once!');
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log('initialized', _this2.options);

          _this2.emit('initialized', _this2.options);

          deferred.resolve(t);
          callback(err, t);
        };

        if (_this2.languages && _this2.options.compatibilityAPI !== 'v1' && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));

        _this2.changeLanguage(_this2.options.lng, finish);
      };

      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }

      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === 'string' ? language : this.language;
      if (typeof language === 'function') usedCallback = language;

      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === 'cimode') return usedCallback();
        var toLoad = [];

        var append = function append(lng) {
          if (!lng) return;

          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

          lngs.forEach(function (l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };

        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function (l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }

        if (this.options.preload) {
          this.options.preload.forEach(function (l) {
            return append(l);
          });
        }

        this.services.backendConnector.load(toLoad, this.options.ns, function (e) {
          if (!e && !_this3.resolvedLanguage && _this3.language) _this3.setResolvedLanguage(_this3.language);
          usedCallback(e);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function (err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error('You are passing an undefined module! Please check the object you are passing to i18next.use()');
      if (!module.type) throw new Error('You are passing a wrong module! Please check the object you are passing to i18next.use()');

      if (module.type === 'backend') {
        this.modules.backend = module;
      }

      if (module.type === 'logger' || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }

      if (module.type === 'languageDetector') {
        this.modules.languageDetector = module;
      }

      if (module.type === 'i18nFormat') {
        this.modules.i18nFormat = module;
      }

      if (module.type === 'postProcessor') {
        postProcessor.addPostProcessor(module);
      }

      if (module.type === 'formatter') {
        this.modules.formatter = module;
      }

      if (module.type === '3rdParty') {
        this.modules.external.push(module);
      }

      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l) {
      if (!l || !this.languages) return;
      if (['cimode', 'dev'].indexOf(l) > -1) return;

      for (var li = 0; li < this.languages.length; li++) {
        var lngInLngs = this.languages[li];
        if (['cimode', 'dev'].indexOf(lngInLngs) > -1) continue;

        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;

      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit('languageChanging', lng);

      var setLngProps = function setLngProps(l) {
        _this4.language = l;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
        _this4.resolvedLanguage = undefined;

        _this4.setResolvedLanguage(l);
      };

      var done = function done(err, l) {
        if (l) {
          setLngProps(l);

          _this4.translator.changeLanguage(l);

          _this4.isLanguageChangingTo = undefined;

          _this4.emit('languageChanged', l);

          _this4.logger.log('languageChanged', l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }

        deferred.resolve(function () {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err, function () {
          return _this4.t.apply(_this4, arguments);
        });
      };

      var setLng = function setLng(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector) lngs = [];
        var l = typeof lngs === 'string' ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);

        if (l) {
          if (!_this4.language) {
            setLngProps(l);
          }

          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }

        _this4.loadResources(l, function (err) {
          done(err, l);
        });
      };

      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }

      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns, keyPrefix) {
      var _this5 = this;

      var fixedT = function fixedT(key, opts) {
        var options;

        if (_typeof(opts) !== 'object') {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }

          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options = _objectSpread$6({}, opts);
        }

        options.lng = options.lng || fixedT.lng;
        options.lngs = options.lngs || fixedT.lngs;
        options.ns = options.ns || fixedT.ns;
        options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
        var keySeparator = _this5.options.keySeparator || '.';
        var resultKey = options.keyPrefix ? "".concat(options.keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options);
      };

      if (typeof lng === 'string') {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }

      fixedT.ns = ns;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;

      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;

      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isInitialized) {
        this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages);
        return false;
      }

      if (!this.languages || !this.languages.length) {
        this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages);
        return false;
      }

      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === 'cimode') return true;

      var loadNotPending = function loadNotPending(l, n) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n)];

        return loadState === -1 || loadState === 2;
      };

      if (options.precheck) {
        var preResult = options.precheck(this, loadNotPending);
        if (preResult !== undefined) return preResult;
      }

      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;

      var deferred = defer();

      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }

      if (typeof ns === 'string') ns = [ns];
      ns.forEach(function (n) {
        if (_this7.options.ns.indexOf(n) < 0) _this7.options.ns.push(n);
      });
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === 'string') lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function (lng) {
        return preloaded.indexOf(lng) < 0;
      });

      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }

      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function (err) {
        deferred.resolve();
        if (callback) callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng) return 'rtl';
      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ug', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam', 'ckb'];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf('-arab') > 1 ? 'rtl' : 'ltr';
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options), {
        isClone: true
      });

      var clone = new I18n(mergedOptions);
      var membersToCopy = ['store', 'services', 'language'];
      membersToCopy.forEach(function (m) {
        clone[m] = _this8[m];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on('*', function (event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }

        clone.emit.apply(clone, [event].concat(args));
      });
      clone.init(mergedOptions, callback);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);

  return I18n;
}(EventEmitter);

_defineProperty(I18n, "createInstance", function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var callback = arguments.length > 1 ? arguments[1] : undefined;
  return new I18n(options, callback);
});

var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;

var createInstance = instance.createInstance;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

/* harmony default export */ const i18next = (instance);


;// CONCATENATED MODULE: ./node_modules/i18next-http-backend/esm/utils.js
function utils_typeof(obj) { "@babel/helpers - typeof"; return utils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, utils_typeof(obj); }

var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function (source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
function hasXMLHttpRequest() {
  return typeof XMLHttpRequest === 'function' || (typeof XMLHttpRequest === "undefined" ? "undefined" : utils_typeof(XMLHttpRequest)) === 'object';
}

function isPromise(maybePromise) {
  return !!maybePromise && typeof maybePromise.then === 'function';
}

function makePromise(maybePromise) {
  if (isPromise(maybePromise)) {
    return maybePromise;
  }

  return Promise.resolve(maybePromise);
}
// EXTERNAL MODULE: ./node_modules/i18next-http-backend/esm/getFetch.cjs
var getFetch = __webpack_require__(154);
var getFetch_namespaceObject = /*#__PURE__*/__webpack_require__.t(getFetch, 2);
;// CONCATENATED MODULE: ./node_modules/i18next-http-backend/esm/request.js
function request_typeof(obj) { "@babel/helpers - typeof"; return request_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, request_typeof(obj); }



var fetchApi;

if (typeof fetch === 'function') {
  if (typeof global !== 'undefined' && global.fetch) {
    fetchApi = global.fetch;
  } else if (typeof window !== 'undefined' && window.fetch) {
    fetchApi = window.fetch;
  }
}

var XmlHttpRequestApi;

if (hasXMLHttpRequest()) {
  if (typeof global !== 'undefined' && global.XMLHttpRequest) {
    XmlHttpRequestApi = global.XMLHttpRequest;
  } else if (typeof window !== 'undefined' && window.XMLHttpRequest) {
    XmlHttpRequestApi = window.XMLHttpRequest;
  }
}

var ActiveXObjectApi;

if (typeof ActiveXObject === 'function') {
  if (typeof global !== 'undefined' && global.ActiveXObject) {
    ActiveXObjectApi = global.ActiveXObject;
  } else if (typeof window !== 'undefined' && window.ActiveXObject) {
    ActiveXObjectApi = window.ActiveXObject;
  }
}

if (!fetchApi && getFetch_namespaceObject && !XmlHttpRequestApi && !ActiveXObjectApi) fetchApi = getFetch || getFetch_namespaceObject;
if (typeof fetchApi !== 'function') fetchApi = undefined;

var addQueryString = function addQueryString(url, params) {
  if (params && request_typeof(params) === 'object') {
    var queryString = '';

    for (var paramName in params) {
      queryString += '&' + encodeURIComponent(paramName) + '=' + encodeURIComponent(params[paramName]);
    }

    if (!queryString) return url;
    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
  }

  return url;
};

var requestWithFetch = function requestWithFetch(options, url, payload, callback) {
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  var headers = defaults({}, typeof options.customHeaders === 'function' ? options.customHeaders() : options.customHeaders);
  if (payload) headers['Content-Type'] = 'application/json';
  fetchApi(url, defaults({
    method: payload ? 'POST' : 'GET',
    body: payload ? options.stringify(payload) : undefined,
    headers: headers
  }, typeof options.requestOptions === 'function' ? options.requestOptions(payload) : options.requestOptions)).then(function (response) {
    if (!response.ok) return callback(response.statusText || 'Error', {
      status: response.status
    });
    response.text().then(function (data) {
      callback(null, {
        status: response.status,
        data: data
      });
    }).catch(callback);
  }).catch(callback);
};

var requestWithXmlHttpRequest = function requestWithXmlHttpRequest(options, url, payload, callback) {
  if (payload && request_typeof(payload) === 'object') {
    payload = addQueryString('', payload).slice(1);
  }

  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }

  try {
    var x;

    if (XmlHttpRequestApi) {
      x = new XmlHttpRequestApi();
    } else {
      x = new ActiveXObjectApi('MSXML2.XMLHTTP.3.0');
    }

    x.open(payload ? 'POST' : 'GET', url, 1);

    if (!options.crossDomain) {
      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }

    x.withCredentials = !!options.withCredentials;

    if (payload) {
      x.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    if (x.overrideMimeType) {
      x.overrideMimeType('application/json');
    }

    var h = options.customHeaders;
    h = typeof h === 'function' ? h() : h;

    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }

    x.onreadystatechange = function () {
      x.readyState > 3 && callback(x.status >= 400 ? x.statusText : null, {
        status: x.status,
        data: x.responseText
      });
    };

    x.send(payload);
  } catch (e) {
    console && console.log(e);
  }
};

var request = function request(options, url, payload, callback) {
  if (typeof payload === 'function') {
    callback = payload;
    payload = undefined;
  }

  callback = callback || function () {};

  if (fetchApi) {
    return requestWithFetch(options, url, payload, callback);
  }

  if (hasXMLHttpRequest() || typeof ActiveXObject === 'function') {
    return requestWithXmlHttpRequest(options, url, payload, callback);
  }
};

/* harmony default export */ const esm_request = (request);
;// CONCATENATED MODULE: ./node_modules/i18next-http-backend/esm/index.js
function esm_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function esm_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function esm_createClass(Constructor, protoProps, staticProps) { if (protoProps) esm_defineProperties(Constructor.prototype, protoProps); if (staticProps) esm_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function esm_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var getDefaults = function getDefaults() {
  return {
    loadPath: '/locales/{{lng}}/{{ns}}.json',
    addPath: '/locales/add/{{lng}}/{{ns}}',
    allowMultiLoading: false,
    parse: function parse(data) {
      return JSON.parse(data);
    },
    stringify: JSON.stringify,
    parsePayload: function parsePayload(namespace, key, fallbackValue) {
      return esm_defineProperty({}, key, fallbackValue || '');
    },
    request: esm_request,
    reloadInterval: typeof window !== 'undefined' ? false : 60 * 60 * 1000,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: false,
    withCredentials: false,
    overrideMimeType: false,
    requestOptions: {
      mode: 'cors',
      credentials: 'same-origin',
      cache: 'default'
    }
  };
};

var Backend = function () {
  function Backend(services) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    esm_classCallCheck(this, Backend);

    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = 'backend';
    this.init(services, options, allOptions);
  }

  esm_createClass(Backend, [{
    key: "init",
    value: function init(services) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var allOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options, this.options || {}, getDefaults());
      this.allOptions = allOptions;

      if (this.services && this.options.reloadInterval) {
        setInterval(function () {
          return _this.reload();
        }, this.options.reloadInterval);
      }
    }
  }, {
    key: "readMulti",
    value: function readMulti(languages, namespaces, callback) {
      this._readAny(languages, languages, namespaces, namespaces, callback);
    }
  }, {
    key: "read",
    value: function read(language, namespace, callback) {
      this._readAny([language], language, [namespace], namespace, callback);
    }
  }, {
    key: "_readAny",
    value: function _readAny(languages, loadUrlLanguages, namespaces, loadUrlNamespaces, callback) {
      var _this2 = this;

      var loadPath = this.options.loadPath;

      if (typeof this.options.loadPath === 'function') {
        loadPath = this.options.loadPath(languages, namespaces);
      }

      loadPath = makePromise(loadPath);
      loadPath.then(function (resolvedLoadPath) {
        if (!resolvedLoadPath) return callback(null, {});

        var url = _this2.services.interpolator.interpolate(resolvedLoadPath, {
          lng: languages.join('+'),
          ns: namespaces.join('+')
        });

        _this2.loadUrl(url, callback, loadUrlLanguages, loadUrlNamespaces);
      });
    }
  }, {
    key: "loadUrl",
    value: function loadUrl(url, callback, languages, namespaces) {
      var _this3 = this;

      this.options.request(this.options, url, undefined, function (err, res) {
        if (res && (res.status >= 500 && res.status < 600 || !res.status)) return callback('failed loading ' + url + '; status code: ' + res.status, true);
        if (res && res.status >= 400 && res.status < 500) return callback('failed loading ' + url + '; status code: ' + res.status, false);
        if (!res && err && err.message && err.message.indexOf('Failed to fetch') > -1) return callback('failed loading ' + url + ': ' + err.message, true);
        if (err) return callback(err, false);
        var ret, parseErr;

        try {
          if (typeof res.data === 'string') {
            ret = _this3.options.parse(res.data, languages, namespaces);
          } else {
            ret = res.data;
          }
        } catch (e) {
          parseErr = 'failed parsing ' + url + ' to json';
        }

        if (parseErr) return callback(parseErr, false);
        callback(null, ret);
      });
    }
  }, {
    key: "create",
    value: function create(languages, namespace, key, fallbackValue, callback) {
      var _this4 = this;

      if (!this.options.addPath) return;
      if (typeof languages === 'string') languages = [languages];
      var payload = this.options.parsePayload(namespace, key, fallbackValue);
      var finished = 0;
      var dataArray = [];
      var resArray = [];
      languages.forEach(function (lng) {
        var addPath = _this4.options.addPath;

        if (typeof _this4.options.addPath === 'function') {
          addPath = _this4.options.addPath(lng, namespace);
        }

        var url = _this4.services.interpolator.interpolate(addPath, {
          lng: lng,
          ns: namespace
        });

        _this4.options.request(_this4.options, url, payload, function (data, res) {
          finished += 1;
          dataArray.push(data);
          resArray.push(res);

          if (finished === languages.length) {
            if (callback) callback(dataArray, resArray);
          }
        });
      });
    }
  }, {
    key: "reload",
    value: function reload() {
      var _this5 = this;

      var _this$services = this.services,
          backendConnector = _this$services.backendConnector,
          languageUtils = _this$services.languageUtils,
          logger = _this$services.logger;
      var currentLanguage = backendConnector.language;
      if (currentLanguage && currentLanguage.toLowerCase() === 'cimode') return;
      var toLoad = [];

      var append = function append(lng) {
        var lngs = languageUtils.toResolveHierarchy(lng);
        lngs.forEach(function (l) {
          if (toLoad.indexOf(l) < 0) toLoad.push(l);
        });
      };

      append(currentLanguage);
      if (this.allOptions.preload) this.allOptions.preload.forEach(function (l) {
        return append(l);
      });
      toLoad.forEach(function (lng) {
        _this5.allOptions.ns.forEach(function (ns) {
          backendConnector.read(lng, ns, 'read', null, null, function (err, data) {
            if (err) logger.warn("loading namespace ".concat(ns, " for language ").concat(lng, " failed"), err);
            if (!err && data) logger.log("loaded namespace ".concat(ns, " for language ").concat(lng), data);
            backendConnector.loaded("".concat(lng, "|").concat(ns), err, data);
          });
        });
      });
    }
  }]);

  return Backend;
}();

Backend.type = 'backend';
/* harmony default export */ const esm = (Backend);
// EXTERNAL MODULE: ./node_modules/loc-i18next/index.js
var loc_i18next = __webpack_require__(837);
var loc_i18next_default = /*#__PURE__*/__webpack_require__.n(loc_i18next);
;// CONCATENATED MODULE: ./src/i18n/translator.ts
var translator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


// @ts-ignore






var localize;
// let initialized: boolean = false;
var TranslatorGlobal = /** @class */ (function (_super) {
    translator_extends(TranslatorGlobal, _super);
    function TranslatorGlobal() {
        var _this = _super.call(this, 'Sys.Trnslt') || this;
        _this.locReady = false;
        _this.initialized = false;
        insights_Insights.add('system', 'translator', _this.log);
        _this.i18n = i18next;
        return _this;
    }
    TranslatorGlobal.prototype.translate = function (key) {
        if (!this.initialized)
            return key;
        if (!this.i18n.isInitialized)
            return key;
        return this.i18n.t(key) || key;
    };
    /**
     * Initialize a manager-object on a 2sxc-instance
     */
    TranslatorGlobal.prototype.initManager = function (manage) {
        var _this = this;
        var cl = this.log.call('initManager');
        if (this.initialized)
            return cl.done('already initialized');
        var context = manage.context || this.tryToFindAContext();
        cl.add('will initialize');
        var realRootPath = window.$2sxc.env.uiRoot();
        this.i18n
            .use(esm)
            .init({
            lng: context.app.currentLanguage.substr(0, 2),
            fallbackLng: primaryLanguage,
            // whitelist: translations,
            preload: [primaryLanguage],
            backend: {
                loadPath: urlClean(realRootPath + translationsPath),
            },
        }, function () { return _this.initLoc(); });
        this.initialized = true;
        cl.done();
    };
    TranslatorGlobal.prototype.tryToFindAContext = function () {
        var cl = this.log.call('tryToFindAContext');
        cl.add('no context found, will seek');
        // trying to get context...
        var htmlElementOrId = document.querySelector('div[data-cb-id]');
        this.initialized = true; // the next SxcEdit.get will call _translate so we must set true to prevent loops
        var sxc = window.$2sxc(htmlElementOrId);
        this.initialized = false; // for real, it is not initialized...
        var editContext = SxcTools.getEditContext(sxc);
        var context = new ContextComplete(editContext, sxc);
        context.sxc = sxc;
        return cl.return(context);
    };
    /**
     * Initialize loc and auto-translate menu nodes in the DOM
     * This is called when the initialize-promise resolves
     */
    TranslatorGlobal.prototype.initLoc = function () {
        var cl = this.log.call('initLoc');
        // for options see https://github.com/mthh/loc-i18next#initialize-the-plugin
        localize = loc_i18next_default().init(i18next);
        this.locReady = true;
        this.autoTranslateMenus();
        cl.done();
    };
    /**
     * Tell loc to translate all the translatable menu nodes
     * Do this on initial load, and every time dynamic content gets re-created
     */
    TranslatorGlobal.prototype.autoTranslateMenus = function () {
        var cl = this.log.call('autoTranslateMenus');
        if (!this.locReady)
            return cl.done('loc not ready');
        // start localizing, details: https://github.com/mthh/loc-i18next#usage-of-selector-function
        var menus = document.querySelectorAll(IDs.sel.tagScMenu);
        localize(IDs.sel.tagScMenu); // inline toolbars
        var quickEButtons = document.querySelectorAll('.sc-i18n');
        localize('.sc-i18n'); // quick-insert menus
        cl.add("found ".concat(menus.length, " menus and ").concat(quickEButtons.length, " buttons"));
        cl.done();
    };
    return TranslatorGlobal;
}(HasLog));
/**
 * @internal
 */
var translator_Translator = new TranslatorGlobal();

;// CONCATENATED MODULE: ./src/i18n/2sxc.translate.ts

/**
 * provide an official translate API for 2sxc
 * @param key
 * @internal
 */
function translate(key) { return translator_Translator.translate(key); }

;// CONCATENATED MODULE: ./src/i18n/index.ts
/**
 * @internal
 */
var primaryLanguage = 'en';
/**
 * @internal
 */
var translations = (/* unused pure expression or super */ null && (['en', 'de', 'fr', 'it', 'uk', 'nl']));
/**
 * @internal
 */
var translationsPath = 'dist/inpage/i18n/{{lng}}.js';



;// CONCATENATED MODULE: ./src/entity-manipulation/item-commands.ts

/**
 * this enhances the $2sxc client controller with stuff only needed when logged in
 * @internal
 */
// #region contentItem Commands
var contentItems = {
    // delete command - try to really delete a content-item
    delete: function (context, itemId, itemGuid, itemTitle) {
        // first show main warning / get ok
        var ok = confirm(translate('Delete.Confirm')
            .replace('{id}', String(itemId))
            .replace('{title}', itemTitle));
        if (!ok)
            return Promise.resolve();
        /**
         * ZoneId and AppId are sent becase of rare, special case that is not default
         * (default is that 2sxc is finding ZoneId and AppId on server side from ModuleId)
         * when we need to delete entity from other app or zone, than current one.
         * TODO: send this params, only when is necesary (value change detection for ZoneId, AppId)
         */
        var params = {
            zoneId: context.app.zoneId,
            appId: context.app.id,
        };
        return context.sxc.webApi.fetchRaw(context.sxc.webApi.url("app/auto/content/any/".concat(itemGuid), params), undefined, 'DELETE')
            .then(function (response) {
            if (response.status >= 200 && response.status < 300) {
                location.reload();
            }
            else if (response.status >= 400 && response.status < 500) {
                // check if it's a permission config problem
                var msgJs = translate('Delete.ErrCheckConsole');
                if (response.status === 401)
                    alert(translate('Delete.ErrPermission') + msgJs);
                if (response.status === 400)
                    alert(translate('Delete.ErrInUse') + msgJs);
            }
        }).catch(function (error) {
            console.log(error);
        });
    },
};

;// CONCATENATED MODULE: ./src/commands/command/command-delete.ts


/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("delete" /* CommandNames.delete */, 'Delete', 'cancel', true, false, {
    // disabled: true,
    showCondition: function (context) {
        var p = context.button.command.params;
        // can never be used for a modulelist item, as it is always in use somewhere
        if (p.useModuleList)
            return false;
        // check if all data exists required for deleting
        // before 10.27, it was entityId, entityGuid and entityTitle
        // since 10.27, there will always be a guid (if it has an ID)
        // and enabling it requires an action-modifier "+delete",
        // so the automatic detection only applies
        // to the pre-10.27 custom toolbars case
        return (!!p.entityId && !!p.entityGuid && !!p.entityTitle);
    },
    code: function (context) {
        var p = context.button.command.params;
        var title = p.title || p.entityTitle; // prefer new title, and fallback to old for pre 10.27 configs
        return contentItems["delete"](context, p.entityId, p.entityGuid, title);
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-edit.ts

/**
 * open an edit-item dialog
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("edit" /* CommandNames.edit */, 'Edit', 'pencil', false, true, {
    addParamsToLink: function (ctx) { return ({ mode: "edit" /* CommandNames.edit */ }); },
    showCondition: function (ctx) {
        // need ID or a "slot", otherwise edit won't work
        var result = !!ctx.button.command.params.entityId ||
            !!ctx.button.command.params.useModuleList;
        return result;
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-insights.ts

/**
 * import this module to commands.ts
 * @internal
 */
var command_insights_cmd = Command.build("insights" /* CommandNames.insights */, 'Insights', 'speed', true, false, {
    dialog: function (_) { return "insights-server" /* CommandNames.insights_old_server */; },
    showCondition: function (context) { return context.user.CanDevelop; },
    code: function (context, event) {
        return new Promise(function (resolve, reject) {
            var path = window.$2sxc.http.apiUrl('sys/insights/logs');
            window.open(path, '_blank');
            return resolve();
        });
    },
});
Commands.addCommand(command_insights_cmd);
Commands.addCommand(Command.clone(command_insights_cmd, "insights-server" /* CommandNames.insights_old_server */));

;// CONCATENATED MODULE: ./src/commands/command/command-list.ts


/**
 * import this module to commands.ts
 * @internal
 */
var command_list_cmd = Command.build("list" /* CommandNames.list */, 'Sort', 'list-numbered', false, true, {
    dialog: function (_) { return "instance-list" /* CommandNames.list_old_instanceList */; },
    showCondition: function (context) { return SharedLogic.isList(context); },
    configureLinkGenerator: function (context, linkGenerator) {
        if (!SharedLogic.isFieldList(context))
            return;
        var params = context.button.command.params;
        linkGenerator.items = [{
                Add: false,
                Index: CmdParHlp.getIndex(params),
                Parent: params.parent,
                Field: params.fields,
            }];
    },
});
Commands.addCommand(command_list_cmd);
Commands.addCommand(Command.clone(command_list_cmd, "instance-list" /* CommandNames.list_old_instanceList */));

;// CONCATENATED MODULE: ./src/quick-edit/selection.ts
/**
 * @internal
 */
var Selection = /** @class */ (function () {
    function Selection() {
    }
    return Selection;
}());


;// CONCATENATED MODULE: ./src/quick-edit/modifier-base.ts
var modifier_base_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Base class for module / content-block editors
 * @internal
 */
var ModifierBase = /** @class */ (function (_super) {
    modifier_base_extends(ModifierBase, _super);
    function ModifierBase(name) {
        return _super.call(this, name) || this;
    }
    return ModifierBase;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-edit/quick-e-overlays.ts



/**
 * @internal
 */
var QuickEditOverlay;
(function (QuickEditOverlay) {
    function setButtonActivationClasses(buttons, linkTags) {
        var _loop_1 = function (k, v) {
            linkTags.forEach(function (l) {
                l.classList.remove("enable-".concat(k), "disable-".concat(k));
            });
        };
        // remove any previously set classes for these
        for (var _i = 0, _a = Object.entries(new QuickEditConfigButtons()); _i < _a.length; _i++) {
            var _b = _a[_i], k = _b[0], v = _b[1];
            _loop_1(k, v);
        }
        var _loop_2 = function (k, v) {
            linkTags.forEach(function (l) {
                l.classList.add("".concat((v ? 'enable' : 'disable'), "-").concat(k));
            });
        };
        // set classes from config
        for (var _c = 0, _d = Object.entries(buttons); _c < _d.length; _c++) {
            var _e = _d[_c], k = _e[0], v = _e[1];
            _loop_2(k, v);
        }
    }
    QuickEditOverlay.setButtonActivationClasses = setButtonActivationClasses;
    function btn(action, icon, i18N, invisible, unavailable, classes) {
        return "<a class='sc-content-block-menu-btn sc-cb-action icon-sxc-".concat(icon, " ").concat(invisible ? ' sc-invisible ' : '').concat(unavailable ? " ".concat(C.ClsNames.UnAvailable, " ") : '').concat(classes, "' data-action='").concat(action, "' data-i18n='[title]QuickInsertMenu.").concat(i18N, "'></a>");
    }
    QuickEditOverlay.btn = btn;
    QuickEditOverlay.selectedOverlay = NoJQ.domFromString('<div class="sc-content-block-menu sc-content-block-selected-menu sc-i18n"></div>').map(function (o) {
        o.append(NoJQ.domFromString(QuickEditOverlay.btn('delete', 'trash-empty', 'Delete'))[0], NoJQ.domFromString(QuickEditOverlay.btn('sendToPane', 'move', 'Move', null, null, 'sc-cb-mod-only'))[0], NoJQ.domFromString('<div id="paneList"></div>')[0]);
        return o;
    })[0];
})(QuickEditOverlay || (QuickEditOverlay = {}));
/** Expand the selectedOverlay with the necessary toggle function */
QuickEditOverlay.selectedOverlay.toggleOverlay = function (target, buttons) {
    if (!target) {
        QuickEditOverlay.selectedOverlay.style.display = 'none';
    }
    else {
        // 1. set overlay at the right coordinates
        var coords = Positioning.get(target);
        coords.yh = coords.y + 20;
        Positioning.positionAndAlign(QuickEditOverlay.selectedOverlay, coords);
        QuickEditOverlay.selectedOverlay.target = target;
        // 2. Activate / deactivate correct buttons
        QuickEditOverlay.setButtonActivationClasses(buttons, Array.from(QuickEditOverlay.selectedOverlay.querySelectorAll('a')));
    }
};

;// CONCATENATED MODULE: ./src/quick-edit/quick-e-configuration.ts
var quick_e_configuration_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var QuickEditConfigEnableAuto = 'auto';
/**
 * Buttons on a quick-edit toolbar
 * @public
 */
// Note: It's actually used as an interface, but we made it a class so the docs can show the default being true on all values
var QuickEditConfigButtons = /** @class */ (function () {
    function QuickEditConfigButtons() {
        /**
         * Enable the button to "Add Content"
         */
        this.addContent = true;
        /**
         * Enable the button to "add App"
         */
        this.addApp = true;
        /**
         * Enable the button "Select"
         */
        this.select = true;
        /**
         * Enable the button "Paste"
         */
        this.paste = true;
        /**
         * Enable the button "Delete"
         */
        this.delete = true;
        /**
         * Enable the button "Move"
         */
        this.move = true;
    }
    return QuickEditConfigButtons;
}());

/**
 * Quick Edit Configuration which has an `enable` and specific button configurations
 * @public
 */
var QuickEditConfig = /** @class */ (function () {
    function QuickEditConfig() {
        /**
         * Determine whether this section is enabled.
         */
        // Important: write 'auto', don't use constant, because of generated docs
        this.enable = 'auto';
    }
    return QuickEditConfig;
}());

/**
 * Quick Edit - Full configuration at root, with `enable` and rules for `modules` and `innerBlocks`
 * @public
 */
var QuickEditConfigRoot = /** @class */ (function (_super) {
    quick_e_configuration_extends(QuickEditConfigRoot, _super);
    function QuickEditConfigRoot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @internal
     */
    QuickEditConfigRoot.getDefault = function () {
        return {
            enable: true,
            buttons: new QuickEditConfigButtons(),
            innerBlocks: {
                enable: QuickEditConfigEnableAuto,
            },
            modules: {
                enable: QuickEditConfigEnableAuto,
            },
        };
    };
    return QuickEditConfigRoot;
}(QuickEditConfig));


;// CONCATENATED MODULE: ./src/quick-edit/context-for-lists.ts

/**
 * @internal
 */
var ContextForLists = /** @class */ (function () {
    function ContextForLists() {
    }
    ContextForLists.getFromDom = function (tag) {
        var result = JSON.parse(tag.getAttribute(QeSelectors.blocks.cb.context) || null) || {};
        result.appList = []; // empty by default
        if (result != null && typeof (result.apps) === 'string' && result.apps.length > 1)
            result.appList = result.apps
                .split(',')
                .map(function (s) { return s.trim(); }) // trim
                .filter(function (s) { return !!s; }); // drop empty ones
        return result;
    };
    return ContextForLists;
}());


;// CONCATENATED MODULE: ./src/toolbar/config/toolbar-settings.ts
var toolbar_settings_assign = (undefined && undefined.__assign) || function () {
    toolbar_settings_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return toolbar_settings_assign.apply(this, arguments);
};
/** @internal */
var TLB_MORE_END = 'end';
/** @internal */
var TLB_MORE_START = 'start';
/** @internal */
var TLB_MORE_AUTO = 'auto'; // Note: added in 14.07.05
/** @internal */
var TLB_MORE_NEVER = 'never'; // Note: added in 14.07.05
var TLB_MORE_OLD_TRUE = true; //  [true: used to be right/start]
var TLB_MORE_OLD_RIGHT = 'right'; // fallback for older v1 setting
/** @internal */
var TLB_HOV_RIGHT = 'right';
/** @internal */
var TLB_HOV_LEFT = 'left';
/** @internal */
var TLB_HOV_NONE = 'none'; // unclear if this is ever used?
/** @internal */
var TLB_SHOW_ALWAYS = 'always';
/** @internal */
var TLB_SHOW_HOVER = 'hover';
var followDefault = 'default';
/** @internal */
var TLB_FOLLOW_INITIAL = 'initial';
/** @internal */
var TLB_FOLLOW_ALWAYS = 'always';
/** @internal */
var TLB_FOLLOW_SCROLL = 'scroll';
/**
 * Toolbar behavior settings like float, etc.
 * @internal
 */
var ToolbarSettings = /** @class */ (function () {
    function ToolbarSettings(defaults) {
        var _this = this;
        /** Automatically add the '...' more button to the toolbar */
        this.autoAddMore = TLB_MORE_AUTO;
        /** Hover placement of the toolbar */
        this.hover = TLB_HOV_RIGHT;
        /** Show behavior (always, hover, ...) */
        this.show = TLB_SHOW_HOVER;
        /** Follow behavior - if the toolbar should scroll with the page or remain where it was hovered */
        this.follow = followDefault;
        /**
         * Old term, keep for compatibility. Please use `.class` instead
         * @deprecated
         */
        this.classes = '';
        /**
         * Term for the class for simplicity and consistency with button styling
         * New 10.27
         */
        this.class = '';
        /**
         * color configuration which applies to all buttons
         * use "colorname", "#xxyyzz" or "color1,color2" to specify the colors
         * New in 10.27
         */
        this.color = '';
        // Copy all properties of the defaults IF this object also has that property
        if (defaults != null)
            Object.keys(this).forEach(function (k) {
                var kd = k;
                if (defaults[kd])
                    _this[k] = defaults[kd];
            });
        // Swap the real follow-default to be "none"
        if (this.follow === followDefault)
            this.follow = 'none';
    }
    /**
     * removes autoAddMore and classes if are null or empty, to keep same behaviour like in v1
     *
     * Note 2dm: not sure why we're doing this, but it seems like we only need this to merge
     * various objects, so we probably want to make sure the in-html-toolbar doesn't accidentally
     * contain null-items we don't want passed on
     * @param toolbarSettings
     */
    ToolbarSettings.dropEmptyProperties = function (toolbarSettings) {
        var partialSettings = toolbar_settings_assign({}, toolbarSettings);
        if (!partialSettings.autoAddMore)
            delete partialSettings.autoAddMore;
        if (!partialSettings.classes)
            delete partialSettings.classes;
        return partialSettings;
    };
    /**
     * figure out best code to determine where to put it.
     * Important to neutralize historically different param names,
     * and to auto-detect if hover is left.
     * @param settings
     * @returns
     */
    ToolbarSettings.bestAddMorePos = function (settings) {
        var _a;
        var result = (_a = settings === null || settings === void 0 ? void 0 : settings.autoAddMore) !== null && _a !== void 0 ? _a : TLB_MORE_AUTO;
        // On Auto try to detect based on hover position
        if (result === TLB_MORE_AUTO)
            return (settings === null || settings === void 0 ? void 0 : settings.hover) === TLB_HOV_LEFT ? TLB_MORE_START : TLB_MORE_END;
        // Standard values today, just return them
        if (result === TLB_MORE_END || result === TLB_MORE_START || result === TLB_MORE_NEVER)
            return result;
        // Check old values which may still be in use
        if (result === TLB_MORE_OLD_RIGHT || result === TLB_MORE_OLD_TRUE)
            return TLB_MORE_END;
        // If it's anything else we don't know, just return it. It could be a custom class name, though this is not supported.
        return result;
    };
    ToolbarSettings.getDefaults = function () { return new ToolbarSettings({ autoAddMore: TLB_MORE_AUTO, hover: TLB_HOV_RIGHT, show: TLB_SHOW_HOVER, follow: 'default' }); };
    /** Setup for situations where an empty toolbar is needed, without any data or configuration */
    ToolbarSettings.getForEmpty = function () { return new ToolbarSettings({ autoAddMore: TLB_MORE_AUTO, hover: TLB_HOV_LEFT, show: TLB_SHOW_HOVER, follow: 'default' }); };
    return ToolbarSettings;
}());

// TODO: this is in the wrong place, shouldn't be in settings
/**
 * @internal
 */
var ToolbarWhenNoToolbarProvided = {
    toolbar: {},
    settings: ToolbarSettings.getForEmpty(),
};

;// CONCATENATED MODULE: ./src/workflow/workflow-helper.ts

var dummyWorkflowManager;
var debug = false;
/**
 * Various helpers to get a workflow or determine result state
 * @internal
 */
var WorkflowHelper = /** @class */ (function () {
    function WorkflowHelper() {
    }
    /**
     * Find the command workflow on a toolbar (or return null).
     * Will go upwards in the DOM to find the toolbar node which has the configuration stored
     */
    WorkflowHelper.getWorkflow = function (node) {
        if (!node)
            return WorkflowHelper.getDummyManager();
        if (debug)
            console.log('try to find command workflow on ', node);
        var maxParents = 100;
        var parentCount = 0;
        var current = node;
        while (current && parentCount++ < maxParents) {
            var cmdWf = current.commandWorkflow;
            if (cmdWf)
                return cmdWf;
            current = current.parentElement;
        }
        if (debug)
            console.log('not found, will return dummy');
        return WorkflowHelper.getDummyManager();
    };
    /**
     * Get a dummy workflow manager
     *
     * @returns the manager
     * @internal
     */
    WorkflowHelper.getDummyManager = function () {
        if (!dummyWorkflowManager)
            dummyWorkflowManager = new ToolbarWorkflowManager(null, true);
        return dummyWorkflowManager;
    };
    /**
     * Determine if a workflow has been cancelled
     *
     * @returns is cancelled
     * @internal
     */
    WorkflowHelper.isCancelled = function (currentArgs) {
        var cancel = this._isCancelled(currentArgs);
        if (debug)
            console.log('is cancelled: ' + cancel, currentArgs);
        return cancel;
    };
    /**
     *
     * @returns
     * @internal
     */
    WorkflowHelper._isCancelled = function (currentArgs) {
        // promise forgot to return anything, no cancel
        if (currentArgs == null)
            return false;
        // promise returned simple false, cancel
        if (currentArgs === false)
            return true;
        // determine cancel based on either a boolean result or a real WorkflowArguments with cancel.
        return currentArgs.cancel === true;
    };
    return WorkflowHelper;
}());


;// CONCATENATED MODULE: ./src/workflow/toolbar-workflow-manager.ts
var toolbar_workflow_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var toolbar_workflow_manager_assign = (undefined && undefined.__assign) || function () {
    toolbar_workflow_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return toolbar_workflow_manager_assign.apply(this, arguments);
};




/**
 * A workflow manager _of a Toolbar_ which will run stuff before / after commands.
 * When toolbars are created, they will add a Manager and then raise an event for in-page code to add workflow steps.
 * Normally the toolbar with raise a `toolbar-init` event where you can then add steps.
 * @public
 */
var ToolbarWorkflowManager = /** @class */ (function (_super) {
    toolbar_workflow_manager_extends(ToolbarWorkflowManager, _super);
    /**
     * @internal
     */
    function ToolbarWorkflowManager(parentLog, isDummy) {
        if (isDummy === void 0) { isDummy = false; }
        var _this = _super.call(this, 'Cmd.Wrkflw', parentLog, 'constructor') || this;
        _this.isDummy = isDummy;
        /**
         * The workflow steps registered on this toolbar
         * @internal
         */
        _this.steps = [];
        return _this;
    }
    /**
     * Register one or many [workflow-steps](xref:Api.Js.SxcJs.WorkflowStep) to the toolbar, to use if toolbar commands are executed.
     */
    // @publicApi("Used publicly on the Workflow-object in toolbar-init")
    ToolbarWorkflowManager.prototype.add = function (steps) {
        var _this = this;
        if (!steps)
            return;
        if (Array.isArray(steps)) {
            steps.forEach(function (s) { return _this.addOne(s); });
        }
        else
            this.addOne(steps);
    };
    /**
     * Add a single workflow step to this manager
     * @internal
     */
    ToolbarWorkflowManager.prototype.addOne = function (step) {
        step = WorkflowStepHelper.initDefaults(step);
        var cl = this.log.call('add', "'".concat(step.name, "' for '").concat(step.command, "'-'").concat(step.phase, "'"));
        if (!step) {
            var errorMsg = "Trying to add workflow step but didn't get anything";
            cl.add(errorMsg);
            throw errorMsg;
        }
        this.steps.push(step);
        cl.done();
    };
    /**
     * Run a workflow.
     * @internal
     * @returns This will let you chain what happens. The arguments contain a status if it should be cancelled.
     */
    ToolbarWorkflowManager.prototype.run = function (wfArgs) {
        var _this = this;
        var cl = this.log.call('run', "'".concat(wfArgs.command, "' for '").concat(wfArgs.phase, "'"));
        // if this is just a temporary / dummy workflow manager, just return a success-promise
        if (this.isDummy) {
            cl.done('Dummy workflow, nothing to run, will return a resolved promise');
            return emptyWorkflow(wfArgs);
        }
        // Find all steps to run
        var stepsForCommand = this.steps
            // only those of this command or all
            .filter(function (s) { return s.command === wfArgs.command || s.command === WorkflowCommands.all; })
            .filter(function (s) { return s.phase === wfArgs.phase || s.phase === WorkflowPhases.all; })
            // only those having real code
            .filter(function (s) { return s.code; })
            .sort(function (s) { return s.priority; });
        if (stepsForCommand.length === 0) {
            cl.done('no steps found for this command / phase, will return a resolved promise');
            return emptyWorkflow(wfArgs);
        }
        // run in sequence but cancel at any time if necessary
        var promise = new Promise(function (resolve, reject) {
            var promiseChain = Promise.resolve(wfArgs);
            var _loop_1 = function (stepCount) {
                var nextStep = stepsForCommand[stepCount];
                promiseChain = promiseChain.then(function (resultingArgs) {
                    return _this.runNextPromiseIfNotCancelled(resultingArgs, wfArgs, nextStep.code);
                });
            };
            // let previousArgs = wfArgs;
            // let interruptChain = false;
            for (var stepCount = 0; stepCount < stepsForCommand.length; stepCount++) {
                _loop_1(stepCount);
            }
            promiseChain.then(function (finalArgs) { resolve(finalArgs); });
            promiseChain.catch(reject);
        });
        return promise;
    };
    /**
     * Attach a workflow to a toolbar.
     * Will be used at start to hook this manager to the toolbar.
     * Then the init-event will be called to allow adding steps.
     * @internal
     */
    ToolbarWorkflowManager.prototype.attach = function (node, context) {
        var _a;
        var cl = this.log.call('attach');
        if (!node)
            return;
        node.commandWorkflow = this;
        insights_Insights.add('workflow', (_a = context.toolbar) === null || _a === void 0 ? void 0 : _a.identifier, this.log);
        cl.done();
    };
    /**
     *
     * @internal
     */
    ToolbarWorkflowManager.prototype.runNextPromiseIfNotCancelled = function (currentArgs, prevArgs, nextFactory) {
        // determine cancel based on either a boolean result or a real WorkflowArguments with cancel.
        var cancel = WorkflowHelper.isCancelled(currentArgs);
        // make sure we have real arguments no matter what came in - assuming we have prevArgs
        currentArgs = (currentArgs && typeof (currentArgs) !== 'boolean') ? currentArgs : toolbar_workflow_manager_assign({}, prevArgs);
        // in case the cancel came as boolean, we must now set it on the currentArgs
        currentArgs.cancel = cancel;
        return cancel ? emptyWorkflow(currentArgs) : nextFactory(currentArgs);
    };
    return ToolbarWorkflowManager;
}(HasLog));

function emptyWorkflow(wfArgs) {
    return Promise.resolve(wfArgs);
}

;// CONCATENATED MODULE: ./src/workflow/workflow-step-code-arguments.ts
/**
 * Arguments for [WorkflowStepCode](xref:Api.Js.SxcJs.WorkflowStepCode).
 * Will be passed to your code and should also be returned by your code.
 * This also allows cancelling further execution.
 * @public
 */
var WorkflowStepCodeArguments = /** @class */ (function () {
    /**
     * @internal
     */
    function WorkflowStepCodeArguments(
    /**
     * Name this workflow is running for
     */
    command, 
    /**
     * The phase it's in (before, after, etc.)
     */
    phase, 
    /**
     * Context of the current command / step being run
     */
    context, 
    /**
     * Result in after-phases of the workflow
     * BETA - never really tested this
     */
    result) {
        if (result === void 0) { result = null; }
        this.command = command;
        this.phase = phase;
        this.context = context;
        this.result = result;
        /**
         * If the workflow should be cancelled.
         * Can be set by any workflow step.
         * If set to true, following steps / workflows will not run.
         */
        this.cancel = false;
    }
    return WorkflowStepCodeArguments;
}());


;// CONCATENATED MODULE: ./src/workflow/workflow-phases.ts
/**
 * Phases / events of a specific workflow.
 */
var WorkflowPhases;
(function (WorkflowPhases) {
    /**
     * Run at every phase - before and after events/commands
     */
    WorkflowPhases["all"] = "all";
    /**
     * Run before a specific event / command
     */
    WorkflowPhases["before"] = "before";
    /**
     * Run after a specific event / command
     */
    WorkflowPhases["after"] = "after";
})(WorkflowPhases || (WorkflowPhases = {}));

;// CONCATENATED MODULE: ./src/workflow/workflow-step-helper.ts


/**
 * @internal
 */
var WorkflowStepHelper = /** @class */ (function () {
    function WorkflowStepHelper() {
    }
    WorkflowStepHelper.initDefaults = function (step) {
        var _a, _b, _c, _d;
        step.name = (_a = step.name) !== null && _a !== void 0 ? _a : '';
        step.command = (_b = step.command) !== null && _b !== void 0 ? _b : WorkflowCommands.all;
        step.phase = (_c = step.phase) !== null && _c !== void 0 ? _c : WorkflowPhases.before;
        step.priority = (_d = step.priority) !== null && _d !== void 0 ? _d : 1;
        if (!step.code || typeof (step.code) !== 'function')
            throw "Tried preparing a workflow step, but the promise either doesn't exist or is not a promise factory";
        return step;
    };
    return WorkflowStepHelper;
}());


;// CONCATENATED MODULE: ./src/workflow/index.ts









;// CONCATENATED MODULE: ./src/toolbar/toolbar-lifecycle.ts


/**
 * @internal
 */
var ToolbarLifecycle = /** @class */ (function () {
    function ToolbarLifecycle() {
    }
    /**
     * This will be triggered when a hover toolbar has been built,
     * so that on-page JS can register workflows for this toolbar.
     * @static
     * @param {HTMLElement} toolbarElement The toolbar HTML DOM passed into the event
     * @param {HTMLElement} anchoredElement The DOM element which had the @Edit.TagToolbar(...) - on which the event will be raised
     * @param {ContextComplete} context The toolbar context
     */
    ToolbarLifecycle.raiseToolbarInitEvent = function (toolbarElement, anchoredElement, context) {
        var _a;
        var commandWorkflow = new ToolbarWorkflowManager(null);
        commandWorkflow.attach(toolbarElement, context);
        var event = new CustomEvent(C.Toolbar.eventNames.onInit, {
            bubbles: true,
            detail: {
                // type: ToolbarTypes.tag,
                element: toolbarElement,
                identifier: (_a = context.toolbar) === null || _a === void 0 ? void 0 : _a.identifier,
                workflow: commandWorkflow,
            },
        });
        anchoredElement === null || anchoredElement === void 0 ? void 0 : anchoredElement.dispatchEvent(event);
    };
    return ToolbarLifecycle;
}());


;// CONCATENATED MODULE: ./src/toolbar/tag-toolbars/tag-toolbar.ts




/**
 * This is the modern toolbar which is attached to a tag from whic it hovers.
 * Internally the toolbar Dom-Elements are hidden at the bottom of the page.
 * This object is responsible for creating them,
 * and making sure that hover-events etc. cause the right toolbar to show up.
 * @internal
 */
var TagToolbar = /** @class */ (function () {
    /**
     * A Tag-Toolbar which is outside of the module DOM and floating freely
     * @param {HTMLElement} hoverTag
     * @param {ContextComplete} context
     * @param {typeof Translator} [translator] special translator, only included because otherwise WebPack causes circular references
     */
    function TagToolbar(hoverTag, context, translator) {
        var _this = this;
        this.hoverTag = hoverTag;
        this.context = context;
        this.translator = translator;
        this.toolbarElement = null;
        this.initialized = false;
        this.alwaysShow = false;
        /** Remember if scrollwatcher has been enabled */
        this.watcherActive = false;
        /** The update function as a prebuild function, so it can be reused in on/off */
        this.updateFn = function () { return _this.updatePosition(false); };
        this.follow = context.toolbar.settings.follow;
        this.alwaysShow = context.toolbar.settings.show === TLB_SHOW_ALWAYS;
        // Ensure toolbar gets visible when hovering
        this.addMouseEvents(hoverTag);
        if (this.alwaysShow)
            this.showPermanently();
    }
    /**
     * Attach Mouse-Enter and Mouse-Leave events to ensure show/hide of the toolbar
     */
    TagToolbar.prototype.addMouseEvents = function (hoverTag) {
        var _this = this;
        hoverTag.addEventListener('mouseenter', function () { _this.show(); });
        if (!this.alwaysShow)
            hoverTag.addEventListener('mouseleave', function (e) {
                _this.initializeIfNecessary();
                // if we hover the menu itself now, don't hide it
                var relatedTarget = e.relatedTarget;
                if (!_this.toolbarElement.contains(relatedTarget) && _this.toolbarElement !== relatedTarget)
                    _this.hide();
            });
    };
    TagToolbar.prototype.initializeIfNecessary = function () {
        var _this = this;
        var _a;
        if (this.initialized)
            return;
        var nextFreeId = TagToolbarManager.getNextToolbarId();
        var toolbarId = "".concat(this.context.instance.id, "-").concat(this.context.contentBlockReference.id, "-").concat(nextFreeId);
        // render toolbar and append tag to body
        this.toolbarElement = new ToolbarRenderer(this.context).generate();
        // 2021-11-15 2dm disabled this, seems like a duplicate to the attach-mouse-enter which always runs
        if (!this.alwaysShow)
            this.toolbarElement.addEventListener('mouseleave', function (e) {
                // if we do not hover the tag now, hide it
                var relatedTarget = e.relatedTarget;
                if (!_this.hoverTag.contains(relatedTarget) && _this.hoverTag !== relatedTarget)
                    _this.hide();
            });
        document.body.append(this.toolbarElement);
        this.toolbarElement.setAttribute(TagToolbarManager.TagToolbarForAttr, toolbarId);
        this.hoverTag.setAttribute(TagToolbarManager.TagToolbarAttr, toolbarId);
        var toolbarStyle = this.toolbarElement.style;
        toolbarStyle.position = 'absolute';
        // Do the following things on toolbars which are invisible (show != always)
        if (!this.alwaysShow) {
            toolbarStyle.display = 'none';
            toolbarStyle.transition = 'top 0.5s ease-out';
        }
        // ensure it's translated
        (_a = this.translator) === null || _a === void 0 ? void 0 : _a.autoTranslateMenus();
        this.initialized = true;
        // new in v11.12 - toolbar Workflow
        ToolbarLifecycle.raiseToolbarInitEvent(this.toolbarElement, this.hoverTag, this.context);
    };
    TagToolbar.prototype.updatePosition = function (initial) {
        var position = {
            top: 'auto',
            left: 'auto',
            right: 'auto',
            viewportOffset: this.hoverTag.getBoundingClientRect().top,
            bodyOffset: TagToolbarManager.getBodyScrollOffset(),
            tagScrollOffset: 0,
            tagOffset: NoJQ.offset(this.hoverTag),
            tagWidth: NoJQ.outerWidth(this.hoverTag),
            mousePos: TagToolbarManager.mousePosition,
            win: {
                scrollY: window.scrollY,
                width: document.documentElement.clientWidth,
            },
            padding: tagToolbarPadding,
        };
        // If we scrolled down, the toolbar might not be visible - calculate offset
        position.tagScrollOffset = Math.min(position.viewportOffset - position.bodyOffset.top, 0);
        // Update top coordinates
        // new: only do this on initial=true && follow != 'none' or not-initial
        // start by setting default-top
        position.top = position.tagOffset.top + tagToolbarPadding - position.bodyOffset.top;
        var trackMouse = (this.follow === TLB_FOLLOW_ALWAYS)
            || (this.follow === TLB_FOLLOW_INITIAL && initial)
            || (this.follow === TLB_FOLLOW_SCROLL && position.tagScrollOffset !== 0);
        if (trackMouse)
            position.top = position.mousePos.y + position.win.scrollY - position.bodyOffset.top - toolbarHeight / 2;
        // Update left / right coordinates
        if (this.toolbarElement.classList.contains('sc-tb-hover-right'))
            position.right = position.win.width - position.tagOffset.left - position.tagWidth + tagToolbarPaddingRight - position.bodyOffset.left;
        else
            position.left = position.tagOffset.left + tagToolbarPadding + position.bodyOffset.left;
        this.toolbarElement.style.top = typeof position.top === 'number' ? "".concat(position.top, "px") : position.top;
        this.toolbarElement.style.left = typeof position.left === 'number' ? "".concat(position.left, "px") : position.left;
        this.toolbarElement.style.right = typeof position.right === 'number' ? "".concat(position.right, "px") : position.right;
    };
    /**
     * Hide the toolbar and detach scrolling-watcher
     */
    TagToolbar.prototype.hide = function () {
        if (this.alwaysShow)
            return;
        this.toolbarElement.style.display = 'none';
        this.disableScrollWatcher();
    };
    /**
     * Show the toolbar
     */
    TagToolbar.prototype.show = function () {
        // console.log('show');
        this.initializeIfNecessary();
        this.toolbarElement.style.display = 'block';
        this.updatePosition(true);
        this.activateScrollWatcher();
    };
    /**
     * Always show the toolbar.
     */
    TagToolbar.prototype.showPermanently = function () {
        // console.log('show permanently');
        this.show();
        // after a moment, adjust position because often initial position is a bit off
        window.addEventListener('load', this.updateFn);
        document.addEventListener('readystatechange', this.updateFn);
        // Also watch resizing, as the position would be wrong otherwise
        window.addEventListener('resize', this.updateFn);
    };
    /** Enable scroll watcher & remember */
    TagToolbar.prototype.activateScrollWatcher = function () {
        if (this.watcherActive)
            return;
        var trackOngoing = this.follow === TLB_FOLLOW_SCROLL || this.follow === TLB_FOLLOW_ALWAYS;
        if (!trackOngoing)
            return;
        window.addEventListener('scroll', this.updateFn);
        if (this.follow === TLB_FOLLOW_ALWAYS)
            window.addEventListener('mousemove', this.updateFn);
        this.watcherActive = true;
    };
    /** Disable scroll watcher - if it is active */
    TagToolbar.prototype.disableScrollWatcher = function () {
        if (!this.watcherActive)
            return;
        window.removeEventListener('scroll', this.updateFn);
        window.removeEventListener('mousemove', this.updateFn);
        this.watcherActive = false;
    };
    return TagToolbar;
}());

var tagToolbarPadding = 4;
var tagToolbarPaddingRight = 0;
var toolbarHeight = 20;

;// CONCATENATED MODULE: ./src/toolbar/tag-toolbars/tag-toolbar-manager.ts

/**
 * The global Tag Toolbar Manager is responsible for the new TagToolbars
 * These have certain shared aspects, like:
 * - a numbering scheme to keep them apart
 * - a mouse tracker to keep track of the position as the toolbar follows the scroll
 * @internal
 */
var TagToolbarManager = /** @class */ (function () {
    function TagToolbarManager() {
    }
    /** The next free ID to mark a TagToolbar */
    TagToolbarManager.getNextToolbarId = function () {
        return TagToolbarManager.lastMenuId++;
    };
    /**
     * Returns the body offset if positioning is relative or absolute
     */
    TagToolbarManager.getBodyScrollOffset = function () {
        var posNoJq = document.body.style.position;
        var body = document.body;
        var bodyPos = posNoJq; // body.css('position');
        if (bodyPos === 'relative' || bodyPos === 'absolute') {
            var offset = NoJQ.offset(body);
            return {
                top: offset.top,
                left: offset.left,
            };
        }
        return {
            top: 0,
            left: 0,
        };
    };
    /**
     * Remove orphan tag-toolbars from DOM
     * This can be necessary if the module was replaced by ajax,
     * leaving behind un-attached TagToolbars.
     */
    TagToolbarManager.CleanupOrphanedToolbars = function () {
        var tagToolbars = document.querySelectorAll("[".concat(TagToolbarManager.TagToolbarForAttr, "]"));
        tagToolbars.forEach(function (e) {
            var id = e.getAttribute(TagToolbarManager.TagToolbarForAttr);
            if (!document.querySelectorAll("[".concat(TagToolbarManager.TagToolbarAttr, "=\"").concat(id, "\"]")).length) {
                e.remove();
            }
        });
    };
    /** Mark Dom-Notes with the ID which Tag-Toolbar they want on mouse-over */
    TagToolbarManager.TagToolbarAttr = 'data-tagtoolbar';
    /** Mark TagToolbar Html-Nodes with the ID of the Dom-Tag they belong to */
    TagToolbarManager.TagToolbarForAttr = 'data-tagtoolbar-for';
    /** The current mouseposition, always updated when the mouse changes */
    TagToolbarManager.mousePosition = {
        x: 0,
        y: 0,
    };
    TagToolbarManager.lastMenuId = 0;
    return TagToolbarManager;
}());

/**
 * Keep the mouse-position update for future use
 */
window.addEventListener('mousemove', function (e) {
    TagToolbarManager.mousePosition.x = e.clientX;
    TagToolbarManager.mousePosition.y = e.clientY;
});

;// CONCATENATED MODULE: ./src/toolbar/config/button-command.ts
var button_command_assign = (undefined && undefined.__assign) || function () {
    button_command_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return button_command_assign.apply(this, arguments);
};

/**
 * @internal
 */
var ButtonCommand = /** @class */ (function () {
    // customCode: string;
    function ButtonCommand(name, /* contentType?: string, */ params) {
        this.name = name;
        this.params = params;
        if (!params)
            this.params = {};
        // 2dm 2022-07-05 #badContentTypeExtractAndRefill - we seem to extract it, just to put it back on the ButtonCommand
        // if (contentType) this.params.contentType = contentType;
        this.command = Commands.singleton().get(name); // activate command for this
    }
    /** make static, as many ButtonCommand signatures are actually not objects */
    ButtonCommand.mergeAdditionalParams = function (command, additionalParams) {
        var params = {};
        if (command) {
            if (command.name)
                params.action = command.name;
            if (command.params)
                params = button_command_assign(button_command_assign(button_command_assign({}, params), command.params), additionalParams);
        }
        command.params = params;
        return params;
    };
    return ButtonCommand;
}());


;// CONCATENATED MODULE: ./src/toolbar/config/button.ts

/**
 * The real button configuration as it's used at runtime
 * @internal
 */
var Button = /** @class */ (function () {
    function Button(command, name) {
        var _a;
        /** classes which will be applied to this button */
        this.classes = '';
        /** Determine if it should use the inline window, always a function */
        this.inlineWindow = function () { return false; };
        this.command = command;
        // if the name is an identifier, split it
        var parts = Button.splitName(name);
        this.id = parts.id;
        // this.name = parts.name;
        // get defaults from action commandDefinition
        if ((_a = command === null || command === void 0 ? void 0 : command.command) === null || _a === void 0 ? void 0 : _a.buttonDefaults)
            Obj.TypeSafeAssign(this, command.command.buttonDefaults);
    }
    Button.splitName = function (identifier) {
        var parts = identifier.split('=');
        return { id: parts[0], name: (parts[1] || identifier) };
    };
    /** Detect if this is a Button */
    Button.is = function (thing) {
        return thing.command !== undefined;
    };
    Button.isArray = function (thing) {
        return thing.length && Button.is(thing[0]);
    };
    Button.isPropGen = function (thing) {
        return typeof thing === 'function';
    };
    return Button;
}());


;// CONCATENATED MODULE: ./src/toolbar/config/button-safe.ts


/**
 * Special helper to read a button configuration
 * and make sure that all properties have the correct fallback values
 * @internal
 */
var ButtonSafe = /** @class */ (function () {
    function ButtonSafe(button, context) {
        var _this = this;
        this.button = button;
        this.context = context;
        this.action = function () { return _this.button.command; };
        this.classes = function () { return _this.button.classes || ''; };
        /** The dialog name - should default to the name */
        this.dialog = function () { return getVal(_this.button.dialog, _this.context, _this.button.command.name); };
        /** Determines if the button should be disabled */
        this.disabled = function () { return getVal(_this.button.disabled, _this.context, false); };
        /** Dynamicaly determine classes - must always be a function */
        this.dynamicClasses = function () { return getVal(_this.button.dynamicClasses, _this.context, ''); };
        /** Check if full-screen, always a function */
        this.fullScreen = function () { return getVal(_this.button.fullScreen, _this.context, false); };
        /** The icon to show in the button */
        this.icon = function () { return getVal(_this.button.icon, _this.context, ''); };
        /** Determine if it should use the inline window, always a function */
        this.inlineWindow = function () { return getVal(_this.button.inlineWindow, _this.context, false); };
        /** Check if we should open a new window, always an FN */
        this.newWindow = function () { return getVal(_this.button.newWindow, _this.context, false); };
        /** The parameters which are used to run the command */
        this.addParamsToLink = function () { return getVal(_this.button.addParamsToLink, _this.context, {}); };
        /** Determines if this button runs in the page - affecting publishing */
        this.partOfPage = function () { return getVal(_this.button.partOfPage, _this.context, false); };
        /** Method which determines if it should be shown or not */
        this.showCondition = function () { return getVal(_this.button.showCondition, _this.context, true); };
        /** The title of this button which will usually be i18n keys */
        this.title = function () { return getVal(_this.button.title, _this.context, 'unknown-title'); };
        /** this is just a UI interaction, won't create data so won't need pre-flight */
        this.uiActionOnly = function () { return getVal(_this.button.uiActionOnly, _this.context, true); };
    }
    return ButtonSafe;
}());

/** Evaluate a property or generator and return the property */
function getVal(propOrGen, ctx, fallback) {
    if (isNothing(propOrGen))
        return fallback;
    var result = (Button.isPropGen(propOrGen) ? propOrGen(ctx) : propOrGen);
    return result === undefined ? fallback : result;
}

;// CONCATENATED MODULE: ./src/toolbar/config/button-group.ts
/**
 * @internal
 */
var ButtonGroup = /** @class */ (function () {
    function ButtonGroup(buttons) {
        this.buttons = buttons;
        this.defaults = {};
        // adds these to the items
        this.buttons = buttons || [];
    }
    /** Detect if this is a ButtonGroup */
    ButtonGroup.is = function (thing) {
        return thing.buttons !== undefined;
    };
    /** Detect if this is a ButtonGroup */
    ButtonGroup.isArray = function (thing) {
        return thing.length && thing[0].buttons !== undefined;
    };
    return ButtonGroup;
}());


;// CONCATENATED MODULE: ./src/toolbar/config/toolbar.ts
/**
 * Runtime configuration of the toolbar.
 * contains a toolbar config + settings + mny groups
 * @internal
 */
var Toolbar = /** @class */ (function () {
    function Toolbar() {
        /** The groups of buttons in this toolbar */
        this.groups = [];
        /** show more debug info */
        this.debug = false;
        this.identifier = Toolbar.createIdentifier();
    }
    Toolbar.createIdentifier = function () {
        return 'Toolbar' + Math.floor(Math.random() * 99999);
    };
    return Toolbar;
}());


;// CONCATENATED MODULE: ./src/toolbar/config/index.ts
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 

;// CONCATENATED MODULE: ./src/toolbar/render/render-part-base.ts
var render_part_base_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * Base class for inner part renderers.
 * The goal is that we have the code in own objects, but that these can only be used
 * from the primary parent object of the type ToolbarRenderer
 *
 * @internal
 */
var RenderPart = /** @class */ (function (_super) {
    render_part_base_extends(RenderPart, _super);
    function RenderPart(parent, logName) {
        var _this = _super.call(this, logName, parent.log) || this;
        _this.parent = parent;
        return _this;
    }
    return RenderPart;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/render/render-button.ts
var render_button_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var render_button_assign = (undefined && undefined.__assign) || function () {
    render_button_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return render_button_assign.apply(this, arguments);
};
var render_button_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};



/**
 * @internal
 */
var RenderButton = /** @class */ (function (_super) {
    render_button_extends(RenderButton, _super);
    function RenderButton(parent) {
        return _super.call(this, parent, 'Rnd.Button') || this;
    }
    RenderButton.prototype.render = function (ctx, groupIndex) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        var cl = this.log.call('render', "contex: obj, group: ".concat(groupIndex, ", btn: ").concat(ctx.button.id, "/").concat((_a = ctx.button.command) === null || _a === void 0 ? void 0 : _a.name));
        var btnSafe = new ButtonSafe(ctx.button, ctx);
        // check if we have rules and merge params into the button
        var rule = (_d = (_c = (_b = ctx.toolbar) === null || _b === void 0 ? void 0 : _b.settings) === null || _c === void 0 ? void 0 : _c._rules) === null || _d === void 0 ? void 0 : _d.find(ctx.button.id);
        if (rule)
            cl.data('rule found, will try to merge params', rule);
        var params = ButtonCommand.mergeAdditionalParams(btnSafe.action(), rule === null || rule === void 0 ? void 0 : rule.params);
        var group = (_f = (_e = ctx.toolbar) === null || _e === void 0 ? void 0 : _e.groups) === null || _f === void 0 ? void 0 : _f[groupIndex];
        var groupName = group === null || group === void 0 ? void 0 : group.name;
        var btnLink = document.createElement('a');
        var disabled = btnSafe.disabled();
        // put call as plain JavaScript to preserve even if DOM is serialized
        if (!disabled)
            btnLink.setAttribute('onclick', this.generateRunJs(rule, ctx, params));
        // Add various classes
        var classes = (disabled ? ' disabled' : '')
            + (btnSafe.action() ? " sc-".concat(btnSafe.action().name) : '')
            + " in-group-".concat(groupIndex)
            + (groupName ? " in-group-".concat(groupName) : '')
            + ' ' + ((_g = rule === null || rule === void 0 ? void 0 : rule.ui.class) !== null && _g !== void 0 ? _g : '')
            + ' ' + ((_h = rule === null || rule === void 0 ? void 0 : rule.ui.classes) !== null && _h !== void 0 ? _h : '')
            + ' ' + btnSafe.classes()
            + ' ' + btnSafe.dynamicClasses();
        cl.add('classes: ' + classes);
        HtmlTools.addClasses(btnLink, classes);
        // set title for button, optionally with i18n
        this.setTitle(rule, btnLink, btnSafe);
        var divTag = document.createElement('div');
        divTag.appendChild(this.iconTag(btnSafe, rule));
        btnLink.appendChild(divTag);
        // set color - new in 10.27
        this.processColorRules(rule, ctx, divTag);
        return cl.return(btnLink);
    };
    RenderButton.prototype.setTitle = function (rule, btnLink, btn) {
        var _a;
        var callLog = this.log.call('setTitles');
        var uiTitle = (_a = rule === null || rule === void 0 ? void 0 : rule.ui) === null || _a === void 0 ? void 0 : _a.title;
        if (uiTitle) {
            callLog.add("uiTitle: ".concat(uiTitle));
            btnLink.setAttribute('title', uiTitle);
        }
        else {
            var i18nTitle = btn.title();
            callLog.add("i18nTitle: ".concat(i18nTitle));
            if (i18nTitle)
                btnLink.setAttribute('data-i18n', "[title]".concat(i18nTitle));
        }
        callLog.done();
    };
    RenderButton.prototype.processColorRules = function (rule, ctx, divTag) {
        var _a;
        var callLog = this.log.call('processColorRules');
        var color = ((_a = rule === null || rule === void 0 ? void 0 : rule.ui) === null || _a === void 0 ? void 0 : _a.color) || ctx.toolbar.settings.color;
        // catch edge case where the color is something like 808080 - which is treated as a number
        if (color && typeof color === 'number')
            color = color.toString();
        if (color && typeof color === 'string') {
            var parts = color.split(',');
            if (parts[0])
                divTag.style.backgroundColor = correctColorCodes(parts[0]);
            if (parts[1])
                divTag.style.color = correctColorCodes(parts[1]);
        }
        return callLog.done(color !== null && color !== void 0 ? color : 'no color');
    };
    RenderButton.prototype.generateRunJs = function (rule, ctx, params) {
        // 2022-05-18 2dm: #CustomContext New we can override the context
        var modifyContext = rule === null || rule === void 0 ? void 0 : rule.context;
        if (!modifyContext || Object.keys(modifyContext).length === 0)
            modifyContext = undefined;
        else
            modifyContext = render_button_assign(render_button_assign({}, modifyContext), { complete: true });
        var targetContext = modifyContext ? JSON.stringify(modifyContext) : "".concat(ctx.instance.id, ", ").concat(ctx.contentBlockReference.id);
        // 2022-06-28 experimental trying to move to cms.run
        if ((params === null || params === void 0 ? void 0 : params.action) === "code" /* CommandNames.code */) {
            var action = params.action, cleanParams = render_button_rest(params, ["action"]);
            var newP = { action: params.action, params: cleanParams };
            return "$2sxc(".concat(targetContext, ").cms.run(").concat(JSON.stringify(newP), ", event);");
        }
        return "$2sxc(".concat(targetContext, ").manage.run(").concat(JSON.stringify(params), ", event);");
    };
    RenderButton.prototype.iconTag = function (btn, rule) {
        var _a;
        var callLog = this.log.call('iconTag');
        var icon = ((_a = rule === null || rule === void 0 ? void 0 : rule.ui) === null || _a === void 0 ? void 0 : _a.icon) || btn.icon();
        if (icon.indexOf('<svg') > -1) {
            // Temporary dom element
            var symbol = document.createElement('template');
            symbol.innerHTML = icon;
            // Note: It would be tempting to set the viewBox here, but it's not possible
            // because we cannot calculate the size before rendering
            return callLog.return(symbol.content.firstChild, icon);
        }
        else {
            var symbol = document.createElement('i');
            HtmlTools.addClasses(symbol, icon);
            symbol.setAttribute('aria-hidden', 'true');
            return callLog.return(symbol, icon);
        }
    };
    return RenderButton;
}(RenderPart));

// detect Hex-colors 6-digits or 8 in case transparent
var colorDetect = '^([A-Fa-f0-9]{6,8})$';
function correctColorCodes(color) {
    if (color && color.match(colorDetect))
        return '#' + color;
    return color;
}

;// CONCATENATED MODULE: ./src/toolbar/render/render-groups.ts
var render_groups_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @internal
 */
var RenderButtonGroups = /** @class */ (function (_super) {
    render_groups_extends(RenderButtonGroups, _super);
    function RenderButtonGroups(parent) {
        return _super.call(this, parent, 'Rnd.Groups') || this;
    }
    RenderButtonGroups.prototype.generate = function (context) {
        var cl = this.log.call('generate');
        var tags = []; // temporary storage for detached HTML DOM objects
        var btnGroups = context.toolbar.groups;
        for (var i = 0; i < btnGroups.length; i++)
            tags = tags.concat(this.generateGroup(btnGroups[i], context, i));
        return cl.return(tags, "total tags: ".concat(tags.length));
    };
    RenderButtonGroups.prototype.generateGroup = function (group, context, groupNumber) {
        var cl = this.log.call('generateGroup', "group #".concat(groupNumber));
        var tags = []; // temporary storage for detached HTML DOM objects
        var btns = group.buttons;
        for (var h = 0; h < btns.length; h++) {
            var btnContext = context.forButton(btns[h]);
            var tag = this.parent.button.render(btnContext, groupNumber);
            // add button to group of buttons
            var item = document.createElement('li');
            item.appendChild(tag);
            tags.push(item);
        }
        return cl.return(tags, "tags: ".concat(tags.length));
    };
    return RenderButtonGroups;
}(RenderPart));


;// CONCATENATED MODULE: ./src/toolbar/render/toolbar-renderer.ts
var toolbar_renderer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var attrIdentifier = 'toolbar-identifier';
/**
 * @internal
 */
var ToolbarRenderer = /** @class */ (function (_super) {
    toolbar_renderer_extends(ToolbarRenderer, _super);
    function ToolbarRenderer(context) {
        var _this = this;
        var _a;
        _this = _super.call(this, 'Rnd.Toolbr') || this;
        _this.context = context;
        insights_Insights.add('toolbar-render', ((_a = context.toolbar) === null || _a === void 0 ? void 0 : _a.identifier) || '', _this.log);
        _this.groups = new RenderButtonGroups(_this);
        _this.button = new RenderButton(_this);
        return _this;
    }
    /**
     * Convert a generated Toolbar into an HTML-string.
     * AFAIK it's only used in external scripts through older APIs, and never called directly.
     */
    ToolbarRenderer.prototype.render = function () {
        var cl = this.log.call('generate');
        return cl.return(this.generate().outerHTML);
    };
    /**
     * Generate an HTML toolbar tag for adding to the page
     */
    ToolbarRenderer.prototype.generate = function () {
        var _a;
        var cl = this.log.call('generate');
        // render groups of buttons
        var context = this.context;
        cl.data('toolbar config', context.toolbar);
        var groups = this.groups.generate(context);
        // render toolbar
        var tlbTag = document.createElement('ul');
        tlbTag.setAttribute(attrIdentifier, (_a = context.toolbar) === null || _a === void 0 ? void 0 : _a.identifier);
        tlbTag.classList.add(IDs.cls.scMenu);
        tlbTag.classList.add('group-0'); // IE11 fix, add each class separately
        // add behaviour classes
        var settings = context.toolbar.settings;
        tlbTag.classList.add("sc-tb-hover-".concat(settings.hover));
        tlbTag.classList.add("sc-tb-show-".concat(settings.show));
        if (CmdParHlp.getIndex(context.toolbar.params) === -1)
            tlbTag.classList.add('listContent');
        if (context.toolbar.params.fields)
            tlbTag.classList.add('sc-sublist');
        HtmlTools.addClasses(tlbTag, settings.class || settings.classes);
        // add button groups to toolbar
        tlbTag.setAttribute('group-count', context.toolbar.groups.length.toString());
        for (var g = 0; g < groups.length; g++)
            tlbTag.appendChild(groups[g]);
        return cl.return(tlbTag, 'done');
    };
    return ToolbarRenderer;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/initialize/toolbar-init-config.ts


/**
 * The configuration / settings of a toolbar as loaded from the DOM
 * @internal
 */
var ToolbarInitConfig = /** @class */ (function () {
    function ToolbarInitConfig() {
    }
    /**
     * Load the toolbar configuration from the sxc-toolbar attribute OR the old schema
     * @param tag
     * @returns a configuration object or null in case of an error
     */
    ToolbarInitConfig.loadFromTag = function (tag) {
        try {
            var newConfigFormat = HtmlTools.tryGetAttrText(tag, C.Toolbar.attr.full);
            if (newConfigFormat) {
                var result = JSON.parse(newConfigFormat);
                // check for new V10.27 format, which is just an array!
                if (Array.isArray(result))
                    return { toolbar: result };
                return result;
            }
            else {
                var at = C.IDs.attr;
                var data = HtmlTools.getFirstAttribute(tag, at.toolbar, at.toolbarData);
                var settings = HtmlTools.getFirstAttribute(tag, at.settings, at.settingsData);
                return {
                    toolbar: JSON.parse(data),
                    settings: JSON.parse(settings),
                };
            }
        }
        catch (err) {
            console.error('error in settings JSON - probably invalid - make sure you quote properties like "name": ...', tag, err);
            return null;
        }
    };
    return ToolbarInitConfig;
}());


;// CONCATENATED MODULE: ./src/toolbar/initialize/toolbar-finder-and-initializer.ts
var toolbar_finder_and_initializer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();









// quick debug - set to false if not needed for production
var dbg = false;
/**
 * @internal
 */
var toolbar_finder_and_initializer_toolbarSelector = ".sc-menu[toolbar],.sc-menu[data-toolbar],[".concat(C.Toolbar.attr.full, "]");
/**
 * This class is responsible for finding toolbar configurations in the doom
 * and then initializing them.
 * @internal
 */
var ToolbarConfigFinderAndInitializer = /** @class */ (function (_super) {
    toolbar_finder_and_initializer_extends(ToolbarConfigFinderAndInitializer, _super);
    /**
     * Special constructor which only allows this builder to be instatiated from the TagManager
     * This is to simplify program control flow
     */
    function ToolbarConfigFinderAndInitializer(tlbManager) {
        var _this = _super.call(this, 'Tlb.Buildr', tlbManager.log) || this;
        _this.tlbManager = tlbManager;
        return _this;
    }
    /**
     * Generate toolbars inside a MODULE tag (usually a div with class sc-edit-context)
     * @param parentTag
     * @param optionalId
     */
    ToolbarConfigFinderAndInitializer.prototype.buildDnnModule = function (parentTag) {
        var _this = this;
        var cl = this.log.call('buildDnnModule');
        // if something says the toolbars are disabled, then skip
        if (parentTag.getAttribute(C.Toolbar.attr.disable))
            return cl.done('disabled');
        var toolbars = this.findChildTagsWithConfig(parentTag);
        // no toolbars found, must help a bit because otherwise editing is hard
        if (toolbars.length === 0) {
            toolbars = addDefaultToolbarConfigToTag(parentTag);
            if (toolbars == null)
                return cl.done('toolbars=null');
        }
        toolbars.forEach(function (e) { return _this.loadConfigAndInitialize(e); });
        // ensure translations are rebuilt
        translator_Translator.autoTranslateMenus();
        cl.done();
    };
    /**
     * Build toolbar, but allow an html node as target
     * Will automatically find a wrapping sc-edit-context and all containing toolbars
     * @param node
     */
    ToolbarConfigFinderAndInitializer.prototype.build = function (node) {
        var _this = this;
        // for toolbars that are not inside 2sxc modules (e.g. in skin)
        if (node.matches(toolbar_finder_and_initializer_toolbarSelector) && !node.closest(C.Sel.SxcDivs)) {
            this.loadConfigAndInitialize(node);
            return;
        }
        // go up the DOM to find the parent which has context-information
        // if we have no contextNode (a parent content block), we can
        // assume the node is outside of a 2sxc module so not interesting
        var contextNode = node.closest(C.Cb.selectors.ofName);
        if (contextNode == null)
            return;
        // check if the current node needs a toolbar
        if (node.matches(toolbar_finder_and_initializer_toolbarSelector))
            this.loadConfigAndInitialize(node);
        // activate all child-nodes with toolbars
        var toolbars = node.querySelectorAll(toolbar_finder_and_initializer_toolbarSelector);
        toolbars.forEach(function (e) { return _this.loadConfigAndInitialize(e); });
    };
    //////////////////////////////// Private Functions ////////////////////////////////////
    /**
     * find current toolbars inside this wrapper-tag
     */
    ToolbarConfigFinderAndInitializer.prototype.findChildTagsWithConfig = function (parentTag) {
        var allInner = Array.from(parentTag.querySelectorAll(toolbar_finder_and_initializer_toolbarSelector));
        // return only those, which don't belong to a sub-item
        var onlyDirectDescendents = allInner.filter(function (e) { return e.closest(C.Cb.selectors.ofName) === parentTag; });
        if (dbg)
            console.log('found toolbars for parent', parentTag, onlyDirectDescendents);
        return onlyDirectDescendents;
    };
    /**
     * Setup a toolbar for a specific tag/node by loading its self-contained configuration
     * and replacing / preparing the toolbar as needed.
     * @param node
     */
    ToolbarConfigFinderAndInitializer.prototype.loadConfigAndInitialize = function (tag) {
        var cl = this.log.call('loadConfigAndInitialize');
        // Do not process tag if a toolbar has already been attached
        if (tag.getAttribute("data-".concat(C.Toolbar.attrToMarkInitalized)))
            return cl.done('already initialized');
        var config = ToolbarInitConfig.loadFromTag(tag);
        if (config != null) { // is null if load failed
            // catch errors, as this is very common - make sure the others are still rendered
            try {
                this.convertConfigToToolbars(tag, config);
            }
            catch (err2) {
                console.error('error creating toolbar - will skip this one', err2);
            }
        }
        cl.done();
    };
    /**
     * Take a configuration and convert into a toolbar-menu; also attach the hover-attribute
     * @param tag
     * @param config
     */
    ToolbarConfigFinderAndInitializer.prototype.convertConfigToToolbars = function (tag, config) {
        var cl = this.log.call('convertConfigToToolbars');
        cl.data('tag', tag);
        cl.data('config', config);
        var context = ContextComplete.findContext(tag);
        context.toolbar = this.tlbManager.loadConfig(context, config);
        // V2 where the full toolbar is included in one setting
        if (tag.getAttribute(C.Toolbar.attr.full)) {
            cl.add('V2 TagToolbar detected');
            var tagToolbar = new TagToolbar(tag, context, translator_Translator);
            tag.setAttribute("data-".concat(C.Toolbar.attrToMarkInitalized), "".concat(tagToolbar != null));
            this.addHoverAttributeToTag(tag);
            return cl.done();
        }
        // default case, tag is the old <ul> tag, so find the sc-element parent before replacing
        var toolbar = new ToolbarRenderer(context).generate();
        var hoverParent = tag.closest(C.Toolbar.selectors.ofOldHover);
        cl.data('parentTag', hoverParent);
        tag.replaceWith(toolbar);
        if (hoverParent) {
            cl.add('V1 hover-toolbar and parents found - will add attribute');
            this.addHoverAttributeToTag(hoverParent);
        }
        // Also run toolbar-init on the new toolbar.
        // Must use var 'toolbar' and not 'tag', as that is kind of reset/not existing at this
        // So the event would get lost
        // Added in 12.10
        ToolbarLifecycle.raiseToolbarInitEvent(toolbar, toolbar, context);
        cl.done();
    };
    /**
     * add hover-attribute to tag which is responsible for the menu to appear/disappear
     */
    ToolbarConfigFinderAndInitializer.prototype.addHoverAttributeToTag = function (tag) {
        var cl = this.log.call('addHoverAttributeToTag');
        if (!tag)
            return cl.done('no tag found'); // skip in case nothing was given
        if (!tag.hasAttribute(C.Toolbar.attr.hover)) {
            cl.add('will add attribute ' + C.Toolbar.attr.hover);
            tag.setAttribute(C.Toolbar.attr.hover, '');
        }
        cl.done();
    };
    return ToolbarConfigFinderAndInitializer;
}(HasLog));

//////////////////////////////// Private Functions ////////////////////////////////////
/**
 * Create a default/fallback toolbar and return it
 */
function addDefaultToolbarConfigToTag(parentTag) {
    if (dbg)
        console.log("didn't find toolbar, so will auto-create", parentTag);
    var outsideCb = !parentTag.classList.contains(C.Cb.classes.name);
    var contentTag = outsideCb ? parentTag.querySelector("div".concat(C.Cb.selectors.ofName)) : parentTag;
    // auto toolbar
    var ctx = ContextComplete.findContext(contentTag);
    if (ctx.ui.autoToolbar === false)
        return null;
    contentTag.setAttribute(C.Toolbar.attr.full, JSON.stringify(ToolbarWhenNoToolbarProvided));
    return [contentTag];
}

;// CONCATENATED MODULE: ./src/toolbar/index.ts








;// CONCATENATED MODULE: ./src/toolbar/config-loaders/config-formats/in-page-button.ts
/**
 * Button Definition v1. from old API
 * it is publicly used out of inpage, so take a care to preserve its signature
 * @internal
 */
var InPageButtonJson = /** @class */ (function () {
    function InPageButtonJson() {
    }
    // check two common signatures - command and action
    InPageButtonJson.is = function (thing) {
        return thing.command !== undefined || thing.action !== undefined;
    };
    InPageButtonJson.isArray = function (thing) {
        return thing.length > 0 && InPageButtonJson.is(thing[0]);
    };
    InPageButtonJson.toButton = function (oldFormat) {
        var config = {};
        // simple value properties
        if (oldFormat.classes)
            config.classes = oldFormat.classes;
        if (oldFormat.dialog)
            config.dialog = oldFormat.dialog;
        if (oldFormat.disabled)
            config.disabled = oldFormat.disabled;
        if (oldFormat.icon)
            config.icon = oldFormat.icon;
        // Method Properties
        if (oldFormat.fullScreen)
            config.fullScreen = evalPropOrFun(oldFormat.fullScreen);
        if (oldFormat.icon)
            config.icon = evalPropOrFun(oldFormat.icon);
        if (oldFormat.inlineWindow)
            config.inlineWindow = evalPropOrFun(oldFormat.inlineWindow);
        if (oldFormat.newWindow)
            config.newWindow = evalPropOrFun(oldFormat.newWindow);
        if (oldFormat.partOfPage)
            config.partOfPage = evalPropOrFun(oldFormat.partOfPage);
        if (oldFormat.title)
            config.title = evalPropOrFun(oldFormat.title);
        return config;
    };
    return InPageButtonJson;
}());

function evalPropOrFun(propOrFunction) {
    if (propOrFunction === undefined || propOrFunction === null)
        return false;
    if (typeof (propOrFunction) === 'function')
        return propOrFunction;
    return function () { return propOrFunction; };
}

;// CONCATENATED MODULE: ./src/toolbar/config-loaders/config-formats/in-page-command.ts
/**
 * @internal
 */
var InPageCommandJson = /** @class */ (function () {
    function InPageCommandJson() {
    }
    InPageCommandJson.hasActions = function (thing) {
        // check two common signatures - command and action
        return typeof thing.action === 'string';
    };
    InPageCommandJson.hasModify = function (thing) {
        // check two common signatures - command and action
        return !!thing.modify;
    };
    /** Important for object merging - because otherwise action will be preserved */
    InPageCommandJson.noAction = function (thing) {
        // some clean-up
        delete thing.action; // remove the action property
        return thing;
    };
    return InPageCommandJson;
}());


;// CONCATENATED MODULE: ./src/toolbar/config-loaders/config-formats/in-page-button-group.ts
/**
 * @internal
 */
var InPageButtonGroupJson = /** @class */ (function () {
    function InPageButtonGroupJson() {
    }
    return InPageButtonGroupJson;
}());


;// CONCATENATED MODULE: ./src/toolbar/config-loaders/button-config-loader.ts
var button_config_loader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * This is a system to build button configurations
 * @internal
 */
var ButtonConfigLoader = /** @class */ (function (_super) {
    button_config_loader_extends(ButtonConfigLoader, _super);
    function ButtonConfigLoader(toolbar) {
        var _this = _super.call(this, 'Tlb.BtCfBl', toolbar.log) || this;
        _this.toolbar = toolbar;
        return _this;
    }
    /**
     * takes an object like "actionname" or { action: "actionname", ... }
     * and changes it to a { command: { action: "actionname" }, ... }
     */
    ButtonConfigLoader.prototype.normalize = function (original) {
        var cl = this.log.call('normalize');
        cl.data('initial', original);
        // prevent multiple inits
        var asBtnConfig = original;
        if (asBtnConfig._expanded || asBtnConfig.command)
            return cl.return(asBtnConfig, "already expanded, won't modify");
        // if just a name, turn into a command
        // use the deep version with command.action, because of more clean-up later on
        if (typeof original === 'string')
            return cl.return(this.btnConfigStructure(original, {}), 'found name, use that');
        // if it's a command w/action, wrap into command + trim
        if (InPageCommandJson.hasActions(original)) {
            cl.add('action found, will move down to .command', original);
            if (original.action)
                original.action = original.action.trim();
            return cl.return({
                command: original,
                _expanded: true,
            }, 'had actions, convert to commands');
        }
        throw 'can\'t expand InPageButtonConfiguration - unexpected type signature encountered';
    };
    ButtonConfigLoader.prototype.btnConfigStructure = function (name, params) {
        var wrapLog = this.log.call('getFromName', name);
        return wrapLog.return({
            command: {
                action: name.trim(),
                params: params,
            },
            _expanded: true,
        }, "name \"".concat(name, "\" found, will re-map to .command.action"));
    };
    /**
     * remove buttons which are not valid based on add condition
     */
    ButtonConfigLoader.prototype.removeDisableButtons = function (context, full) {
        var wrapLog = this.log.call('removeDisableButtons', "length of groups: ".concat(full.groups.length));
        var btnGroups = full.groups;
        for (var g = 0; g < btnGroups.length; g++) {
            var btns = btnGroups[g].buttons;
            // #CodeChange#2020-03-22#InstanceConfig - believe this is completely unused; remove in June
            // const config = InstanceConfig.fromContext(context);
            this.removeUnfitButtons(context, /* full,*/ btns /* config, */);
            wrapLog.add('will disable appropriate buttons');
            // #CodeChange#2020-03-22#InstanceConfig - believe this is completely unused; remove in June
            // disableButtons(context, btns/*, config */);
            // remove the group, if no buttons left, or only "more"
            if (btns.length === 0 || (btns.length === 1 && btns[0].command.name === "more" /* CommandNames.more */)) {
                wrapLog.add('found no more buttons except for the "more" - will remove that group');
                btnGroups.splice(g--, 1); // remove, and decrement counter
            }
        }
        wrapLog.return(null);
    };
    /**
     * enhance button-object with default icons, etc.
     */
    ButtonConfigLoader.prototype.addDefaultBtnSettings = function (btn, groupDefaults, tlbDefaults, actions) {
        var cl = this.log.call('addDefaultBtnSettings', '', "for ".concat(function () { return btn.command.name; }));
        for (var d = 0; d < btnProperties.length; d++)
            fallbackBtnSetting(btn, groupDefaults, tlbDefaults, actions, btnProperties[d]);
        cl.return(null);
    };
    ButtonConfigLoader.prototype.removeUnfitButtons = function (context, btns) {
        // #CodeChange#2020-03-22#InstanceConfig - believe this is completely unused; remove in June
        // config: InstanceConfig,
        var cl = this.log.call('removeUnfitButtons');
        var removals = '';
        for (var i = 0; i < btns.length; i++) {
            var btn = btns[i];
            if (btn.command) {
                context.button = btn; // add to context for calls
                var rule = this.toolbar.toolbarV10.rules.find(btn.id || btn.command.name);
                var show = rule === null || rule === void 0 ? void 0 : rule.overrideShow();
                if (show == null) {
                    // make sure params on the rule are also respected when checking the show-condition
                    // I think this should have happened earlier, but as of 2022-06 it's necessary
                    var btnSafe = new ButtonSafe(btn, context);
                    ButtonCommand.mergeAdditionalParams(btnSafe.action(), rule === null || rule === void 0 ? void 0 : rule.params);
                    show = btnSafe.showCondition();
                }
                if (show === false) {
                    removals += "#".concat(i, " \"").concat(btn.command.name, "\"; ");
                    btns.splice(i--, 1);
                }
                cl.add("btn '".concat(btn.command.name, "' show ").concat(show));
            }
        }
        if (removals)
            cl.add("removed buttons: ".concat(removals));
        cl.return(null);
    };
    return ButtonConfigLoader;
}(HasLog));

var btnProperties = [
    'classes',
    'icon',
    'title',
    'dynamicClasses',
    'showCondition',
    'disabled',
];
/**
 * configure missing button properties with various fallback options
 * @param btn
 * @param group
 * @param fullToolbarConfig
 * @param actions
 * @param propName
 */
function fallbackBtnSetting(btn, groupDefaults, toolbarDefaults, actions, propName) {
    var target = btn;
    // skip it property is already set
    if (target[propName])
        return;
    if (groupDefaults && groupDefaults[propName])
        return target[propName] = groupDefaults[propName];
    // if the toolbar has defaults, try use that property
    if (toolbarDefaults && toolbarDefaults[propName])
        return target[propName] = toolbarDefaults[propName];
    // if there is an action, try to use that property name
    if (btn.command && btn.command.name) {
        var a = actions.get(btn.command.name);
        if (a && a.buttonDefaults) {
            var c = a.buttonDefaults;
            if (c[propName])
                return target[propName] = c[propName];
        }
    }
}

;// CONCATENATED MODULE: ./src/toolbar/config-loaders/command-config-loader.ts
var command_config_loader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @internal
 */
var CommandConfigLoader = /** @class */ (function (_super) {
    command_config_loader_extends(CommandConfigLoader, _super);
    function CommandConfigLoader(toolbar) {
        var _this = _super.call(this, 'Tlb.CmdLdr', toolbar.log) || this;
        _this.toolbar = toolbar;
        return _this;
    }
    /**
     * entity support (compatibility for pre 2sxc v9.x)
     * does some clean-up work on a button-definition object
     * because the target item could be specified directly, or in a complex internal object called entity
     * @param actDef
     */
    CommandConfigLoader.prototype.updateToV9 = function (actDef) {
        // doesn't have the pre-V9 properties, so we're fine
        if (!actDef.entity || !actDef.entity._2sxcEditInformation)
            return actDef;
        var editInfo = actDef.entity._2sxcEditInformation;
        // move up sortOrder property and set useModuleList
        if (editInfo.sortOrder !== undefined)
            actDef.useModuleList = true; // has sort-order, so use list
        if (editInfo.sortOrder !== undefined)
            actDef.sortOrder = editInfo.sortOrder;
        // move up entityId and clean-up the old 'entity' property
        if (actDef.entity.EntityId !== undefined)
            actDef.entityId = actDef.entity.EntityId;
        delete actDef.entity;
        return actDef;
    };
    return CommandConfigLoader;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/templates/constants.ts
/**
 * @internal
 */
var TemplateConstants = {
    NameDefault: 'default',
    NameEmpty: 'empty',
    GroupDefault: 'default',
    GroupList: 'list',
    GroupEditAdvanced: 'edit-advanced',
    GroupView: 'view',
    GroupApp: 'app',
    GroupUnknown: 'unknown',
    ButtonSeparator: ',',
};

;// CONCATENATED MODULE: ./src/toolbar/config-loaders/group-config-loader.ts
var group_config_loader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var group_config_loader_assign = (undefined && undefined.__assign) || function () {
    group_config_loader_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return group_config_loader_assign.apply(this, arguments);
};






/**
 * @internal
 */
var ButtonGroupConfigLoader = /** @class */ (function (_super) {
    group_config_loader_extends(ButtonGroupConfigLoader, _super);
    function ButtonGroupConfigLoader(toolbar) {
        var _this = _super.call(this, 'Tlb.GrpCnf', toolbar.log) || this;
        _this.toolbar = toolbar;
        return _this;
    }
    /**
     * this will traverse a groups-tree and expand each group
     * so if groups were just strings like "edit,new" or compact buttons, they will be expanded afterwards
     * @param fullToolbar
     */
    ButtonGroupConfigLoader.prototype.expandButtonGroups = function (fullToolbar) {
        var cl = this.log.call('expandButtonGroups');
        // by now we should have a structure, let's check/fix the buttons
        cl.add("will expand groups - found ".concat(fullToolbar.groups.length, " items"));
        for (var g = 0; g < fullToolbar.groups.length; g++) {
            // expand a verb-list like "edit,new" into objects like [{ action: "edit" }, {action: "new"}]
            var group = fullToolbar.groups[g];
            var groupDefaults = group.defaults;
            var btns = this.expandButtonList(group, fullToolbar.settings);
            var buttonConfigs = [];
            if (Array.isArray(btns)) {
                cl.add("will process ".concat(btns.length, " buttons"));
                for (var b = 0; b < btns.length; b++)
                    buttonConfigs.push(this.convertToButton(btns[b], fullToolbar.params, fullToolbar.defaults, groupDefaults));
            }
            else
                cl.add("no button array found, won't do a.nything");
            // Toolbar API v2 overwrite V1
            group.buttons = buttonConfigs;
        }
        var toolbar = fullToolbar;
        this.dropMoreIfOnlyOneGroup(toolbar);
        return cl.return(toolbar);
    };
    /**
     * Converts the InPageButtonJson to a Button
     * WARNING: Note that this does the same task as convertToButton in the ButtonConfigLoader - but very differently
     *          I'm not sure why though.
     */
    ButtonGroupConfigLoader.prototype.convertToButton = function (btn, sharedParams, sharedDefaults, groupDefaults) {
        var btnCommand = btn.command;
        var identifier = btnCommand.action;
        var name = Button.splitName(identifier).name;
        if (!(Commands.singleton().get(name))) {
            this.log.add("couldn't find action ".concat(name, " - show warning"));
            console.warn('warning: toolbar-button with unknown action-name:', name);
        }
        // first check if we already got params in the object - then we will use those, otherwise the main object
        var realParams = btnCommand.params || InPageCommandJson.noAction(btnCommand);
        // 2dm 2022-07-05 #badContentTypeExtractAndRefill - we seem to extract it, just to put it back on the ButtonCommand
        // const contentType = realParams.contentType;
        // if the button belongs to a content-item, move the specs up to the item into the settings-object
        btnCommand = this.toolbar.command.updateToV9(btnCommand);
        // parameters adapter from v1 to v2
        var params = group_config_loader_assign(group_config_loader_assign({}, realParams), sharedParams);
        // Toolbar API v2
        var command = new ButtonCommand(name, /* contentType, */ params);
        var newButtonConfig = new Button(command, identifier);
        // settings adapter from v1 to v2
        newButtonConfig = group_config_loader_assign(group_config_loader_assign({}, newButtonConfig), InPageButtonJson.toButton(btn));
        // ensure all buttons have either own settings, or the fallback
        this.toolbar.button.addDefaultBtnSettings(newButtonConfig, groupDefaults, sharedDefaults, Commands.singleton());
        return newButtonConfig;
    };
    /**
     * take a list of buttons (objects OR strings)
     * and convert to proper array of buttons with actions
     * on the in is a object with buttons, which are either:
     * - a string like "edit" or multi-value "layout,more"
     * - an array of such strings incl. optional complex objects which are
     */
    ButtonGroupConfigLoader.prototype.expandButtonList = function (root, settings) {
        var _this = this;
        var wrapLog = this.log.call('expandButtonList'); // new Log('Tlb.ExpBts', this.log, 'start');
        wrapLog.add('initial', root);
        var buttonsWip = root.buttons;
        var newButtons = [];
        // convert compact buttons (with multi-verb action objects) into own button-objects
        // important because an older syntax allowed {action: "new,edit", entityId: 17}
        if (Array.isArray(buttonsWip)) {
            wrapLog.add("detected array of btns (".concat(buttonsWip.length, "), will ensure it's an object"));
            for (var b = 0; b < buttonsWip.length; b++) {
                var btn = buttonsWip[b];
                var actionNames = btn.action;
                wrapLog.add("will process actions: '".concat(actionNames, "' for "), btn);
                if (typeof actionNames === 'string' && actionNames.indexOf(',') > -1) {
                    wrapLog.add("actionNames has mult values: '".concat(actionNames, "'"));
                    this.expandButtonAndAddToList(newButtons, btn, actionNames);
                }
                else {
                    wrapLog.add('actionNames has 1 value', btn);
                    newButtons.push(btn);
                }
            }
        }
        else if (typeof buttonsWip === 'string') {
            wrapLog.add("detected that it is a string \"".concat(buttonsWip, "\", will split by \",\" and ..."));
            this.expandButtonAndAddToList(newButtons, {}, buttonsWip);
        }
        else {
            wrapLog.add('no special case detected, will use the buttons-object as is');
            newButtons = buttonsWip;
        }
        wrapLog.add("after check, found ".concat(newButtons.length, " buttons"), newButtons);
        // optionally add a more-button in each group
        this.addMoreButton(settings, newButtons);
        var result = newButtons.map(function (x) { return _this.toolbar.button.normalize(x); }); // ensure the internal def is also an array now
        return wrapLog.return(result, 'done');
    };
    ButtonGroupConfigLoader.prototype.expandButtonAndAddToList = function (list, btn, names) {
        var cl = this.log.call('expandButtonAndAddToList', "..., ..., '".concat(names, "'"), "button def \"".concat(btn, " is string of mult names, will expand into array with action-properties\""));
        var actions = names.length ? names.split(TemplateConstants.ButtonSeparator) : [];
        var params = group_config_loader_assign({}, btn);
        delete params.action;
        for (var a = 0; a < actions.length; a++) {
            var commandPart = this.toolbar.button.btnConfigStructure(actions[a], params);
            cl.data('commandPart', commandPart);
            list.push(commandPart); // {...btn, ...commandPart });
        }
        cl.return(list);
    };
    /** Add the "more" button at the end or beginning */
    ButtonGroupConfigLoader.prototype.addMoreButton = function (settings, list) {
        var cl = this.log.call('addMoreButtons');
        var addMore = ToolbarSettings.bestAddMorePos(settings);
        if (addMore && addMore !== TLB_MORE_NEVER) {
            this.log.add("will add a more \"...\" button to ".concat(addMore));
            var moreButton = this.toolbar.button.btnConfigStructure("more" /* CommandNames.more */, {});
            if (addMore === TLB_MORE_END)
                list.push(moreButton);
            else
                list.unshift(moreButton);
        }
        else
            this.log.add('will not add more "..." button');
        cl.return(list);
    };
    /**
     * If there is only one group, then remove the More button.
     * Note that this has to happen almost at the end, because groups will be removed if empty
     */
    ButtonGroupConfigLoader.prototype.dropMoreIfOnlyOneGroup = function (toolbar) {
        var cl = this.log.call('dropMoreIfOnlyOneGroup');
        if (toolbar.groups.length !== 1)
            return cl.done('not just 1 group');
        cl.add('exactly one group found, will remove more');
        var buttons = toolbar.groups[0].buttons;
        var index = buttons.findIndex(function (b) { var _a; return ((_a = b.command) === null || _a === void 0 ? void 0 : _a.name) === "more" /* CommandNames.more */; });
        if (index === -1)
            return cl.done("no 'more' button found");
        buttons.splice(index, 1);
        cl.done('more removed');
    };
    return ButtonGroupConfigLoader;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/templates/template-empty.ts

/**
 * @internal
 */
// the default / initial buttons in a standard toolbar
var ToolbarTemplateEmpty = {
    name: TemplateConstants.NameEmpty,
    groups: [
        {
            name: TemplateConstants.GroupDefault,
            buttons: '',
        },
    ],
    defaults: {},
    params: {},
    settings: {},
    _isToolbarTemplate: true,
};

;// CONCATENATED MODULE: ./src/toolbar/templates/template-default.ts

/**
 * @internal
 */
// the default / initial buttons in a standard toolbar
var ToolbarTemplateDefault = {
    name: TemplateConstants.NameDefault,
    groups: [
        {
            name: TemplateConstants.GroupDefault,
            buttons: ["edit" /* CN.edit */, "new" /* CN.new */, "metadata" /* CN.metadata */, "publish" /* CN.publish */, "layout" /* CN.layout */].join(','),
        }, {
            name: TemplateConstants.GroupList,
            buttons: ["add" /* CN.add */, "add-existing" /* CN.addExisting */, "replace" /* CN.replace */, "remove" /* CN.remove */, "moveup" /* CN.moveUp */, "movedown" /* CN.moveDown */, "list" /* CN.list */].join(','),
        }, {
            name: TemplateConstants.GroupEditAdvanced,
            buttons: ["delete" /* CN.delete */].join(','),
        }, {
            name: TemplateConstants.GroupView,
            buttons: ["template" /* CN.template */, "view" /* CN.view */, "data" /* CN.data */, "query" /* CN.query */, "fields" /* CN.fields */].join(','),
            defaults: {
                classes: 'group-pro',
            },
        }, {
            name: TemplateConstants.GroupApp,
            buttons: ["app" /* CN.app */, "app-settings" /* CN.appSettings */, "app-resources" /* CN.appResources */, "system" /* CN.system */, "insights" /* CN.insights */].join(','),
            defaults: {
                classes: 'group-pro',
            },
        },
    ],
    defaults: {},
    params: {},
    settings: {},
    _isToolbarTemplate: true,
};

;// CONCATENATED MODULE: ./src/toolbar/templates/template-sublist.ts

/**
 * @internal
 */
// the default / initial buttons in a standard toolbar
var ToolbarTemplateSublist = {
    name: 'sublist',
    groups: [
        {
            name: TemplateConstants.GroupDefault,
            buttons: 'edit,new,publish',
            defaults: {
                classes: 'group-inlist',
            },
        }, {
            name: TemplateConstants.GroupList,
            buttons: 'add-existing,replace,remove,moveup,movedown,instance-list',
            defaults: {
                classes: 'group-inlist',
            },
        }, {
            name: TemplateConstants.GroupEditAdvanced,
            buttons: 'delete',
            defaults: {
                classes: 'group-inlist',
            },
        },
    ],
    defaults: {},
    params: {},
    settings: {},
    _isToolbarTemplate: true,
};

;// CONCATENATED MODULE: ./src/toolbar/templates/toolbar-template-manager.ts
var toolbar_template_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * The template manager provides toolbar templates to the entire system.
 * It basically keeps a list of predefined templates, and returns the ones needed
 * @internal
 */
var ToolbarTemplateManager = /** @class */ (function (_super) {
    toolbar_template_manager_extends(ToolbarTemplateManager, _super);
    function ToolbarTemplateManager() {
        var _this = _super.call(this, 'Tlb.TmpMan', null, 'build') || this;
        _this.configTemplateList = [];
        /** hash - table of templates, to be used a list()['template - name'] */
        _this.list = {};
        insights_Insights.add('system', 'toolbar-template-manager', _this.log);
        _this.add(ToolbarTemplateEmpty);
        _this.add(ToolbarTemplateDefault);
        _this.add(ToolbarTemplateSublist);
        return _this;
    }
    /** Singleton */
    ToolbarTemplateManager.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new ToolbarTemplateManager());
    };
    /**
     * Deep copy toolbar template, so it can be modified without changing the next use
     */
    ToolbarTemplateManager.prototype.copy = function (name) {
        return Obj.DeepClone(this.findOrShowError(name));
    };
    ToolbarTemplateManager.prototype.findOrShowError = function (name) {
        var found = this.list[name];
        if (found)
            return found;
        throw "try to find toolbar template '".concat(name, "' but not found");
    };
    /**
     * adds a template to the list, if it doesn't exist
     */
    ToolbarTemplateManager.prototype.add = function (template) {
        this.list[template.name] = template;
    };
    return ToolbarTemplateManager;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/templates/toolbar-template.ts
/**
 * This describes a template configuration of a toolbar
 * It's meant to provide type-save templates for what buttons are used where
 * @internal
 */
var ToolbarTemplate = /** @class */ (function () {
    function ToolbarTemplate() {
        this.groups = [];
        this.defaults = {};
        this.params = {};
        this.settings = {};
    }
    ToolbarTemplate.is = function (thing) {
        return thing._isToolbarTemplate;
    };
    ToolbarTemplate.hasGroups = function (thing) {
        return Array.isArray(thing.groups);
    };
    return ToolbarTemplate;
}());


;// CONCATENATED MODULE: ./src/toolbar/templates/toolbar-template-group.ts

/**
 * This describes a button group in a toolbar template.
 * It should only be used for that
 * @internal
 */
var ToolbarTemplateGroup = /** @class */ (function () {
    function ToolbarTemplateGroup() {
        this.name = TemplateConstants.GroupUnknown;
        this.buttons = '';
        this.defaults = {};
    }
    ToolbarTemplateGroup.is = function (thing) {
        return thing.buttons !== undefined;
    };
    return ToolbarTemplateGroup;
}());


;// CONCATENATED MODULE: ./src/toolbar/templates/template-editor.ts
var template_editor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * This object is used to change the structure of a toolbar template.
 * It's only purpose is to assist in the new V10 format for quickly making toolbars.
 * @internal
 */
var TemplateEditor = /** @class */ (function (_super) {
    template_editor_extends(TemplateEditor, _super);
    function TemplateEditor(toolbar) {
        var _this = _super.call(this, 'Tlb.TplEdt', toolbar.log) || this;
        _this.toolbar = toolbar;
        _this.ensureGroups = function (template) { if (!template.groups)
            template.groups = []; };
        _this.findGroup = function (template, name) {
            return template.groups.find(function (t) { return t.name === name; });
        };
        return _this;
    }
    TemplateEditor.prototype.addButton = function (template, groupName, id, name, pos) {
        var _a, _b;
        // fromStart
        var fromStart = !(Object.is(pos, -0) || pos < 0);
        pos = Math.abs(pos);
        // console.log('addbutton - pos', `${fromStart ? '+' : '-'}${pos}`);
        var cl = this.log.call('addButton', "..., ".concat(groupName, ", ").concat(id, ", ").concat(name, ", ").concat(fromStart ? '+' : '-').concat(pos, ", ").concat(fromStart));
        if (!template)
            return cl.done('no template');
        var group = this.findGroupOrDefault(template, groupName);
        if (!group)
            group = this.addGroup(template, groupName, 1000); // create group at end
        var buttons = (_b = (_a = group.buttons) === null || _a === void 0 ? void 0 : _a.split(TemplateConstants.ButtonSeparator)) !== null && _b !== void 0 ? _b : [];
        var buttonId = id === name ? name : "".concat(id, "=").concat(name);
        var posStartEnd = this.correctPosStartEnd(buttons, pos, fromStart);
        var posInsert = fromStart ? this.findInsertPosition(group, posStartEnd) : posStartEnd;
        cl.add("pos: ".concat(pos, ", startEnd: ").concat(posStartEnd, ", insert:").concat(posInsert));
        buttons.splice(posInsert, 0, buttonId);
        group.buttons = buttons
            .filter(function (b) { return b.length; }) // drop empty items
            .join(TemplateConstants.ButtonSeparator);
        cl.done();
    };
    TemplateEditor.prototype.findInsertPosition = function (group, pos) {
        group._insertCursor = group._insertCursor || 0;
        if (pos === 0)
            pos = group._insertCursor++;
        return pos;
    };
    TemplateEditor.prototype.correctPosStartEnd = function (target, pos, fromStart) {
        if (fromStart)
            return pos;
        pos = target.length - pos;
        return pos >= 0 ? pos : target.length;
    };
    TemplateEditor.prototype.addGroup = function (template, groupName, pos) {
        var fromStart = !(Object.is(pos, -0) || pos < 0);
        pos = Math.abs(pos);
        var cl = this.log.call('addGroup', "..., ".concat(groupName, ", ").concat(fromStart ? '+' : '-').concat(pos));
        this.ensureGroups(template);
        var alreadyExists = this.findGroup(template, groupName);
        if (alreadyExists)
            return cl.return(alreadyExists, 'already exists');
        var newGroup = new ToolbarTemplateGroup();
        newGroup.name = groupName;
        var posStartEnd = this.correctPosStartEnd(template.groups, pos, fromStart);
        var posInsert = fromStart ? this.findInsertPosition(template, posStartEnd) : posStartEnd;
        template.groups.splice(posInsert, 0, newGroup);
        return cl.return(newGroup, 'created');
    };
    TemplateEditor.prototype.removeGroup = function (template, groupName) {
        var group = this.findGroup(template, groupName);
        if (!group)
            return;
        var index = template.groups.indexOf(group);
        if (index < 0)
            return;
        template.groups.splice(index, 1);
    };
    TemplateEditor.prototype.findGroupOrDefault = function (template, name) {
        var cl = this.log.call('findGroup', name);
        this.ensureGroups(template);
        if (template.groups.length === 0)
            return cl.return(null, 'no groups');
        var found = this.findGroup(template, name);
        if (found)
            return cl.return(found, 'found');
        return cl.return(template.groups[0], 'not found, return first)');
    };
    return TemplateEditor;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/templates/index.ts










;// CONCATENATED MODULE: ./src/toolbar/config-loaders/toolbar-config-loader-v09.ts
var toolbar_config_loader_v09_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var toolbar_config_loader_v09_assign = (undefined && undefined.__assign) || function () {
    toolbar_config_loader_v09_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return toolbar_config_loader_v09_assign.apply(this, arguments);
};




/**
 * @internal
 */
var ToolbarConfigLoaderV09 = /** @class */ (function (_super) {
    toolbar_config_loader_v09_extends(ToolbarConfigLoaderV09, _super);
    function ToolbarConfigLoaderV09(toolbar) {
        var _this = _super.call(this, 'Tlb.TlbV09', toolbar.log) || this;
        _this.toolbar = toolbar;
        return _this;
    }
    ToolbarConfigLoaderV09.prototype.loadV9 = function (context, config) {
        var cl = this.log.call('loadV9');
        var toolbarSettings = config.settings;
        // Default to empty toolbar settings if we don't have a toolbar or settings
        // important: the checks look a bit strange, but there are cases where {} settings are handed in
        // and we can't count the keys because that would result in other checks
        if (Object.keys(config.toolbar).length > 0 && toolbarSettings === {}) {
            cl.add('no data or settings, will use default settings for empty');
            toolbarSettings = ToolbarSettings.getForEmpty();
        }
        // if it has an action or is an array, keep that. Otherwise get standard buttons
        var draftToolbar = this.getTemplateIfNoButtonsSpecified(config.toolbar);
        cl.data('after template check', draftToolbar);
        var toolbar = this.buildFullDefinition(context, draftToolbar, toolbarSettings);
        return cl.return(toolbar, 'ok');
    };
    /**
     * If the raw data has specs for what buttons, use that
     * Otherwise load the button list from the template
     */
    ToolbarConfigLoaderV09.prototype.getTemplateIfNoButtonsSpecified = function (raw) {
        var cl = this.log.call('getTemplateIfNoButtonsSpecified');
        cl.add('initial', raw);
        if (InPageCommandJson.hasActions(raw))
            return cl.return(raw, 'has actions, keep raw');
        if (ToolbarTemplate.hasGroups(raw))
            return cl.return(raw, 'has groups, keep raw');
        if (ToolbarTemplateGroup.is(raw))
            return cl.return(raw, 'is group, keep raw');
        if (Array.isArray(raw))
            return cl.return(raw, 'is array, keep raw');
        // final: nothing defined, use template
        cl.add('no toolbar structure specified, will use standard toolbar template');
        // If it's a sub-list toolbar, use the special template for it
        var defToolbarname = raw.fields ? ToolbarTemplateSublist.name : ToolbarTemplateDefault.name;
        var template = this.toolbar.templates.copy(defToolbarname);
        template.params = (Array.isArray(raw) && raw[0]) || raw; // attach parameters
        return cl.return(template, 'use template');
    };
    /**
     * take various common input format and convert it to a full toolbar-structure definition
     * can handle the following input formats (the param unstructuredConfig):
     * complete tree (detected by "groups): \{ groups: [ \{\}, \{\}], name: ..., defaults: \{...\} \}
     * group of buttons (detected by "buttons): \{ buttons: "..." | [], name: ..., ... \}
     * list of buttons (detected by IsArray with action): [ \{ action: "..." | []\}, \{ action: ""|[]\} ]
     * button (detected by "command"): \{ command: ""|[], icon: "..", ... \}
     * just a command (detected by "action"): \{ entityId: 17, action: "edit" \}
     * array of commands: [\{entityId: 17, action: "edit"\}, \{contentType: "blog", action: "new"\}]
     */
    ToolbarConfigLoaderV09.prototype.buildFullDefinition = function (toolbarContext, unstructuredConfig, 
    // #CodeChange#2020-03-22#InstanceConfig - believe this is completely unused; remove in June
    // instanceConfig: InstanceConfig,
    toolbarSettings) {
        var cl = this.log.call('buildFullDefinition');
        var configWip = this.ensureDefinitionTree(unstructuredConfig, toolbarSettings); // as unknown as Toolbar;
        if (ToolbarTemplate.is(unstructuredConfig) && unstructuredConfig.debug)
            console.log('toolbar: detailed debug on; start build full Def');
        var result = this.toolbar.buildTreeAndModifyAccordingToRules(toolbarContext, configWip);
        return cl.return(result);
    };
    //#region build initial toolbar object
    /**
     * this will take an input which could already be a tree, but it could also be a
     * button-definition, or just a string, and make sure that afterwards it's a tree with groups
     * the groups could still be in compact form, or already expanded, depending on the input
     * output is object with:
     * - groups containing buttons[], but buttons could still be very flat
     * - defaults, already officially formatted
     * - params, officially formatted
     */
    ToolbarConfigLoaderV09.prototype.ensureDefinitionTree = function (unstructuredConfig, toolbarSettings) {
        var wrapLog = this.log.call('ensureDefinitionTree');
        // original is null/undefined, just return empty set
        if (!unstructuredConfig)
            throw ("preparing toolbar, with nothing to work on: ".concat(unstructuredConfig));
        var newToolbar = new Toolbar();
        newToolbar.groups = this.findGroups(unstructuredConfig);
        var probablyTemplate = unstructuredConfig;
        newToolbar.params = probablyTemplate.params || {}; // these are the default command parameters
        newToolbar.settings = toolbar_config_loader_v09_assign(toolbar_config_loader_v09_assign(toolbar_config_loader_v09_assign({}, ToolbarSettings.getDefaults()), probablyTemplate.settings), ToolbarSettings.dropEmptyProperties(toolbarSettings));
        newToolbar.debug = probablyTemplate.debug || false; // show more debug info
        newToolbar.defaults = probablyTemplate.defaults || {}; // the button defaults like icon, etc.
        return wrapLog.return(newToolbar);
    };
    ToolbarConfigLoaderV09.prototype.findGroups = function (unstructuredConfig) {
        var cl = this.log.call('findGroups');
        cl.data('initial', unstructuredConfig);
        // case 0: nothing in the config
        if (!unstructuredConfig || (Object.getOwnPropertyNames(unstructuredConfig).length === 0))
            return cl.return([], 'case 0: empty object, use []');
        var arrGroups = [];
        // ensure that the groups are all correct
        cl.add('will detect what initial structure was given');
        // Case 2: Array
        if (Array.isArray(unstructuredConfig)) {
            cl.add('Case 2: is array');
            if (unstructuredConfig.length === 0)
                return cl.return([], '2a: empty array');
            if (Button.isArray(unstructuredConfig))
                return cl.return([{ buttons: unstructuredConfig }], '2b: array of groups');
            if (InPageButtonJson.is(unstructuredConfig[0]))
                return cl.return([{ buttons: unstructuredConfig }], '2b: is list of buttons, return 1 group');
            console.warn('error detecting groups in this toolbar');
            return cl.return([], "2x: error, it's array but can't detect type, use []");
        }
        // Case 3: not an array
        cl.add('Case 3: not array');
        if (InPageButtonJson.is(unstructuredConfig)) {
            return cl.return([{ buttons: [unstructuredConfig] }], 'Case 3a: not array, but has action/buttons properties, will wrap config into array');
        }
        cl.add('Case 3: not array and no "action", will return it or blank');
        // we either have groups already, or we'll return blank
        if (ToolbarTemplate.hasGroups(unstructuredConfig))
            return cl.return(unstructuredConfig.groups, '4: found groups');
        cl.add('can\'t detect what this is - show warning');
        console.warn("toolbar tried to build toolbar but couldn't detect type of this:", arrGroups);
        return cl.return([], 'warning');
    };
    return ToolbarConfigLoaderV09;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/rules/rule-constants.ts
/**
 * @internal
 */
var RuleConstants = {
    Keys: {
        None: 'none',
    },
};

;// CONCATENATED MODULE: ./src/toolbar/rules/rule-operators.ts
/**
 * @internal
 */
var Operations;
(function (Operations) {
    Operations["add"] = "+";
    Operations["addAuto"] = "\u00B1";
    Operations["remove"] = "-";
    Operations["system"] = "$";
    Operations["modify"] = "%";
    // comment = '/',
})(Operations || (Operations = {}));

;// CONCATENATED MODULE: ./src/toolbar/rules/build-steps.ts
/**
 * @internal
 */
var BuildSteps;
(function (BuildSteps) {
    BuildSteps["toolbar"] = "toolbar";
    BuildSteps["group"] = "group";
    BuildSteps["button"] = "button";
    BuildSteps["params"] = "params";
    BuildSteps["settings"] = "settings";
})(BuildSteps || (BuildSteps = {}));

;// CONCATENATED MODULE: ./src/toolbar/rules/rule-params-helper.ts

var prefillPrefix = 'prefill:';
var filterPrefix = 'filter:';
var contextPrefix = 'context:';
/**
 * @internal
 */
var RuleParamsHelper = /** @class */ (function () {
    function RuleParamsHelper() {
    }
    RuleParamsHelper.processParams = function (params, log) {
        var cl = log.call('processParams');
        var prefill = RuleParamsHelper.extractSubKeys(params, prefillPrefix, log);
        if (prefill)
            params.prefill = prefill;
        var filters = RuleParamsHelper.extractSubKeys(params, filterPrefix, log);
        if (filters)
            params.filters = filters;
        var context = RuleParamsHelper.extractSubKeys(params, contextPrefix, log);
        // catch a very common mistake in metadata
        if (params.metadata) {
            delete params.metadata;
            cl.add("params had additional metadata - invalid, will remove. Use 'for' instead", null, LogEntryOptions.error);
        }
        // process metadata
        if (params.for)
            params.metadata = RuleParamsHelper.processMetadata(params, log);
        return cl.return({ params: params, context: context });
    };
    RuleParamsHelper.processMetadata = function (params, log) {
        var cl = log.call('processMetadata');
        // get the for-target and if exists, delete from params
        var mdFor = params.for;
        if (!mdFor)
            return cl.return(undefined, 'no metadata');
        delete params.for;
        // just one part, use it as key
        if (mdFor.indexOf(',') === -1)
            return cl.return({ key: mdFor }, 'only has key');
        var parts = mdFor.split(',').map(function (p) { return p.trim(); });
        if (parts.length !== 3)
            return cl.return(undefined, "error: metadata-for parts count expected 3: ".concat(parts.length), LogEntryOptions.error);
        // part 1 must be a number
        var targetType = +parts[0];
        if (isNaN(targetType))
            return cl.return(undefined, "error: first key part is not number - got ".concat(targetType), LogEntryOptions.error);
        // part 2 must be a string with 'string', 'guid' or 'number'
        var keyType = parts[1];
        if (keyType !== 'string' && keyType !== 'guid' && keyType !== 'number')
            return cl.return(undefined, "error: key is not known type, should be string, guid or number, but got ".concat(keyType), LogEntryOptions.error);
        // part 3 is the key
        var key = parts[2];
        if (key === null || key === undefined || key === '')
            return cl.return(undefined, "error: key strange value: '".concat(key, "'"), LogEntryOptions.error);
        // todo: warn if no metadata or id!
        if (!params.contentType || params.entityId == null)
            return cl.return(undefined, 'error: contentType and entityId missing', LogEntryOptions.error);
        return cl.return({
            key: key,
            targetType: targetType,
            keyType: keyType,
        });
    };
    /** Do special processing on all prefill:Field=Value rules */
    RuleParamsHelper.extractSubKeys = function (params, prefix, log) {
        var cl = log.call('processSubMultiKeys');
        // only load special prefills if we don't already have a prefill
        if (!params)
            return cl.return(undefined, 'no params');
        var keys = Object.keys(params).filter(function (k) { return k.indexOf(prefix) === 0; });
        if (!keys || keys.length === 0)
            return cl.return(undefined, "no speciall '".concat(prefix, "' keys"));
        var prefixLen = prefix.length;
        var list = {};
        keys.forEach(function (k) {
            var value = params[k];
            // 2020-04-02 prefill is a bit flaky - this should fix the common issues
            // fix boolean true must be "true"
            if (value === true || value === false)
                value = value.toString();
            // filter:[] is a special case - it's an array of IDs
            else if (prefix === filterPrefix)
                value = RuleParamsHelper.filterValues(value);
            // prefill: try to detect list of guids
            else if (prefix === prefillPrefix)
                value = RuleParamsHelper.prefillValues(value);
            list[k.substring(prefixLen)] = value;
            delete params[k];
        });
        return cl.return(list, 'got list of multi-keys');
    };
    RuleParamsHelper.filterValues = function (value) {
        if (typeof value === 'string' && value.length > 0 && value[0] === '[' && value[value.length - 1] === ']') {
            try {
                var array = JSON.parse(value);
                return array;
            }
            catch (_a) {
                console.warn("filter:[] value is not a valid JSON array: ".concat(value));
            }
        }
        return value;
    };
    /**
     * Process Prefill values - basically check if it's an array of GUIDs and convert to that
     * @param value
     * @returns
     */
    RuleParamsHelper.prefillValues = function (value) {
        // must be string
        if (!value || typeof value !== 'string')
            return value;
        // must have a comma to become an array
        if (value.indexOf(',') === -1)
            return value;
        // shouldn't have any quotes
        if (value.indexOf('"') >= 0 || value.indexOf("'") >= 0)
            return value;
        var probablyArray = value.split(',').map(function (g) { return g.trim(); });
        // guid check regex from https://stackoverflow.com/questions/7905929/how-to-test-valid-uuid-guid
        var guidCount = probablyArray
            .filter(function (g) { return g.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i) !== null; });
        // .filter((m) => m === true);
        if (guidCount && guidCount.length === probablyArray.length)
            return probablyArray;
        return value;
    };
    return RuleParamsHelper;
}());


;// CONCATENATED MODULE: ./src/toolbar/rules/rule.ts
var rule_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * Contains a rule how to add/modify a toolbar.
 * @internal
 */
var BuildRule = /** @class */ (function (_super) {
    rule_extends(BuildRule, _super);
    //#endregion
    function BuildRule(ruleString, parentLog) {
        var _this = _super.call(this, 'Tlb.BdRule', parentLog) || this;
        _this.ruleString = ruleString;
        /** Group name - when adding more buttons */
        _this.group = TemplateConstants.NameDefault;
        /**
         * position where something is added - the group or the button
         * Note that JS preserves -0
         */
        _this.pos = 0;
        //#endregion
        //#region command parts
        _this.params = {};
        /**
         * Button Rules - determines what a button should do / not do
         * Note: can also be Partial<ToolbarSettings>
         */
        _this.ui = {};
        /** ATM unused url-part after the hash - will probably be needed in future */
        // private hash: Dictionary<string> = {};
        //#endregion
        //#region New #CustomContext
        _this.context = {};
        if (!ruleString) {
            _this.log.add('rule is empty');
            return _this;
        }
        _this.load();
        return _this;
    }
    /** Tells if this rule will override the show settings  */
    BuildRule.prototype.overrideShow = function () {
        var _a;
        if (this.operator === Operations.remove)
            return false;
        if (this.operator === Operations.add)
            return true;
        if (this.operator === Operations.addAuto)
            return undefined;
        if (this.operator === Operations.modify)
            return (_a = this.ui) === null || _a === void 0 ? void 0 : _a.show; // can be true/false/undefined
        return undefined;
    };
    BuildRule.prototype.load = function () {
        var cl = this.log.call('load', this.ruleString);
        var parts = splitUrlSections(this.ruleString);
        if (!parts.key)
            return cl.done("no key, won't load");
        this.loadHeader(parts.key);
        if (parts.params) {
            var processed = this.loadParamsAndPrefill(parts.params);
            this.params = processed.params;
            this.context = processed.context;
        }
        // ATM seems unused...? hash is already processed before in loadHeader
        // if (parts.ui) this.hash = this.loadDictionary(parts.ui);
        return cl.done();
    };
    BuildRule.prototype.loadHeader = function (rule) {
        var _a, _b;
        var cl = this.log.call('loadHeader', rule);
        var parts = this.splitParamsArray(rule);
        var key = ((_a = parts === null || parts === void 0 ? void 0 : parts[0]) === null || _a === void 0 ? void 0 : _a[0]) || RuleConstants.Keys.None;
        // Pick up the operation from header, but if it's not a known operator, auto-detect
        var operator = key[0];
        var knownOperatorFound = Object.values(Operations).includes(operator);
        if (!knownOperatorFound)
            operator = (key === BuildSteps.params || key === BuildSteps.settings || key === BuildSteps.toolbar)
                ? Operations.system
                : Operations.add;
        this.operator = operator;
        cl.add("name part '".concat(key, "', firstChar '").concat(operator, "'"));
        // remember the primary keyword because this determines what we're doing
        // but truncate the first char if it had an operator
        key = knownOperatorFound ? key.substring(1) : key;
        var knowStepFound = Object.values(BuildSteps).includes(key);
        this.step = knowStepFound ? key : BuildSteps.button;
        // for system and %-change operations the id should be the name of the standard button
        // ...but if it's an add-operation, we must keep the IDs appart because various
        // properties are set at a much later time
        this.id = (this.operator === Operations.add || this.operator === Operations.addAuto)
            ? 'rndId' + Math.floor(Math.random() * 99999)
            : key;
        // command name defaults to name, can be reset by load-headers
        // assumes key is something like "group=myGroup" or just "edit"
        this.name = ((_b = parts === null || parts === void 0 ? void 0 : parts[0]) === null || _b === void 0 ? void 0 : _b[1]) || key;
        if (parts.length > 1)
            this.leadHeaderAndUi(key, parts.slice(1));
        return cl.done();
    };
    /**
     * Load the header
     * @param forKey the key being loaded, to handle special case settings/toolbar
     * @param rest the parameters to process
     */
    BuildRule.prototype.leadHeaderAndUi = function (forKey, rest) {
        var cl = this.log.call('loadHeaderParts');
        if (!rest.length)
            return cl.done('nothing to load');
        var parts = this.dicToArray(rest);
        // #1 pick up id & name
        if (parts.id)
            this.id = parts.id;
        if (parts.name)
            this.name = parts.name;
        // #2 pick up group
        if (typeof parts.group === 'string') {
            this.group = parts.group;
            delete parts.group;
        }
        // #3 position can be number or -number to indicate from other side
        // Note that JS preserves -0, which is kind of unique
        if (parts.pos != null)
            this.pos = Number(parts.pos);
        // #4 icon is automatically kept
        // #5 show override of buttons (on buttons, must convert to bool)
        if (forKey !== BuildSteps.settings && forKey !== BuildSteps.toolbar)
            if (typeof parts.show === 'string')
                parts.show = parts.show === 'true';
        this.ui = parts;
        return cl.return(this.ui, 'button rules');
    };
    BuildRule.prototype.loadParamsAndPrefill = function (rule) {
        var cl = this.log.call('loadParams', rule);
        var parms = this.splitParamsDic(rule);
        cl.data('params', parms);
        var split = RuleParamsHelper.processParams(parms, this.log);
        return cl.return(split);
    };
    // private loadDictionary(original: string): Dictionary<string> {
    //     const cl = this.log.call('loadHash', original);
    //     const parts = this.splitParamsDic(original);
    //     cl.data('button', parts);
    //     return cl.return(parts);
    // }
    //#region string manipulation helpers
    BuildRule.prototype.dicToArray = function (original) {
        return original.reduce(function (map, obj) {
            map[obj[0]] = obj[1];
            return map;
        }, {});
    };
    BuildRule.prototype.splitParamsDic = function (original) {
        return this.dicToArray(this.splitParamsArray(original));
    };
    BuildRule.prototype.splitParamsArray = function (original) {
        if (!original)
            return [];
        var split1 = original.split('&');
        var split2 = split1.map(function (p) {
            var i = p.indexOf('=');
            if (i < 0)
                i = p.length;
            var keyValues = [p.slice(0, i), p.slice(i + 1)];
            // 2022-08-15 2dm before - would have lost cases where '=' occurs in the value a few times
            // const keyValues = p.split('=');
            var key = keyValues[0];
            var val = keyValues[1];
            // disabled, don't see a use case for this
            // check if the value had '=' - then re-join
            // if (keyValues.length > 1)
            //     val = keyValues.slice(1).join('=');
            // fix url encoding
            if ((val === null || val === void 0 ? void 0 : val.indexOf('%')) > -1)
                val = decodeURIComponent(val);
            // fix C# typed true/false or string representations
            if (val === 'True' || val === 'true')
                return [key, true];
            if (val === 'False' || val === 'false')
                return [key, false];
            // cast numbers to proper number objects
            if (!isNaN(+val))
                return [key, Number(val)];
            // revert base64 encoding
            if (typeof (val) === 'string' && val.startsWith('base64:')) {
                var afterPrefix = val.split('base64:')[1];
                return [key, atob(afterPrefix)];
            }
            if (typeof (val) === 'string' && val.startsWith('json64:')) {
                var afterPrefix = val.split('json64:')[1];
                return [key, JSON.parse(atob(afterPrefix))];
            }
            return [key, val];
        });
        return split2;
    };
    return BuildRule;
}(HasLog));

function splitUrlSections(str) {
    // dev link: https://regex101.com/r/vK4rV7/519
    // inpsired by https://stackoverflow.com/questions/27745/getting-parts-of-a-url-regex
    var regex = /^([^\/?#]*)?([^?#]*)(\?([^#]*))?(#(.*))?/i;
    // const str = `+edit&something=other&els=ok?aoeuaoeu=5&aoeuaou=aoeu#but=thi&aouoaeu`;
    var m = regex.exec(str);
    if (m && m !== null)
        return { key: m[1], params: m[4], button: m[6] };
    return undefined;
}
// #CustomContext
// /**
//  * Will take a UI definition and extract the context if available
//  * @param ui original value before split
//  * @returns 
//  */
// function splitUiParts(ui: string): [string, string] {
//   if (!ui) return [null, null];
//   // If it starts with ## then the original value only had the context
//   // In this case the first # of the three ### was already removed
//   if (ui.startsWith('##')) return [null, ui.substring(2)];
//   const parts = ui.split('###');
//   return [parts[0], parts.length > 1 ? parts[1] : null];
// }

;// CONCATENATED MODULE: ./src/toolbar/rules/rule-manager.ts
var rule_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var throwOnError = true;
/**
 * @internal
 */
var RuleManager = /** @class */ (function (_super) {
    rule_manager_extends(RuleManager, _super);
    /** Basic constructor, must be called from a ToolbarConfigLoader */
    function RuleManager(parent) {
        var _this = _super.call(this, 'Tlb.RlMngr', parent.log, 'constructor') || this;
        /** List of rules which were picked up and will be applied */
        _this.rules = [];
        _this.ruleManagerId = Math.floor(Math.random() * 99999);
        // before v14.07.05 it was this:
        // remove Q4 2022 if everything is ok
        // getSettingsOld = () => this.getSystemRule(BuildSteps.settings) || this.getToolbar();
        /**
         * The params for the command - if not found, will use the toolbar params.
         * But it's either or, mixing won't work by design ATM.
         */
        _this.getParams = function () { return _this.getSystemRule(BuildSteps.params) || _this.getToolbar(); };
        _this.getToolbar = function () { return _this.getSystemRule(BuildSteps.toolbar); };
        _this.getAdd = function () { return _this.filter(function (br) { return br.operator === Operations.add || br.operator === Operations.addAuto; }); };
        _this.getRemoveGroups = function () { return _this.filter(function (br) { return br.operator === Operations.remove && br.step === BuildSteps.group; }); };
        _this.log.add('tempId:' + _this.ruleManagerId);
        return _this;
    }
    /** Load/initialize the rules which were found */
    RuleManager.prototype.load = function (rawList) {
        var _this = this;
        var cl = this.log.call('load', "".concat(function () { return rawList.length; }));
        if (!Array.isArray(rawList))
            return cl.return([], 'raw is empty');
        rawList.forEach(function (raw) {
            if (typeof raw === 'string') {
                try {
                    _this.rules.push(new BuildRule(raw, _this.log));
                }
                catch (e) {
                    if (throwOnError)
                        throw e;
                    cl.add("error adding string-rule '".concat(raw, "'"), e);
                }
            }
            else {
                console.error('tried to parse a toolbar rule and expected a string, but got something else');
            }
        });
        return cl.return(this.rules, 'final rules');
    };
    /** Find a single rule matching an ID */
    RuleManager.prototype.find = function (id) { return this.rules.find(function (r) { return r.id === id; }); };
    /** find all rules matching a criteria */
    RuleManager.prototype.filter = function (criteria) { return this.rules.filter(criteria); };
    /**
     * The settings are usually retrieved on settings,
     * but you can also put them behind the toolbar.
     * But mixing both won't work ATM by design.
     */
    RuleManager.prototype.getSettings = function () {
        var all = this.getSystemRuleS(BuildSteps.settings) || [];
        // Params must be merged BEFORE adding the main toolbar rule
        // because actually settings shouldn't have params, but historically it was used
        // But toolbar-rule params are never for the settings
        // Because this params-mistake was only made when only 1 settings was allowed
        // We will only use one setting
        var params = Object.assign.apply(Object, __spreadArray([{}], all.slice(0, 1).map(function (a) { return a === null || a === void 0 ? void 0 : a.params; }), false));
        var tlbPart = this.getToolbar();
        if (tlbPart)
            all.unshift(tlbPart); // add to start, so it's the lowest priority
        var ui = Object.assign.apply(Object, __spreadArray([{}], all.map(function (a) { return a === null || a === void 0 ? void 0 : a.ui; }), false));
        return { ui: ui, params: params };
    };
    /** Find a system rule (marked with '$') */
    RuleManager.prototype.getSystemRule = function (name) {
        return this.rules.find(function (r) { return r.operator === Operations.system && r.step === name; });
    };
    /** Find a system rule (marked with '$') */
    RuleManager.prototype.getSystemRuleS = function (name) {
        return this.rules.filter(function (r) { return r.operator === Operations.system && r.step === name; });
    };
    return RuleManager;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/rules/index.ts








;// CONCATENATED MODULE: ./src/toolbar/config-loaders/toolbar-config-loader-v10.ts
var toolbar_config_loader_v10_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * @internal
 */
var ToolbarConfigLoaderV10 = /** @class */ (function (_super) {
    toolbar_config_loader_v10_extends(ToolbarConfigLoaderV10, _super);
    function ToolbarConfigLoaderV10(toolbar) {
        var _this = _super.call(this, 'Tlb.TlbV10', toolbar.log, 'constructor') || this;
        _this.toolbar = toolbar;
        _this.rules = new RuleManager(toolbar);
        return _this;
    }
    ToolbarConfigLoaderV10.prototype.loadV10 = function (context, config, raw) {
        var _this = this;
        var _a;
        var cl = this.log.call('loadV10');
        this.rules.load(raw);
        var template;
        // #1 prepare settings - get rules and mix with defaults
        // We should use the `ui` parameter, as it's UI rules, but because previously
        // it used the `params` - we must support both :(
        var settingRule = this.rules.getSettings();
        var settingsUiRule = settingRule === null || settingRule === void 0 ? void 0 : settingRule.ui;
        if (Object.keys(settingsUiRule || {}).length === 0)
            settingsUiRule = settingRule === null || settingRule === void 0 ? void 0 : settingRule.params;
        var settings = new ToolbarSettings(settingsUiRule);
        // #2 load either the default toolbar or the one specified
        var toolbarRule = this.rules.getToolbar();
        // #3 find params
        var params = this.rules.getParams();
        // If it's a sub-list toolbar, use the special template for it
        var isSublist = config.toolbar.fields || ((_a = params === null || params === void 0 ? void 0 : params.params) === null || _a === void 0 ? void 0 : _a.fields);
        var defToolbarname = isSublist ? ToolbarTemplateSublist.name : ToolbarTemplateDefault.name;
        var toolbarTemplateName = toolbarRule
            ? toolbarRule.name
            : defToolbarname;
        template = this.toolbar.templates.copy(toolbarTemplateName);
        template.settings = settings;
        if (params)
            template.params = params.params;
        // #4 Remove unwanted groups
        var removeGroups = this.rules.getRemoveGroups();
        removeGroups.forEach(function (rg) { return _this.toolbar.templateEditor.removeGroup(template, rg.name); });
        // Add additional buttons
        var add = this.rules.getAdd();
        add.forEach(function (a) {
            if (a.step === BuildSteps.group)
                _this.toolbar.templateEditor.addGroup(template, a.name, a.pos);
            else
                _this.toolbar.templateEditor.addButton(template, a.group, a.id, a.name, a.pos);
        });
        var toolbar = this.toolbar.buildTreeAndModifyAccordingToRules(context, template);
        if (!toolbar.identifier)
            toolbar.identifier = Toolbar.createIdentifier();
        toolbar.settings._rules = this.rules;
        // process the rules one by one
        return cl.return(toolbar, 'ok');
    };
    return ToolbarConfigLoaderV10;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/config-loaders/index.ts











;// CONCATENATED MODULE: ./src/toolbar/config-loaders/toolbar-config-loader.ts
var toolbar_config_loader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



// Enable when debugging toolbar creation - will dump all logs to the console
var liveDumpThis = false;
/**
 * @internal
 */
var ToolbarConfigLoader = /** @class */ (function (_super) {
    toolbar_config_loader_extends(ToolbarConfigLoader, _super);
    /** Special constructor that can only be called from the ToolbarManager */
    function ToolbarConfigLoader(_owner) {
        var _this = 
        // important: always create a new log as it will be stored in insights
        _super.call(this, 'Tlb.TlbCnf') || this;
        _this.templates = ToolbarTemplateManager.singleton();
        return _this;
    }
    ToolbarConfigLoader.prototype.setLoggingAndCreateHelpers = function (toolbarData) {
        // note: could be true, false or 'live'
        var debugLog = toolbarData && toolbarData.debug;
        if (debugLog === undefined && Array.isArray(toolbarData) && toolbarData.length)
            debugLog = toolbarData[0].debug;
        debugLog = debugLog || false;
        if (liveDumpThis || debugLog) {
            this.log.keepData = true;
            if (liveDumpThis || debugLog.toString() === 'live')
                this.log.liveDump = true;
            this.log.add("found debug=".concat(debugLog, ", will enable intense logging"));
        }
        this.toolbarV09 = new ToolbarConfigLoaderV09(this);
        this.toolbarV10 = new ToolbarConfigLoaderV10(this);
        this.groups = new ButtonGroupConfigLoader(this);
        this.button = new ButtonConfigLoader(this);
        this.command = new CommandConfigLoader(this);
        this.templateEditor = new TemplateEditor(this);
    };
    ToolbarConfigLoader.prototype.load = function (context, config) {
        var cl = this.log.call('load', '', 'expand start', { context: context, config: config });
        // cl.data('initial context', context);
        // cl.data('initial config', config);
        // if null/undefined, use empty object
        var raw = config.toolbar = config.toolbar || {};
        this.setLoggingAndCreateHelpers(raw);
        // check if it's a V10 tolbar
        if (Array.isArray(raw) && raw.length >= 0 && typeof raw[0] === 'string')
            return cl.return(this.toolbarV10.loadV10(context, config, raw), 'v10 done');
        // do standard V3 procedures
        return cl.return(this.toolbarV09.loadV9(context, config), 'V9 done');
    };
    ToolbarConfigLoader.prototype.buildTreeAndModifyAccordingToRules = function (toolbarContext, configWip) {
        var wrapLog = this.log.call('buildFullDefinition');
        var tlbConfig = this.groups.expandButtonGroups(configWip);
        // #CodeChange#2020-03-22#InstanceConfig - believe this is completely unused; remove in June
        this.button.removeDisableButtons(toolbarContext, tlbConfig /*, instanceConfig */);
        return wrapLog.return(tlbConfig);
    };
    return ToolbarConfigLoader;
}(HasLog));


;// CONCATENATED MODULE: ./src/toolbar/toolbar-manager.ts
var toolbar_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



/**
 * Toolbar manager for the whole page - basically a set of APIs
 * the toolbar manager is an internal helper taking care of toolbars, buttons etc.
 * @internal
 */
var ToolbarManager = /** @class */ (function (_super) {
    toolbar_manager_extends(ToolbarManager, _super);
    function ToolbarManager() {
        var _this = _super.call(this, 'Tlb.Mngr', null, 'init') || this;
        insights_Insights.add('system', 'toolbar-manager', _this.log);
        _this.toolbarFinder = new ToolbarConfigFinderAndInitializer(_this);
        return _this;
    }
    /** Singleton */
    ToolbarManager.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new ToolbarManager());
    };
    ToolbarManager.prototype.buildModule = function (parentTag) {
        this.toolbarFinder.buildDnnModule(parentTag);
    };
    ToolbarManager.prototype.build = function (node) {
        this.toolbarFinder.build(node);
    };
    ToolbarManager.prototype.loadConfig = function (context, config) {
        var loader = this.getLoader(JSON.stringify(config.toolbar || ''));
        return loader.load(context, config);
    };
    /** Generate a single-use loader. It must be single use so the logs work */
    ToolbarManager.prototype.getLoader = function (instanceName) {
        var loader = new ToolbarConfigLoader(this);
        insights_Insights.add('toolbar', instanceName, loader.log);
        return loader;
    };
    return ToolbarManager;
}(HasLog));

// export const ToolbarManager = new ToolbarManagerGlobal();

;// CONCATENATED MODULE: ./src/quick-edit/modifier-content-block-internal.ts
var modifier_content_block_internal_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


// note: this import must be at the end of the list, for reasons unknown
// otherwise you get an error at runtime, something about constructors
// Object prototype may only be an Object or null: undefined
// not sure why though
// tslint:disable-next-line: ordered-imports

//#region WebApi Endpoints used: 2sxc
var webApiNew = 'cms/block/block';
var webApiMove = 'cms/list/move';
var webApiRemove = 'cms/list/Delete';
//#endregion
/**
 * contains commands to create/move/delete a content-block in an inner-content
 * @internal
 */
var ModifierContentBlockInstance = /** @class */ (function (_super) {
    modifier_content_block_internal_extends(ModifierContentBlockInstance, _super);
    function ModifierContentBlockInstance(parent, sxcInstance) {
        var _this = _super.call(this, 'QE.MdCbIn', parent.log) || this;
        _this.sxcInstance = sxcInstance;
        return _this;
    }
    /**
     * create content block
     */
    ModifierContentBlockInstance.prototype.create = function (parentId, field, index, app, // app name
    container, guid) {
        // the wrapper, into which this will be placed and the list of pre-existing blocks
        if (!container) {
            alert('can\'t add content-block as we couldn\'t find the list');
            return Promise.resolve();
        }
        var cblockList = container.querySelectorAll('div.sc-content-block');
        if (index > cblockList.length)
            index = cblockList.length; // make sure index is never greater than the amount of items
        var params = { parentId: parentId, field: field, index: index, app: app, guid: guid };
        var promise = this.sxcInstance.webApi
            .fetchJson(this.sxcInstance.webApi.url(webApiNew, params), undefined, 'POST')
            .then(function (result) {
            var newTag = NoJQ.domFromString(result)[0]; // prepare tag for inserting
            // should I add it to a specific position...
            if (cblockList.length > 0 && index > 0)
                cblockList[cblockList.length > index - 1 ? index - 1 : cblockList.length - 1].after(newTag);
            else // ...or just at the beginning?
                container.prepend(newTag);
            // ReSharper disable once UnusedLocals
            var sxcNew = window.$2sxc(newTag);
            ToolbarManager.singleton().buildModule(newTag);
        });
        return Promise.resolve(promise);
    };
    /**
     * move content block
     * @param parentId
     * @param field
     * @param indexFrom
     * @param indexTo
     */
    ModifierContentBlockInstance.prototype.move = function (parent, field, indexFrom, indexTo) {
        var params = {
            parent: parent,
            fields: field,
            index: indexFrom,
            toIndex: indexTo,
        };
        var promise = this.sxcInstance.webApi
            .fetchRaw(this.sxcInstance.webApi.url(webApiMove, params), undefined, 'POST')
            .then(function () {
            console.log('done moving!');
            window.location.reload();
        });
        return Promise.resolve(promise);
    };
    /**
     * delete a content-block inside a list of content-blocks
     * @param parent
     * @param field
     * @param index
     */
    ModifierContentBlockInstance.prototype.delete = function (parent, field, index) {
        if (!confirm(translate('QuickInsertMenu.ConfirmDelete')))
            return null;
        var params = {
            parent: parent,
            fields: field,
            index: index,
        };
        var promise = this.sxcInstance.webApi
            .fetchRaw(this.sxcInstance.webApi.url(webApiRemove, params), undefined, 'DELETE')
            .then(function () {
            console.log('done deleting!');
            window.location.reload();
        });
        return Promise.resolve(promise);
    };
    return ModifierContentBlockInstance;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-edit/modifier-content-block.ts
var modifier_content_block_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




/**
 * extend the quick edit with the core commands
 * @internal
 */
var ModifierContentBlock = /** @class */ (function (_super) {
    modifier_content_block_extends(ModifierContentBlock, _super);
    function ModifierContentBlock() {
        return _super.call(this, 'QE.CntBlk') || this;
    }
    ModifierContentBlock.prototype.getInstanceModifier = function (tag) {
        var sxc = window.$2sxc(tag);
        return new ModifierContentBlockInstance(this, sxc);
    };
    ModifierContentBlock.prototype.delete = function (clip) {
        return this.getInstanceModifier(clip.list).delete(clip.parentGuid, clip.field, this.findClipListIndex(clip));
    };
    ModifierContentBlock.prototype.create = function (parent, field, listIndex, appOrContent, list, newGuid) {
        return this.getInstanceModifier(list).create(parent, field, listIndex, appOrContent, list, newGuid);
    };
    ModifierContentBlock.prototype.move = function (oldClip, newClip) {
        var from = this.findClipListIndex(oldClip);
        var to = this.findClipListIndex(newClip);
        this.getInstanceModifier(oldClip.list).move(newClip.parentGuid, newClip.field, from, to);
    };
    // cb-numbering is a bit different, because the selector is at the bottom
    // only there we should also skip on +1;
    ModifierContentBlock.prototype.isRealMove = function (oldClip, newClip) {
        return this.findClipListIndex(oldClip) + 1 !== this.findClipListIndex(newClip);
    };
    /**
     * find the real index of this block in the list - may not match the DOM index
     */
    ModifierContentBlock.prototype.findClipListIndex = function (clip) {
        return this.findListIndex(clip.item, clip.index);
    };
    /**
     * find the real index of a block tag as it may not match the DOM index
     */
    ModifierContentBlock.prototype.findListIndex = function (tag, fallback) {
        var _a, _b;
        var editContext = SxcTools.getEditContextOfTag(tag);
        var listIndex = (_b = (_a = editContext === null || editContext === void 0 ? void 0 : editContext.contentBlockReference) === null || _a === void 0 ? void 0 : _a.parentIndex) !== null && _b !== void 0 ? _b : fallback;
        return listIndex;
    };
    /**
     * The button click handler. Must be static, as it will be attached to the buttons
     * So the 'this' is not a ContentBlockModifier, but the html-tag which was clicked
     */
    ModifierContentBlock.onCbButtonClick = function () {
        var blockTag = QuickE.singleton().main.activeContentBlock;
        var button = this;
        var list = QeSelectors.blocks.cb.findClosestList(blockTag);
        var listItems = list.querySelectorAll(QeSelectors.blocks.cb.selector);
        var actionConfig = ContextForLists.getFromDom(list);
        var newGuid = actionConfig.guid || null;
        // if the target is a content-block, then the list already has items
        // so the domIndex must be based on that. Otherwise use 0
        var domIndex = blockTag.classList.contains(QeSelectors.blocks.cb["class"])
            ? Array.from(listItems).indexOf(blockTag) + 1
            : 0;
        // Check if it's a cut/paste action
        var cbAction = button.getAttribute('data-action');
        if (cbAction)
            return QuickEClipboard.singleton().do(cbAction, list, domIndex, QeSelectors.blocks.cb.id);
        // this is a create-additional block action
        // in this case the clipboard doesn't exist
        // so we'll have to find the dom object and get the list index
        var listIndex = QuickEClipboard.singleton().modCb.findListIndex(blockTag, domIndex - 1) + 1;
        var appOrContent = button.getAttribute('data-type');
        return QuickEClipboard.singleton().modCb.create(actionConfig.parent, actionConfig.field, listIndex, appOrContent, list, newGuid);
    };
    return ModifierContentBlock;
}(ModifierBase));


;// CONCATENATED MODULE: ./src/quick-edit/position-coordinates.ts
/**
 * @internal
 */
var PositionCoordinates = /** @class */ (function () {
    function PositionCoordinates(x, y) {
        this.x = x;
        this.y = y;
    }
    return PositionCoordinates;
}());


;// CONCATENATED MODULE: ./src/quick-edit/modifier-dnn-module.ts
var modifier_dnn_module_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @internal
 */
var ModifierDnnModule = /** @class */ (function (_super) {
    modifier_dnn_module_extends(ModifierDnnModule, _super);
    function ModifierDnnModule() {
        var _this_1 = _super.call(this, 'QE.DnnMod') || this;
        _this_1.modInternal = new ModifierDnnModuleInternal(_this_1);
        return _this_1;
    }
    ModifierDnnModule.prototype.delete = function (clip) {
        if (!confirm('are you sure?'))
            return;
        var modId = this.modInternal.getModuleId(clip.item.className);
        this.modInternal.delete(modId);
    };
    // todo: unsure if this is a good place for this bit of code...
    ModifierDnnModule.prototype.move = function (oldClip, newClip /*, from: number, to: number*/) {
        var from = oldClip.index;
        var to = newClip.index;
        var modId = this.modInternal.getModuleId(oldClip.item.className);
        var pane = this.modInternal.getPaneName(newClip.list);
        this.modInternal.move(modId, pane, to);
    };
    ModifierDnnModule.prototype.isRealMove = function (oldClip, newClip) {
        var oldPane = this.modInternal.getPaneName(oldClip.list);
        var newPane = this.modInternal.getPaneName(newClip.list);
        return oldPane !== newPane || oldClip.index !== newClip.index;
    };
    ModifierDnnModule.prototype.showSendToPane = function () {
        // debugger; // there is a bug where pane options are not updated when user clicks send to pane once, until that button is clicked again
        // to reproduce: select module in header pane, click sendToPane. Now select module in content pane and notice panes list is showing panes for previous module
        var quickE = QuickE.singleton();
        var pane = QeSelectors.blocks.mod.findClosestList(quickE.main.activeModule);
        // debugger; // breaks in inner content buttons, like Accordion App. Check if I can hide this button in inner content
        if (!pane)
            return;
        // show the pane-options
        var pl = quickE.selected.querySelector('#paneList');
        if (!pl.matches(':empty'))
            NoJQ.empty(pl);
        pl.append(this.modInternal.getMoveButtons(this.modInternal.getPaneName(pane)));
    };
    ModifierDnnModule.onModuleButtonClick = function () {
        var _this = this;
        var type = _this.getAttribute('data-type');
        var dnnMod = QuickE.singleton().main.activeModule;
        var pane = QeSelectors.blocks.mod.findClosestList(dnnMod);
        var index = 0;
        if (dnnMod.classList.contains('DnnModule'))
            index = Array.from(pane.querySelectorAll('.DnnModule')).indexOf(dnnMod) + 1;
        var cbAction = _this.getAttribute('data-action');
        if (cbAction)
            return QuickEClipboard.singleton().do(cbAction, pane, index, QeSelectors.blocks.mod.id); // copy/paste
        var modManage = QuickEClipboard.singleton().modDnn.modInternal;
        return modManage.create(modManage.getPaneName(pane), index, type);
    };
    return ModifierDnnModule;
}(ModifierBase));


;// CONCATENATED MODULE: ./src/quick-edit/modifier-dnn-module-internal.ts
var modifier_dnn_module_internal_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var modifier_dnn_module_internal_assign = (undefined && undefined.__assign) || function () {
    modifier_dnn_module_internal_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return modifier_dnn_module_internal_assign.apply(this, arguments);
};


// Important - for DNN it still uses #jquery
var dnnSF = function (id) { return window.$.dnnSF(id); };
/**
 * module specific stuff
 * @internal
 */
var ModifierDnnModuleInternal = /** @class */ (function (_super) {
    modifier_dnn_module_internal_extends(ModifierDnnModuleInternal, _super);
    function ModifierDnnModuleInternal(parent) {
        return _super.call(this, 'QE.ModMng', parent.log) || this;
    }
    /**
     * Delete a module
     */
    ModifierDnnModuleInternal.prototype.delete = function (modId) {
        var service = dnnSF(modId);
        var tabId = service.getTabId();
        return sendDnnAjax({
            modId: modId,
            url: dnnSF().getServiceRoot('2sxc') + 'dnn/module/delete',
            method: 'GET',
            data: {
                tabId: tabId,
                modId: modId,
            },
            // ReSharper disable once UnusedParameter
            success: function () { return window.location.reload(); },
        });
    };
    /**
     * Create a new module
     */
    ModifierDnnModuleInternal.prototype.create = function (paneName, index, type) {
        return sendDnnAjax({
            modId: null,
            url: dnnSF().getServiceRoot('internalservices') + 'controlbar/GetPortalDesktopModules',
            method: 'GET',
            data: 'category=All&loadingStartIndex=0&loadingPageSize=100&searchTerm=',
            success: function (desktopModules) {
                var moduleToFind = type === 'Default' ? ' Content' : ' App';
                var module = null;
                // ReSharper disable once UnusedParameter
                desktopModules.forEach(function (e, i) {
                    if (e.ModuleName === moduleToFind)
                        module = e;
                });
                return (!module)
                    ? alert(moduleToFind + ' module not found.')
                    : createMod(paneName, index, module.ModuleID);
            },
        });
    };
    /**
     * Move a DNN Module
     */
    ModifierDnnModuleInternal.prototype.move = function (modId, pane, order) {
        var service = dnnSF(modId);
        var tabId = service.getTabId();
        var dataVar = {
            TabId: tabId,
            ModuleId: modId,
            Pane: pane,
            ModuleOrder: (2 * order + 0),
            // strange formula, copied from DNN https://github.com/dnnsoftware/Dnn.Platform/blob/fd225b8de07042837f7473cd49fba13de42a3cc0/Website/admin/Menus/ModuleActions/ModuleActions.js#L70
            // stv: changed formula from: (2 * order + 4)
            // ...to: (2 * order + 0)
        };
        sendDnnAjax({
            modId: modId,
            url: dnnSF(modId).getServiceRoot('internalservices') + 'ModuleService/MoveModule',
            method: 'POST',
            data: dataVar,
            success: function () { return window.location.reload(); },
        });
    };
    ModifierDnnModuleInternal.prototype.getPaneName = function (pane) {
        return pane.getAttribute('id').replace('dnn_', '');
    };
    /**
     * find the correct module id from a list of classes - used on the module-wrapper
     */
    ModifierDnnModuleInternal.prototype.getModuleId = function (classes) {
        var result = classes.match(/DnnModule-([0-9]+)(?:\W|$)/);
        return (result && result.length === 2) ? Number(result[1]) : null;
    };
    ModifierDnnModuleInternal.prototype.getMoveButtons = function (current) {
        var pns = QuickE.singleton().cachedPanes;
        // generate list of panes as links
        var targets = NoJQ.domFromString('<div></div>')[0];
        for (var p = 0; p < pns.length; p++) {
            var pName = this.getPaneName(pns[p]);
            var selected = (current === pName) ? ' selected ' : '';
            if (selected === '') {
                var target = NoJQ.domFromString("<a data='".concat(pName, "'>").concat(pName, "</a>"))[0];
                targets.append(target);
            }
        }
        // attach click event...
        var _this = this;
        targets.querySelectorAll('a').forEach(function (e) {
            e.addEventListener('click', function () {
                var link = this;
                var clip = QuickEClipboard.singleton().clipboard;
                var modId = _this.getModuleId(clip.item.className);
                var newPane = link.getAttribute('data');
                _this.move(modId, newPane, 0);
            });
        });
        return targets;
    };
    return ModifierDnnModuleInternal;
}(HasLog));

// call an api on dnn
function sendDnnAjax(req) {
    // set DNN headers
    var dnnHeaders = {};
    var fakeXhr = {
        setRequestHeader: function (name, value) {
            dnnHeaders[name] = value;
        },
    };
    dnnSF(req.modId).setModuleHeaders(fakeXhr);
    var settings = {
        headers: modifier_dnn_module_internal_assign({ 'X-Requested-With': 'XMLHttpRequest' }, dnnHeaders),
        method: req.method,
    };
    var url = req.url;
    if (req.data) {
        switch (req.method) {
            case 'GET':
                url += typeof req.data === 'string' ? "?".concat(req.data) : "?".concat(NoJQ.param(req.data));
                break;
            case 'POST':
                settings.body = new URLSearchParams(NoJQ.param(req.data));
                settings.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
                break;
        }
    }
    var success = req.success;
    return fetch(url, settings)
        .then(function (response) {
        if (response.status >= 200 && response.status < 300) {
            return response.text();
        }
        throw new Error(response.statusText);
    })
        .then(function (resText) {
        var resData;
        try {
            resData = JSON.parse(resText);
        }
        catch (_a) {
            resData = resText;
        }
        success === null || success === void 0 ? void 0 : success(resData);
        return resData;
    })
        .catch(function (err) {
        alert("Error while talking to server: ".concat(err.message));
        return undefined;
    });
}
// create / insert a new module
function createMod(paneName, position, modId) {
    var postData = {
        Module: modId,
        Page: '',
        Pane: paneName,
        Position: -1,
        Sort: position,
        Visibility: 0,
        AddExistingModule: false,
        CopyModule: false,
    };
    return sendDnnAjax({
        modId: null,
        url: dnnSF().getServiceRoot('internalservices') + 'controlbar/AddModule',
        method: 'POST',
        data: postData,
        success: function () { return window.location.reload(); },
    });
}

;// CONCATENATED MODULE: ./src/quick-edit/positioning.ts
var positioning_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



/**
 * Module with everything related to positioning the quick-edit in-page editing
 * @internal
 */
var Positioning = /** @class */ (function () {
    function Positioning() {
    }
    /**
     * Find the position of an element
     */
    Positioning.get = function (element) {
        var coords = {
            element: element,
            x: NoJQ.offset(element).left,
            w: NoJQ.width(element),
            y: NoJQ.offset(element).top,
            // For content-block ITEMS, the menu must be visible at the end
            // For content-block-LISTS, the menu must be at top
            yh: NoJQ.offset(element).top + (element.matches(QeSelectors.eitherCbOrMod) ? NoJQ.height(element) : 0),
        };
        return coords;
    };
    /**
     * Prepare offset calculation based on body positioning
     */
    Positioning.getBodyPosition = function () {
        var posNoJq = document.body.style.position;
        var bodyPos = posNoJq; // QuickE.body.css('position');
        var quickE = QuickE.singleton();
        return bodyPos === 'relative' || bodyPos === 'absolute'
            ? new PositionCoordinates(NoJQ.offset(quickE.body).left, NoJQ.offset(quickE.body).top)
            : new PositionCoordinates(0, 0);
    };
    Positioning.positionAndAlign = positionAndAlign;
    Positioning.refresh = refresh;
    return Positioning;
}());

/**
 * Refresh content block and modules elements
 */
function refreshDomObjects() {
    // must update this, as sometimes after finishing page load the position changes, like when dnn adds the toolbar
    var quickE = QuickE.singleton();
    quickE.bodyOffset = Positioning.getBodyPosition();
    if (quickE.config.innerBlocks.enable) {
        // get all content-block lists which are empty, or which allow multiple child-items
        var lists = QeSelectors.blocks.cb.findAllLists().filter(function (e) { return e.matches(":not(.".concat(QeSelectors.blocks.cb.singleItem, "), :empty")); });
        var children_1 = [];
        lists.forEach(function (l) {
            children_1.push.apply(children_1, Array.from(l.querySelectorAll(QeSelectors.blocks.cb.selector)));
        });
        quickE.contentBlocks = positioning_spreadArray(positioning_spreadArray([], lists, true), children_1, true);
    }
    if (quickE.config.modules.enable) {
        var panes = quickE.cachedPanes;
        var children_2 = [];
        panes.forEach(function (p) {
            children_2.push.apply(children_2, Array.from(p.querySelectorAll(QeSelectors.blocks.mod.selector)));
        });
        quickE.modules = positioning_spreadArray(positioning_spreadArray([], panes, true), children_2, true);
    }
}
/**
 * Last time when contentblock and modules are refreshed.
 * Helps to skip unnecessary calls to refresh(e).
 */
var lastCall;
/**
 * position, align and show a menu linked to another item
 * @internal
 */
function positionAndAlign(element, coords) {
    var quickE = QuickE.singleton();
    element.style.left = "".concat(coords.x - quickE.bodyOffset.x, "px");
    element.style.top = "".concat(coords.yh - quickE.bodyOffset.y, "px");
    element.style.width = "".concat(NoJQ.width(coords.element), "px");
    element.style.display = 'block';
    return element;
}
/**
 * Refresh positioning / visibility of the quick-insert bar
 * @internal
 */
function refresh(e) {
    var highlightClass = 'sc-cb-highlight-for-insert';
    var newDate = new Date();
    if ((!lastCall) || (newDate.getTime() - lastCall.getTime() > 1000)) {
        // console.log('refreshed contentblock and modules');
        lastCall = newDate;
        refreshDomObjects();
    }
    // find the closest content-blocks and modules
    var currentCoords = new PositionCoordinates(e.clientX, e.clientY);
    var quickE = QuickE.singleton();
    if (quickE.config.innerBlocks.enable && quickE.contentBlocks)
        quickE.nearestCb = findNearest(quickE.contentBlocks, currentCoords);
    if (quickE.config.modules.enable && quickE.modules)
        quickE.nearestMod = findNearest(quickE.modules, currentCoords);
    // hide the buttons for content-block or module, if they are not affected
    quickE.modActions.forEach(function (a) {
        a.classList.toggle('sc-invisible', quickE.nearestMod === null);
    });
    quickE.cbActions.forEach(function (a) {
        a.classList.toggle('sc-invisible', quickE.nearestCb === null);
    });
    var oldParent = quickE.main._parentNode;
    if (quickE.nearestCb !== null || quickE.nearestMod !== null) {
        var alignTo = quickE.nearestCb || quickE.nearestMod;
        // find parent pane to highlight
        var parentPane = QeSelectors.blocks.mod.findClosestList(alignTo.element);
        var parentCbList = QeSelectors.blocks.cb.findClosestList(alignTo.element);
        var parentContainer = parentCbList !== null && parentCbList !== void 0 ? parentCbList : parentPane;
        provideCorrectAddButtons(parentContainer);
        // put part of the pane-name into the button-labels
        if (parentPane) {
            var paneName_1 = parentPane.getAttribute('id') || '';
            if (paneName_1.length > 4)
                paneName_1 = paneName_1.substr(4);
            quickE.modActions.filter(function (a) { return a.matches('[titleTemplate]'); }).forEach(function (a) {
                a.setAttribute('title', a.getAttribute('titleTemplate').replace('{0}', paneName_1));
            });
        }
        positionAndAlign(quickE.main, alignTo);
        // Keep current block as current on menu
        quickE.main.activeContentBlock = quickE.nearestCb ? quickE.nearestCb.element : null;
        quickE.main.activeModule = quickE.nearestMod ? quickE.nearestMod.element : null;
        quickE.main._parentNode = parentContainer;
        parentContainer.classList.add(highlightClass);
    }
    else {
        quickE.main._parentNode = null;
        quickE.main.style.display = 'none';
    }
    // if previously a parent-pane was highlighted, un-highlight it now
    if (oldParent && oldParent !== quickE.main._parentNode)
        oldParent.classList.remove(highlightClass);
}
function provideCorrectAddButtons(tag) {
    var listSettings = ContextForLists.getFromDom(tag);
    var showContent = true;
    var showApps = true;
    if (listSettings.appList.length > 0) {
        showContent = listSettings.appList.indexOf('Content') > -1;
        // only show apps if the list is longer than 'Content' if it contains that
        showApps = listSettings.appList.length - (showContent ? 1 : 0) > 0;
    }
    QuickE.singleton().cbActions.forEach(function (a) {
        a.classList.toggle('hide-content', !showContent);
        a.classList.toggle('hide-app', !showApps);
    });
}
/**
 * Return the nearest element to the mouse cursor from elements
 */
function findNearest(elements, position) {
    var maxDistance = 30; // Defines the maximal distance of the cursor when the menu is displayed
    var nearestItem = null;
    var nearestDistance = maxDistance;
    var posX = position.x + window.scrollX;
    var posY = position.y + window.scrollY;
    // Find nearest element
    elements.forEach(function (element) {
        var e = Positioning.get(element);
        // First check x coordinates - must be within container
        if (posX < e.x || posX > e.x + e.w)
            return;
        // Check if y coordinates are within boundaries
        var distance = Math.abs(posY - e.yh);
        if (distance < maxDistance && distance < nearestDistance) {
            nearestItem = e;
            nearestDistance = distance;
        }
    });
    return nearestItem;
}

;// CONCATENATED MODULE: ./src/quick-edit/quick-e.ts
var quick_e_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var quick_e_assign = (undefined && undefined.__assign) || function () {
    quick_e_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return quick_e_assign.apply(this, arguments);
};



var configAttr = 'quick-edit-config';
var classForAddContent = 'sc-content-block-menu-addcontent';
var classForAddApp = 'sc-content-block-menu-addapp';
/**
 * the quick-edit object
 * the quick-insert object
 * @internal
 */
var QuickE = /** @class */ (function (_super) {
    quick_e_extends(QuickE, _super);
    function QuickE() {
        var _this = _super.call(this, 'Q-E.Main') || this;
        _this.body = document.body;
        _this.main = NoJQ.domFromString('<div class="sc-content-block-menu sc-content-block-quick-insert sc-i18n"></div>')[0];
        _this.template = "<a class='".concat(classForAddContent, " sc-invisible' data-type='Default' data-i18n='[titleTemplate]QuickInsertMenu.AddBlockContent'>&nbsp;</a>")
            + "<a class='".concat(classForAddApp, " sc-invisible' data-type='' data-i18n='[titleTemplate]QuickInsertMenu.AddBlockApp'>&nbsp;</a>")
            + "".concat(QuickEditOverlay.btn('select', 'ok', 'Select', true)).concat(QuickEditOverlay.btn('paste', 'paste', 'Paste', true, true));
        _this.selected = QuickEditOverlay.selectedOverlay;
        // will be populated later in the module section
        _this.contentBlocks = null;
        _this.cachedPanes = null;
        _this.modules = null;
        _this.nearestCb = null;
        _this.nearestMod = null;
        // add stuff which depends on other values to create
        _this.cbActions = NoJQ.domFromString(_this.template);
        _this.modActions = NoJQ.domFromString(_this.template.replace(/QuickInsertMenu.AddBlock/g, 'QuickInsertMenu.AddModule')).map(function (a) {
            a.setAttribute('data-context', 'module');
            a.classList.add('sc-content-block-menu-module');
            return a;
        });
        //
        _this.config = QuickEditConfigRoot.getDefault();
        insights_Insights.add('Q-E', 'manager', _this.log);
        _this.modActions.forEach(function (a) {
            a.addEventListener('click', ModifierDnnModule.onModuleButtonClick);
        });
        _this.cbActions.forEach(function (a) {
            a.addEventListener('click', ModifierContentBlock.onCbButtonClick);
        });
        return _this;
    }
    /** Singleton */
    QuickE.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new QuickE());
    };
    QuickE.prototype.start = function () {
        try {
            this.loadPageConfig();
            if (this.config.enable) {
                // initialize first body-offset
                this.bodyOffset = Positioning.getBodyPosition();
                this.enable();
                this.initWatchMouse();
            }
        }
        catch (e) {
            console.error("couldn't start quick-edit", e);
        }
    };
    /**
     * reset the quick-edit
     * for example after ajax-loading a content-block, which may cause changed configurations
     */
    QuickE.prototype.reset = function () {
        var cl = this.log.call('reset');
        this.loadPageConfig();
        cl.done();
    };
    /**
     * This checks if the page has any alternate configuration
     * Note that it's also used after ajax refreshes, which can change the config
     * So if it does reconfigure itself, it will start with the default config again
     */
    QuickE.prototype.loadPageConfig = function () {
        var _a, _b, _c, _d, _e, _f;
        var cl = this.log.call('loadPageConfig', null, null, { config: this.config });
        this.logConfig();
        var configs = document.querySelectorAll("[".concat(configAttr, "]"));
        var confJ;
        if (configs.length > 0) {
            cl.add('found configs', configs);
            // go through reverse list, as the last is the most important...
            var finalConfig = {};
            for (var c = configs.length; c >= 0; c--) {
                // 2021-09-17 spm either the loop is wrong and we should only get configs[0] or we should be gettings configs[c]
                confJ = configs[0].getAttribute(configAttr);
                try {
                    var confO = JSON.parse(confJ);
                    cl.data('additional config', confO);
                    finalConfig = quick_e_assign(quick_e_assign({}, finalConfig), confO);
                    cl.data('merged config', finalConfig);
                }
                catch (e) {
                    cl.add('had trouble with json');
                    console.warn('had trouble with json', e);
                }
            }
            var defConfig = QuickEditConfigRoot.getDefault();
            this.config = quick_e_assign(quick_e_assign(quick_e_assign({}, defConfig), finalConfig), { buttons: quick_e_assign(quick_e_assign({}, defConfig.buttons), finalConfig.buttons) });
        }
        else
            cl.add('no configs found, will use exiting');
        // expand/merge configs on the sub-nodes module/block
        this.config.innerBlocks.buttons = quick_e_assign(quick_e_assign({}, (_a = this.config) === null || _a === void 0 ? void 0 : _a.buttons), (_c = (_b = this.config) === null || _b === void 0 ? void 0 : _b.innerBlocks) === null || _c === void 0 ? void 0 : _c.buttons);
        this.config.modules.buttons = quick_e_assign(quick_e_assign({}, (_d = this.config) === null || _d === void 0 ? void 0 : _d.buttons), (_f = (_e = this.config) === null || _e === void 0 ? void 0 : _e.modules) === null || _f === void 0 ? void 0 : _f.buttons);
        this.logConfig();
        this.detectWhichMenusToActivate();
        cl.done();
    };
    /**
     * existing inner blocks found? Will affect if modules can be quick-inserted...
     */
    QuickE.prototype.detectWhichMenusToActivate = function () {
        var conf = this.config;
        var cl = this.log.call('detectWhichMenusToActivate');
        var innerCBs = QeSelectors.blocks.cb.findAllLists();
        var hasInnerCBs = (innerCBs.length > 0);
        cl.add("has Content Blocks: ".concat(hasInnerCBs), innerCBs);
        // if it has inner-content, then it's probably a details page, where quickly adding modules would be a problem, so for now, disable modules in this case
        if (conf.modules.enable === null || conf.modules.enable === QuickEditConfigEnableAuto)
            conf.modules.enable = !hasInnerCBs;
        // for now, ContentBlocks are only enabled if they exist on the page
        if (conf.innerBlocks.enable === null || conf.innerBlocks.enable === QuickEditConfigEnableAuto)
            conf.innerBlocks.enable = hasInnerCBs;
        cl.add("module.enable: ".concat(conf.modules.enable));
        cl.add("innerBlocks.enable: ".concat(conf.innerBlocks.enable));
        cl.done();
    };
    QuickE.prototype.enable = function () {
        var cl = this.log.call('enable');
        // build all toolbar html-elements
        this.prepareToolbarInDom();
        // Cache the panes (because panes can't change dynamically)
        this.initPanes();
        cl.done();
    };
    QuickE.prototype.prepareToolbarInDom = function () {
        var _this = this;
        var cl = this.log.call('prepareToolbarInDom');
        this.body.append(this.main);
        this.body.append(this.selected);
        this.cbActions.forEach(function (a) { return _this.main.append(a); });
        this.modActions.forEach(function (a) { return _this.main.append(a); });
        // use config to enable/disable some buttons
        QuickEditOverlay.setButtonActivationClasses(this.config.innerBlocks.buttons, this.cbActions);
        QuickEditOverlay.setButtonActivationClasses(this.config.modules.buttons, this.modActions);
        cl.done();
    };
    /**
     * cache the panes which can contain modules
     */
    QuickE.prototype.initPanes = function () {
        var cl = this.log.call('initPanes');
        this.cachedPanes = QeSelectors.blocks.mod.findAllLists();
        this.cachedPanes.forEach(function (pane) {
            pane.classList.add('sc-cb-pane-glow');
        });
        cl.done();
    };
    /**
     * start watching for mouse-move
     */
    QuickE.prototype.initWatchMouse = function () {
        var cl = this.log.call('initWatchMouse');
        var refreshTimeout = null;
        document.body.addEventListener('mousemove', function (e) {
            if (refreshTimeout === null)
                refreshTimeout = window.setTimeout(function () {
                    requestAnimationFrame(function () {
                        Positioning.refresh(e);
                        refreshTimeout = null;
                    });
                }, 20);
        });
        cl.done();
    };
    QuickE.prototype.logConfig = function () {
        this.log.add("config enabled: ".concat(this.config.enable, ", mod: ").concat(this.config.modules.enable, ", cb: ").concat(this.config.innerBlocks.enable, ". ").concat(JSON.stringify(this.config), ")"));
    };
    return QuickE;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-edit/quick-e-clipboard.ts
var quick_e_clipboard_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





/**
 * add a clipboard to the quick edit
 * @internal
 */
var QuickEClipboard = /** @class */ (function (_super) {
    quick_e_clipboard_extends(QuickEClipboard, _super);
    function QuickEClipboard() {
        var _this = _super.call(this, 'Q-E.Clpbrd') || this;
        /**
         * clipboard object - remembers what module (or content-block) was previously copied / needs to be pasted
         */
        _this.clipboard = new Selection();
        _this.mods = {};
        insights_Insights.add('Q-E', 'clipboard', _this.log);
        _this.mods.cb = _this.modCb = new ModifierContentBlock();
        _this.mods.mod = _this.modDnn = new ModifierDnnModule();
        // initialize once the DOM is ready
        NoJQ.ready(function () { return _this.initializeSecondaryButtons(); });
        return _this;
    }
    /** Singleton */
    QuickEClipboard.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new QuickEClipboard());
    };
    /**
     * bind clipboard actions to DOM buttons
     */
    QuickEClipboard.prototype.initializeSecondaryButtons = function () {
        var cl = this.log.call('initializeSecondaryButtons');
        var qem = this;
        QuickE.singleton().selected.querySelectorAll('a').forEach(function (e) {
            e.addEventListener('click', function () {
                var action = this.getAttribute('data-action');
                switch (action) {
                    case 'delete': return qem.mods[qem.clipboard.type].delete(qem.clipboard);
                    case 'sendToPane': return qem.modDnn.showSendToPane();
                    default: throw new Error("unexpected action: ".concat(action));
                }
            });
        });
        cl.done();
    };
    /**
     * perform copy and paste commands - needs the clipboard
     * @param cbAction
     * @param list
     * @param domIndex
     * @param type
     */
    QuickEClipboard.prototype.do = function (cbAction, list, domIndex, type) {
        var cl = this.log.call('do', "".concat(cbAction, ", ..., ").concat(domIndex));
        var newClip = this.createSpecs(type, list, domIndex);
        // action!
        switch (cbAction) {
            case 'select':
                this.mark(newClip);
                break;
            case 'paste':
                var from = this.clipboard.index;
                var to = newClip.index;
                // check that we only move block-to-block or module to module
                if (this.clipboard.type !== newClip.type)
                    return alert("can't move module-to-block; move only works from module-to-module or block-to-block");
                if (isNaN(from) || isNaN(to))
                    return this.clearUi(); // skip, nothing real
                var operator = newClip.type === QeSelectors.blocks.cb.id ? this.modCb : this.modDnn;
                if (!operator.isRealMove(this.clipboard, newClip))
                    return this.clearUi(); // skip, no change
                operator.move(this.clipboard, newClip);
                this.clearUi();
                break;
            default:
        }
        return cl.return(null);
    };
    QuickEClipboard.prototype.mark = function (newData) {
        var _a, _b;
        var cl = this.log.call('mark');
        cl.data('specs', newData);
        if (newData) {
            // if it was already selected with the same thing, then release it
            if (this.clipboard && this.clipboard.item === newData.item)
                return cl.return(this.clearUi());
            this.clipboard = newData;
        }
        this.removeSelectionMarker(); // clear previous markings
        // sometimes missing data.item
        if (!this.clipboard.item)
            return cl.done();
        var selectedItem = this.clipboard.item;
        selectedItem.classList.add(QeSelectors.selected);
        if ((_a = selectedItem.previousElementSibling) === null || _a === void 0 ? void 0 : _a.matches('iframe'))
            selectedItem.previousElementSibling.classList.add(QeSelectors.selected);
        this.setSecondaryActionsState(true);
        var quickE = QuickE.singleton();
        var btnConfig = ((_b = this.clipboard) === null || _b === void 0 ? void 0 : _b.type) === QeSelectors.blocks.cb.id
            ? quickE.config.innerBlocks.buttons
            : quickE.config.modules.buttons;
        quickE.selected.toggleOverlay(selectedItem, btnConfig);
        cl.done();
    };
    /** Clear the UI so nothing is selected any more */
    QuickEClipboard.prototype.clearUi = function () {
        var cl = this.log.call('clearUi');
        this.removeSelectionMarker();
        this.clipboard = null;
        this.setSecondaryActionsState(false);
        QuickE.singleton().selected.toggleOverlay(false);
        cl.done();
    };
    QuickEClipboard.prototype.removeSelectionMarker = function () {
        document.querySelectorAll(".".concat(QeSelectors.selected)).forEach(function (s) { return s.classList.remove(QeSelectors.selected); });
    };
    QuickEClipboard.prototype.setSecondaryActionsState = function (state) {
        var cl = this.log.call('setSecondaryActionsState');
        var btns = Array.from(document.querySelectorAll('a.sc-content-block-menu-btn'));
        btns = btns.filter(function (btn) { return btn.classList.contains('icon-sxc-paste'); });
        btns.forEach(function (btn) { return btn.classList.toggle(C.ClsNames.UnAvailable, !state); });
        cl.done();
    };
    QuickEClipboard.prototype.createSpecs = function (type, list, domIndex) {
        var cl = this.log.call('createSpecs', "".concat(type, ", ..., ").concat(domIndex));
        var listItems = list.querySelectorAll(QeSelectors.blocks[type].selector);
        // when paste module below the last module in pane
        // index is 1 larger than the length, then select last
        var currentItem = (domIndex >= listItems.length)
            ? listItems[listItems.length - 1]
            : listItems[domIndex];
        // get info what item/block is being edited
        var contextInfo = ContextForLists.getFromDom(list) || {
            parent: 'dnn',
            field: list.id,
            parentGuid: null,
        };
        return cl.return({
            parent: contextInfo.parent,
            parentGuid: contextInfo.parentGuid,
            field: contextInfo.field,
            list: list,
            item: currentItem,
            index: domIndex,
            type: type,
        });
    };
    return QuickEClipboard;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-edit/selectors-instance.ts
/**
 * selectors used all over the in-page-editing, centralized to ensure consistency
 * @internal
 */
var contentBlockAndModuleSelectors = {
    cb: {
        id: 'cb',
        class: 'sc-content-block',
        selector: '.sc-content-block',
        findAllLists: function () { return Array.from(document.querySelectorAll('.sc-content-block-list')); },
        findClosestList: function (element) { return element.closest('.sc-content-block-list'); },
        context: 'data-list-context',
        singleItem: 'single-item',
    },
    mod: {
        id: 'mod',
        class: 'DnnModule',
        selector: '.DnnModule',
        // Found no better way to get all panes - the hidden variable does not exist when not in edit page mode
        findAllLists: function () {
            // jquery :has selector (https://api.jquery.com/has-selector/) is not a compatible with css selector
            // and doesn't work without jquery (https://developer.mozilla.org/en-US/docs/Web/CSS/:has)
            // and has absolutely terrible performance (380-560 ms)
            // $('.DNNEmptyPane, .dnnDropEmptyPanes, :has(>.DnnModule)')
            // compact javascript solution is still very slow (10-15 ms)
            // Array.from(document.querySelectorAll('*')).filter((e) => e.matches('.DNNEmptyPane, .dnnDropEmptyPanes') || Array.from(e.children).some((c) => c.matches('.DnnModule')))
            // as fast as can be (3-5 ms)
            var found = [];
            var all = document.querySelectorAll('*');
            for (var i = 0; i < all.length; i++) {
                var el = all[i];
                if (el.matches('.DNNEmptyPane, .dnnDropEmptyPanes')) {
                    found.push(el);
                    continue;
                }
                var children = el.children;
                for (var j = 0; j < children.length; j++) {
                    var child = children[j];
                    if (child.matches('.DnnModule')) {
                        found.push(el);
                        break;
                    }
                }
            }
            return found;
        },
        findClosestList: function (element) {
            if (!element)
                return null;
            if (element.matches('.DNNEmptyPane, .dnnDropEmptyPanes')) {
                return element;
            }
            for (var i = 0; i < element.children.length; i++) {
                var child = element.children[i];
                if (child.matches('.DnnModule')) {
                    return element;
                }
            }
            return contentBlockAndModuleSelectors.mod.findClosestList(element.parentElement);
        },
        context: null,
    },
};
/**
 * @internal
 */
var QeSelectors = {
    blocks: contentBlockAndModuleSelectors,
    eitherCbOrMod: '.DnnModule, .sc-content-block',
    selected: 'sc-cb-is-selected',
};

;// CONCATENATED MODULE: ./src/quick-edit/index.ts
// must come first because we're still relying on build order












var css = __webpack_require__(246);

;// CONCATENATED MODULE: ./src/commands/command/command-layout.ts




/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("layout" /* CommandNames.layout */, 'ChangeLayout', 'glasses', true, true, {
    inlineWindow: function (_) { return true; },
    code: function (context, event) {
        // console.log('layout');
        // Try to find the closest tag based on the click
        // if this fails, try to find it based on the sxc-instance
        var attrSel = '[' + QeSelectors.blocks.cb.context + ']';
        // note: sometimes when the page loads, this can be auto-triggered and not have an event
        var listSpecs = SxcTools.getTag(context.sxc).closest(attrSel);
        // Now check if we have apps-parameters to pass on
        if (listSpecs) {
            var specs = ContextForLists.getFromDom(listSpecs);
            context.button.command.params.apps = specs.apps;
        }
        return CmsEngine.openDialog(context, event);
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-metadata.ts
var command_metadata_assign = (undefined && undefined.__assign) || function () {
    command_metadata_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return command_metadata_assign.apply(this, arguments);
};

var MetadataDefaultKeyType = 'string';
var MetadataDefaultTargetType = 10; // cms-item
/**
 * create a metadata toolbar
 *
 * import this module to commands.ts
 * @internal
 */
var MetadataCommand = Command.build("metadata" /* CommandNames.metadata */, 'Metadata', 'tag', false, false, {
    addParamsToLink: function (_) { return ({ mode: "new" /* CommandNames.newMode */ }); },
    dialog: function (_) { return "edit" /* CommandNames.edit */; },
    // if it doesn't have data yet, make it less strong
    dynamicClasses: function (ctx) { return ctx.button.command.params.entityId ? '' : 'empty'; },
    // only add a metadata-button if it has metadata-infos
    showCondition: function (ctx) { return !!ctx.button.command.params.metadata; },
    configureLinkGenerator: function (_, linkGenerator) {
        var itm = {
            Metadata: command_metadata_assign({ keyType: MetadataDefaultKeyType, targetType: MetadataDefaultTargetType }, linkGenerator.context.button.command.params.metadata),
        };
        linkGenerator.items[0] = command_metadata_assign(command_metadata_assign({}, linkGenerator.items[0]), itm);
    },
});
/**
 * @internal
 */
var ImageMetadataCommand = Command.build("image" /* CommandNames.image */, 'Image', 'focus', false, false, {
    addParamsToLink: MetadataCommand.buttonDefaults.addParamsToLink,
    dialog: MetadataCommand.buttonDefaults.dialog,
    classes: 'single-field',
    dynamicClasses: MetadataCommand.buttonDefaults.dynamicClasses,
    showCondition: MetadataCommand.buttonDefaults.showCondition,
    configureLinkGenerator: MetadataCommand.buttonDefaults.configureLinkGenerator,
});
Commands.addCommand(MetadataCommand);
Commands.addCommand(ImageMetadataCommand);

;// CONCATENATED MODULE: ./src/commands/command/command-more.ts



/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("more" /* CommandNames.more */, 'MoreActions', 'options btn-mode', true, false, {
    code: function (context, event) {
        return new Promise(function (resolve, reject) {
            var btn2 = event.target;
            var fullMenu2 = btn2.closest(IDs.sel.tagScMenu);
            var oldState2 = Number(fullMenu2.getAttribute('data-state') || 0);
            var max2 = Number(fullMenu2.getAttribute('group-count'));
            var newState2 = (oldState2 + 1) % max2;
            fullMenu2.classList.remove("group-".concat(oldState2));
            fullMenu2.classList.add("group-".concat(newState2));
            fullMenu2.setAttribute('data-state', String(newState2));
            event.preventDefault();
            function mouseenterHandler(e) {
                fullMenu2.style.opacity = '1';
            }
            function mouseleaveHandler(e) {
                if (e.screenX !== 0 && e.screenY !== 0) {
                    // hide toolbar on mouseleave
                    fullMenu2.style.opacity = '0';
                }
                else {
                    // this is fix for Chrome issue
                    // ensure to show toolbar because X=0 and Y=0
                    fullMenu2.style.opacity = '1';
                    console.warn('workaround for toolbar hide onmouseleave issue', e.screenX, e.screenY, e.target);
                }
            }
            // because of issue in Chrome we need to override CSS rules in edit.css for toolbar toggle on mouse hover
            var scElement = fullMenu2.closest('.' + C.Toolbar.classes.oldHover);
            // add mouseenter and mouseleave events to parent sc-element if not already added
            if (scElement && fullMenu2.getAttribute('listener') !== 'true') {
                scElement.addEventListener('mouseenter', mouseenterHandler);
                scElement.addEventListener('mouseleave', mouseleaveHandler);
                fullMenu2.setAttribute('listener', 'true'); // flag that events are added
            }
            resolve();
        });
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-movedown.ts


/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("movedown" /* CommandNames.moveDown */, 'MoveDown', 'move-down', false, true, {
    // TODO: do not display if is last item in list
    showCondition: function (context) { return SharedLogic.isList(context); },
    code: function (context) {
        // TODO: make sure index is never greater than the amount of items
        var i = CmdParHlp.getIndex(context);
        return Actions.changeOrder(context, i, i + 1);
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-moveup.ts



/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("moveup" /* CommandNames.moveUp */, 'MoveUp', 'move-up', false, true, {
    showCondition: function (context) {
        return !!(SharedLogic.isList(context) && CmdParHlp.getIndex(context) !== 0);
    },
    code: function (context) {
        var i = CmdParHlp.getIndex(context);
        return Actions.changeOrder(context, i, Math.max(i - 1, 0));
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-new.ts



/**
 * 'new' is a dialog to add something, and will not add if cancelled
 * new can also be used for mini-toolbars which just add an entity not attached to a module
 * in that case it's essential to add a contentType like
 * <ul class="sc-menu" data-toolbar='{"action":"new", "contentType": "Category"}'></ul>
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("new" /* CommandNames.new */, 'New', 'plus', false, true, {
    addParamsToLink: function (_) { return ({ mode: "new" /* CommandNames.newMode */ }); },
    dialog: function (_) { return "edit" /* CommandNames.edit */; },
    showCondition: function (context) {
        // don't provide new if type unknown or on the header-item
        return !!context.button.command.params.contentType || SharedLogic.isList(context);
    },
    code: function (context, event) {
        var params = context.button.command.params;
        // todo - should refactor this to be a toolbarManager.contentBlock command
        params.index = CmdParHlp.getIndex(params) + 1;
        // if we have an EntityId, this means that it picked up id/guid from the current item,
        // so we must reset both EntityId and EntityGuid
        // note that we don't reset this if entityId = 0, because that usually means the guid was preset on purpose
        if (params.entityId && params.entityId !== 0) {
            delete params.entityId;
            delete params.entityGuid;
        }
        // if we have useModuleList AND contentType then something is inconsistent
        // since useModuleList doesn't need to specify the contentType
        // this means that it's a custom new button, and useModuleList is wrong.
        if (params.useModuleList && params.contentType)
            delete params.useModuleList;
        // done
        return CmsEngine.openDialog(context, event);
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-publish.ts



/**
 * todo: shouldn't be available if changes are not allowed
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("publish" /* CommandNames.publish */, 'Unpublished', 'eye-off', false, false, {
    showCondition: function (context) {
        return context.button.command.params.isPublished === false;
    },
    disabled: function (context) {
        return !context.instance.allowPublish || context.button.command.params.isPublished !== false;
    },
    code: function (context, event) {
        var params = context.button.command.params;
        return new Promise(function (resolve, reject) {
            if (params.isPublished) {
                alert(translate('Toolbar.AlreadyPublished'));
                return resolve();
            }
            // if we have an entity-id, publish based on that
            if (params.entityId)
                return Actions.publishId(context, params.entityId);
            var i = CmdParHlp.getIndex(context);
            var part = i === -1 ? 'listcontent' : 'content';
            var index = i === -1 ? 0 : i;
            return Actions.publish(context, part, index);
        });
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-remove.ts



/**
 * remove an item from the placeholder (usually for lists)
 *
 * import this module to commands.ts
 * @internal
 */
Commands.add("remove" /* CommandNames.remove */, 'Remove', 'minus-circled', false, true, {
    showCondition: function (context) { return SharedLogic.isList(context); },
    code: function (context) {
        return new Promise(function (resolve, reject) {
            if (confirm(translate('Toolbar.ConfirmRemove')))
                return Actions.removeFromList(context);
            return resolve();
        });
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-replace.ts


/**
 * import this module to commands.ts
 * @internal
 */
Commands.add("replace" /* CommandNames.replace */, 'Replace', 'replace', false, true, {
    showCondition: function (context) {
        return SharedLogic.isReferencedItem(context);
    },
    configureLinkGenerator: function (context, linkGenerator) {
        // default case is ContentBlock - in which case it doesn't need to redefine the items
        if (!SharedLogic.isFieldList(context))
            return;
        // fieldList - redefine the items
        var params = context.button.command.params;
        linkGenerator.items = [{
                Add: false,
                Index: CmdParHlp.getIndex(params),
                Parent: params.parent,
                Field: params.fields,
            }];
    },
});

;// CONCATENATED MODULE: ./src/commands/command/command-template.ts

/**
 * import this module to commands.ts
 * @internal
 */
var command_template_cmd = Command.build("template" /* CommandNames.template */, 'Develop', 'code', true, false, {
    newWindow: function (_) { return true; },
    dialog: function (_) { return 'develop'; },
    showCondition: function (context) { return !!context.user.CanDevelop; },
    configureLinkGenerator: function (context, linkGenerator) {
        var cb = context.contentBlock;
        var identifier = { EntityId: cb.templateId };
        if (cb.templatePath)
            identifier.Path = cb.templatePath;
        if (cb.edition)
            identifier.Edition = cb.edition;
        linkGenerator.items = [identifier];
    },
    addParamsToLink: function (ctx) { return ({ isshared: ctx.contentBlock.TemplateIsShared }); },
});
Commands.addCommand(command_template_cmd);
Commands.addCommand(Command.clone(command_template_cmd, "template-develop" /* CommandNames.template_old_develop */));

;// CONCATENATED MODULE: ./src/commands/command/command-query.ts

/**
 * import this module to commands.ts
 * @internal
 */
var command_query_cmd = Command.build("query" /* CommandNames.query */, 'QueryEdit', 'filter', true, false, {
    dialog: function (_) { return 'pipeline-designer'; },
    addParamsToLink: function (ctx) { return ({ pipelineId: ctx.contentBlock.queryId }); },
    newWindow: function (_) { return true; },
    disabled: function (ctx) { return ctx.app.settingsId === null || !ctx.contentBlock.queryId; },
    title: function (ctx) { return "Toolbar.QueryEdit".concat(ctx.contentBlock.queryId === null ? 'Disabled' : ''); },
    showCondition: function (ctx) { return !!ctx.user.CanDevelop && !ctx.app.isContent; },
    // if it doesn't have a query, make it less strong
    dynamicClasses: function (ctx) { return ctx.contentBlock.queryId ? '' : 'empty'; },
});
Commands.addCommand(command_query_cmd);
Commands.addCommand(Command.clone(command_query_cmd, "template-query" /* CommandNames.query_old_templateQuery */));

;// CONCATENATED MODULE: ./src/commands/command/command-view.ts

/**
 * import this module to commands.ts
 * @internal
 */
var command_view_cmd = Command.build("view" /* CommandNames.view */, 'TemplateSettings', 'sliders', true, false, {
    dialog: function (_) { return 'edit'; },
    showCondition: function (ctx) { return !!ctx.user.CanDevelop && !ctx.app.isContent; },
    configureLinkGenerator: function (ctx, linkGen) {
        linkGen.items = [{ EntityId: ctx.contentBlock.templateId }];
    },
});
Commands.addCommand(command_view_cmd);
Commands.addCommand(Command.clone(command_view_cmd, "template-settings" /* CommandNames.view_old_templateSettings */));

;// CONCATENATED MODULE: ./src/commands/command/command-system.ts

/**
 * import this module to commands.ts
 * @internal
 */
var command_system_cmd = Command.build("system" /* CommandNames.system */, 'Zone', 'manage', true, false, {
    dialog: function (_) { return "zone" /* CommandNames.system_old_zone */; },
    showCondition: function (context) {
        return !!context.user.CanAdmin;
    },
});
Commands.addCommand(command_system_cmd);
Commands.addCommand(Command.clone(command_system_cmd, "zone" /* CommandNames.system_old_zone */));

;// CONCATENATED MODULE: ./src/commands/command/content-list-action-params.ts
/**
 * params for getAndReload WebAPI
 * @internal
 */
var ContentListActionParams = /** @class */ (function () {
    function ContentListActionParams() {
    }
    return ContentListActionParams;
}());


;// CONCATENATED MODULE: ./src/commands/command/workflow-commands.ts
/**
 * @internal
 */
var WorkflowCommands = {
    /** Special command: 'all' is a catch-all for workflows that should run on every command */
    all: 'all',
    /** Special Command: 'refresh' is usually run inside other commands after execution */
    refresh: 'refresh',
};

;// CONCATENATED MODULE: ./src/commands/command/index.ts
// TODO
// tslint:disable: align
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
/** @internal */ 
// Workflow
/** @internal */ 
// Params
/** @internal */ 

;// CONCATENATED MODULE: ./src/cms/run-params-helpers.ts
var run_params_helpers_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var run_params_helpers_assign = (undefined && undefined.__assign) || function () {
    run_params_helpers_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return run_params_helpers_assign.apply(this, arguments);
};




/**
 * Helper class to process parameters given to the Cms.Run statement
 * Important because certain params may sometimes be full objects, and sometimes just a name.
 * In addition, even if we have more than the name, we must ensure that defaults are also included
 *
 * @internal
 */
var RunParamsHelpers = /** @class */ (function (_super) {
    run_params_helpers_extends(RunParamsHelpers, _super);
    function RunParamsHelpers(parentLog) {
        return _super.call(this, 'Cmd.RunPrm', parentLog, 'start') || this;
    }
    /**
     * name or settings adapter to settings
     * @param nameOrSettings
     * @returns settings
     */
    RunParamsHelpers.prototype.getParamsFromNameOrParams = function (nameOrSettings) {
        var cl = this.log.call('getParamsFromNameOrParams', "".concat(nameOrSettings));
        // check if nameOrString is name (string) or object (settings)
        var nameIsString = typeof nameOrSettings === 'string';
        cl.add("adapting settings; name string: ".concat(nameIsString, "; name = ").concat(nameOrSettings));
        var result = (nameIsString
            ? { action: nameOrSettings }
            : nameOrSettings);
        return cl.return(result);
    };
    /**
     * Take a settings-name or partial settings object,
     * and return a full settings object with all defaults from
     * the command definition
     * @param params
     */
    RunParamsHelpers.prototype.expandParamsWithDefaults = function (params) {
        var cl = this.log.call('expandParamsWithDefaults');
        var name = params.action;
        cl.add("will add defaults for ".concat(name, " from buttonConfig"));
        var defaults = Commands.singleton().get(name).buttonDefaults;
        cl.data('defaults to merge', defaults);
        // TODO: 2dm - suspicious cast
        // merge conf & settings, but...?
        return cl.return(run_params_helpers_assign(run_params_helpers_assign({}, defaults), params));
    };
    // ----- Static Helpers -----
    /**
     * Checks if the run params are complete, as would be used in the $2sxc.cms.run
     * @internal
     */
    RunParamsHelpers.is$sxcRunParams = function (o) {
        var t = o;
        return (t.tag != null || (t.context != null && (context_identifier_ContextIdentifier.is(t.context) || sxc_Sxc.is(t.context)))) &&
            RunParamsHelpers.isRunParamsInstance(t);
    };
    /**
     * Checks if it's at least an instance run param - having at least `action` or `params`
     * @internal
     */
    RunParamsHelpers.isRunParamsInstance = function (maybeRunParams) {
        var typed = maybeRunParams;
        return (typed.action != null || typed.params != null);
    };
    /**
     * @internal
     */
    RunParamsHelpers.ensureRunParamsInstanceOrError = function (runParams) {
        if (!RunParamsHelpers.isRunParamsInstance(runParams))
            throw "".concat(run_params_helpers_errPrefix, " with at least ").concat(runContextInstanceMinimalRequirements);
        if (runParams.context)
            throw "".concat(run_params_helpers_errPrefix, " without 'context' since it already provides the context");
    };
    return RunParamsHelpers;
}(HasLog));

var runContextInstanceMinimalRequirements = "'action' and/or 'params'";
var run_params_helpers_errPrefix = 'sxc instance run() expects runParams';

;// CONCATENATED MODULE: ./src/quick-dialog/quick-dialog-container.ts
var quick_dialog_container_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * this is a dialog manager which is in charge of all quick-dialoges
 * it always has a reference to the latest dialog created by a.ny module instance
 * @internal
 */
var containerClass = 'inpage-frame-wrapper';
var iframeClass = 'inpage-frame';
var iframeTag = 'iframe';
var containerTemplate = "<div class=\"".concat(containerClass, "\"><div class=\"").concat(iframeClass, "\"></div></div>");
var resizeInterval = 200;
/**
 * @internal
 */
var QuickDialogContainer = /** @class */ (function (_super) {
    quick_dialog_container_extends(QuickDialogContainer, _super);
    function QuickDialogContainer(quickDialog) {
        var _this = _super.call(this, 'QDl.Contnr', quickDialog.log) || this;
        _this.isFullscreen = false;
        _this.resizeWatcher = null;
        return _this;
    }
    /**
     * get the current container
     * @returns html element of the div
     */
    QuickDialogContainer.prototype.getOrCreate = function () {
        var container = document.querySelector(".".concat(containerClass));
        return container !== null && container !== void 0 ? container : this.buildContainerAndIFrame();
    };
    /**
     * build the container in the dom w/iframe for re-use
     * @returns dom-object
     */
    QuickDialogContainer.prototype.buildContainerAndIFrame = function () {
        var callLog = this.log.call('buildContainerAndIFrame');
        var container = NoJQ.domFromString(containerTemplate)[0];
        if (document.querySelectorAll('#personaBar-iframe').length > 0)
            container.classList.add('persona-bar-visible');
        var newIFrame = document.createElement(iframeTag);
        var extendedIFrame = convertIFrameToQuickDialog(newIFrame, this);
        container.querySelector(".".concat(iframeClass)).append(extendedIFrame);
        document.body.append(container);
        this.watchForResize(container);
        return callLog.return(container, 'ok');
    };
    /**
     * find the iframe which hosts the dialog
     * @param container: - html-container
     * @returns iframe object
     */
    QuickDialogContainer.prototype.getIFrame = function (container) {
        if (!container)
            container = this.getOrCreate();
        return container.querySelector(iframeTag);
    };
    /**
     * set container css for size
     */
    QuickDialogContainer.prototype.setSize = function (fullScreen) {
        var cl = this.log.call('setSize');
        var container = this.getOrCreate();
        // set container height
        container.style.minHeight = fullScreen ? '100%' : '225px';
        this.isFullscreen = fullScreen;
        cl.done();
    };
    /**
     * create watcher which monitors the iframe size and adjusts the container as needed
     */
    QuickDialogContainer.prototype.watchForResize = function (container) {
        var _this = this;
        // only add a timer if not already running
        if (this.resizeWatcher)
            return;
        var callLog = this.log.call('watchForResize');
        // if (!resizeWatcher)
        this.resizeWatcher = window.setInterval(function () {
            try {
                var frm = _this.getIFrame(container);
                if (!frm) {
                    callLog.onlyAddIfNew('no iframe');
                    return;
                }
                var height = frm.contentDocument.body.offsetHeight;
                if (frm.previousHeight === height) {
                    callLog.onlyAddIfNew('no height change');
                    return;
                }
                frm.style.minHeight = container.style.minHeight;
                frm.style.height = height + 'px';
                frm.previousHeight = height;
                if (_this.isFullscreen) {
                    frm.style.height = '100%';
                    frm.style.position = 'absolute';
                }
                callLog.onlyAddIfNew('changed to ' + height);
            }
            catch (e) {
                callLog.add('error', e);
            }
        }, resizeInterval);
        callLog.return(null, 'watcher added');
    };
    return QuickDialogContainer;
}(HasLog));

function convertIFrameToQuickDialog(iFrame, parent) {
    var callLog = parent.log.call('build');
    callLog.data('prototype', IFrameBridge.prototype);
    var iFrameExtended = iFrame;
    iFrameExtended.bridge = new IFrameBridge(parent);
    callLog.data('extensions', iFrameExtended.bridge);
    return callLog.return(iFrameExtended);
}

;// CONCATENATED MODULE: ./src/manage/session-state-handler.ts
var session_state_handler_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * This object helps persist / load / reset
 * a setting in the session-state
 * @internal
 */
// General notes
// - must always use try-catch because in certain environments like iFrame prohibit access to sessionStorage
var SessionStateHandler = /** @class */ (function (_super) {
    session_state_handler_extends(SessionStateHandler, _super);
    function SessionStateHandler(key) {
        var _this = _super.call(this, 'Ses.State') || this;
        _this.key = key;
        insights_Insights.add('system', 'session-state ' + key, _this.log);
        return _this;
    }
    SessionStateHandler.prototype.set = function (value) {
        this.log.add("state '".concat(this.key, "' set(").concat(value, ")"));
        try {
            sessionStorage.setItem(this.key, value);
        }
        catch ( /* ignore */_a) { /* ignore */ }
    };
    SessionStateHandler.prototype.remove = function () {
        this.log.add("state '".concat(this.key, "' remove()"));
        try {
            sessionStorage.removeItem(this.key);
        }
        catch ( /* ignore */_a) { /* ignore */ }
    };
    SessionStateHandler.prototype.get = function () {
        var result = getItemValue(this.key);
        this.log.add("state '".concat(this.key, "' get() = '").concat(result, "'"));
        try {
            return result;
        }
        catch ( /* ignore */_a) { /* ignore */ }
    };
    return SessionStateHandler;
}(HasLog));

function getItemValue(key) {
    try {
        var value = sessionStorage.getItem(key);
        return JSON.parse(value);
    }
    catch (_a) {
        return null;
    }
}

;// CONCATENATED MODULE: ./src/quick-dialog/state.ts

/**
 * @internal
 */
var state_cbId = new SessionStateHandler('dia-cbid');
/**
 * @internal
 */
var cancelled = new SessionStateHandler('cancelled-dialog');

;// CONCATENATED MODULE: ./src/quick-dialog/quick-dialog.ts
var quick_dialog_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var diagShowClass = 'dia-select';
/** dialog manager - the currently active dialog object */
var current = null;
/**
 * this is a dialog manager which is in charge of all quick-dialogues
 * it always has a reference to the latest dialog created by a.ny module instance
 * @internal
 */
var QuickDialog = /** @class */ (function (_super) {
    quick_dialog_extends(QuickDialog, _super);
    function QuickDialog() {
        var _this = _super.call(this, 'Qdl.Managr') || this;
        insights_Insights.add('quick-dialog', 'manager', _this.log);
        _this.container = new QuickDialogContainer(_this);
        return _this;
    }
    /** Singleton */
    QuickDialog.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new QuickDialog());
    };
    /**
     * Determines if a.ny dialog is currently showing
     */
    QuickDialog.prototype.isVisible = function () {
        return current != null;
    };
    /**
     * toggle visibility
     * @param {boolean} [show] true/false optional
     */
    QuickDialog.prototype.setVisible = function (show) {
        var cl = this.log.call('setVisible');
        var cont = this.container.getOrCreate();
        cont.classList.toggle(diagShowClass, show);
        this.rememberDialogState(this.container.getIFrame(cont), show);
        current = show ? this.container.getIFrame() : null;
        cl.done();
    };
    /**
     * show / reset the current iframe to use new url and callback
     * @param {ContextComplete} context object
     * @param url - url to show
     * @param {function()} closeCallback - callback event
     * @param {boolean} isFullscreen - if it should open full screen
     * @param [dialogName] - optional name of dialog, to check if it's already open
     * @returns {Promise<boolean>}
     */
    QuickDialog.prototype.showOrToggleFromToolbar = function (context, url, isFullscreen, dialogName) {
        var cl = this.log.call('showOrToggleFromToolbar', "ctx, url: '".concat(url, "', isFullScreen:").concat(isFullscreen, ", name:'").concat(dialogName, "'"));
        this.container.setSize(isFullscreen);
        var iFrame = this.container.getIFrame();
        // in case it's a toggle
        if (this.isVisible()) {
            cl.add('is already visible');
            // check if we're just toggling the current, or will show a new one afterwards
            var isForSame = dialogName && current
                && current.bridge.isConfiguredFor(context.sxc.cacheKey, dialogName);
            var togglePromise = isForSame ? this.promise : null;
            this.cancel(current.bridge);
            // just a hide this, return the old promise
            if (togglePromise)
                return cl.return(togglePromise, 'just toggle off');
        }
        var dialogUrl = this.setUrlToQuickDialog(url);
        iFrame.bridge.setup(context.sxc, dialogName);
        iFrame.setAttribute('src', dialogUrl);
        // if the window had already been loaded, re-init
        if (iFrame.contentWindow && iFrame.contentWindow.reboot)
            iFrame.contentWindow.reboot();
        // make sure it's visible'
        this.setVisible(true);
        return cl.return(this.promiseRestart(), 'restart');
    };
    QuickDialog.prototype.cancel = function (bridge) {
        var callLog = this.log.call('cancel');
        this.setVisible(false);
        cancelled.set('true');
        this.resolvePromise(bridge.changed);
        callLog.done();
    };
    QuickDialog.prototype.rememberDialogState = function (iframe, state) {
        var callLog = this.log.call('rememberDialogState');
        callLog.add("qDialog persistDia(..., ".concat(state, ")"));
        if (state) {
            var cbId = iframe.bridge
                .getContext()
                .contentBlockReference.id.toString();
            callLog.add("contentBlockId: ".concat(cbId, ")"));
            return callLog.return(state_cbId.set(cbId));
        }
        return callLog.return(state_cbId.remove(), 'remove');
    };
    QuickDialog.prototype.promiseRestart = function () {
        var _this = this;
        this.promise = new Promise(function (resolve) { return (_this.resolvePromise = resolve); });
        return this.promise;
    };
    //#endregion
    /**
     * rewrite the url to fit the quick-dialog situation
     * optionally with a live-compiled version from ng-serve
     * @param url - original url pointing to the default dialog
     * @returns {string} new url pointing to quick dialog
     */
    QuickDialog.prototype.setUrlToQuickDialog = function (url) {
        var cl = this.log.call('setUrlToQuickDialog', url);
        // change default url-schema from the primary angular-app to the quick-dialog
        url = url.replace(C.DialogPaths.eavUi, C.DialogPaths.quickDialog);
        return cl.return(url);
    };
    return QuickDialog;
}(HasLog));


;// CONCATENATED MODULE: ./src/manage/ng-dialog-params.ts
/**
 * This is for building/serializing the main url params when opening a dialog.
 * It does not contain the "params" / "items" part
 * @internal
 */
var NgUrlValuesWithoutParams = /** @class */ (function () {
    // 2022-06-16 2dm disabled, believe it's not used any more
    /** features of App - this is to tell the UI it can show advanced features of an app like permissions, API, REST etc. */
    // readonly fa: boolean;
    // #reduceEnvVars
    /** request verification token header name */
    // readonly rvth: string;
    // #reduceEnvVars
    /** request verification token value */
    // readonly rvt: string;
    function NgUrlValuesWithoutParams(context, partOfPage) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var $2sxc = window.$2sxc;
        // #CustomContext
        var ctx = (_a = context.sxc) === null || _a === void 0 ? void 0 : _a.ctx;
        if ((ctx === null || ctx === void 0 ? void 0 : ctx.complete) === true) {
            this.zoneId = ctx.zoneId;
            this.appId = ctx.appId;
            // #reduceEnvVars
            // if (ctx.pageId != null) this.tid = ctx.pageId;
            if (ctx.moduleId != null)
                this.mid = ctx.moduleId;
            var cbid = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.blockId) !== null && _b !== void 0 ? _b : this.mid;
            if (cbid != null && cbid)
                this.cbid = cbid;
        }
        else {
            this.zoneId = (_c = ctx === null || ctx === void 0 ? void 0 : ctx.zoneId) !== null && _c !== void 0 ? _c : context.app.zoneId;
            this.appId = (_d = ctx === null || ctx === void 0 ? void 0 : ctx.appId) !== null && _d !== void 0 ? _d : context.app.id;
            // #reduceEnvVars
            // this.tid = ctx?.pageId ?? context.page.id;
            this.mid = (_e = ctx === null || ctx === void 0 ? void 0 : ctx.moduleId) !== null && _e !== void 0 ? _e : context.instance.id;
            this.cbid = (_f = ctx === null || ctx === void 0 ? void 0 : ctx.blockId) !== null && _f !== void 0 ? _f : context.contentBlockReference.id;
        }
        // #reduceEnvVars
        // this.api = $2sxc.env.api();
        this.partOfPage = partOfPage;
        if (partOfPage)
            this.publishing = context.contentBlockReference.publishingMode;
        // todo= probably move the user into the dashboard info
        // 2021-01-19 2dm - should now not be used any more
        // this.user = ContextOfUser.fromContext(context);
        // TODO: #paramCleanUp - approot is probably not used anymore. verify and remove
        // #reduceEnvVars
        // this.approot = context.app.appPath || null; // this is the only value which doesn't have a slash by default. note that the app-root doesn't exist when opening "manage-app"
        if ((_j = (_h = (_g = context === null || context === void 0 ? void 0 : context.button) === null || _g === void 0 ? void 0 : _g.command) === null || _h === void 0 ? void 0 : _h.params) === null || _j === void 0 ? void 0 : _j.apps)
            this.apps = context.button.command.params.apps;
        // TODO: #paramCleanUp - fa is probably not used anymore. verify and remove
        // #reduceEnvVars
        // this.fa = !context.app.isContent;
        // this.rvth = $2sxc.env.rvtHeader();
        // this.rvt = $2sxc.env.rvt();
    }
    return NgUrlValuesWithoutParams;
}());


;// CONCATENATED MODULE: ./src/commands/command-link-generator.ts
var command_link_generator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var command_link_generator_assign = (undefined && undefined.__assign) || function () {
    command_link_generator_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return command_link_generator_assign.apply(this, arguments);
};






// 2022-06-16 2dm experimental
var urlMode2 = false;
/**
 * This is responsible for taking a context with command and everything
 * then building the link for opening the correct dialogs
 * @internal
 */
var CommandLinkGenerator = /** @class */ (function (_super) {
    command_link_generator_extends(CommandLinkGenerator, _super);
    function CommandLinkGenerator(context, parentLog) {
        var _this = _super.call(this, 'Cmd.LnkGen', parentLog) || this;
        _this.context = context;
        var cl = _this.log.call('constructor');
        var button = new ButtonSafe(context.button, context);
        var command = button.action();
        // Initialize Items - use predefined or create empty array
        _this.items = command.params.items || [];
        cl.data('items', _this.items);
        // initialize params
        _this.urlParams = button.addParamsToLink();
        var dialog = button.dialog();
        // note: this corrects how the variable to name the dialog changed in the history of 2sxc from action to dialog
        _this.urlParams = command_link_generator_assign({ dialog: dialog || command.name }, _this.urlParams);
        cl.data('urlParmas', _this.urlParams);
        // get isDebug url Parameter
        _this.debugUrlParam = window.$2sxc.urlParams.get('debug') ? '&debug=true' : '';
        _this.buildItemsList(button);
        // if the command has own configuration stuff, do that now
        if (context.button.configureLinkGenerator)
            context.button.configureLinkGenerator(context, _this);
        cl.done();
        return _this;
    }
    /**
     * Generate items for editing/changing or simple item depending on the scenario.
     */
    CommandLinkGenerator.prototype.buildItemsList = function (button) {
        if (button.action().params.useModuleList)
            this.addContentGroupItems(true);
        else if (button.action().params.parent)
            this.addItemInList();
        else
            this.addItem();
    };
    /**
     * build the link, combining specific params with global ones and put all in the url
     */
    CommandLinkGenerator.prototype.getLink = function () {
        var context = this.context;
        var button = new ButtonSafe(context.button, context);
        var params = button.action().params;
        var urlItems = this.urlParams;
        // steps for all actions: prefill, serialize, open-dialog
        // when doing new, there may be a prefill in the link to initialize the new item
        if (params.prefill)
            for (var i = 0; i < this.items.length; i++)
                this.items[i].Prefill = params.prefill;
        delete urlItems.prefill; // added 2020-03-11, seemed strange that it's not removed
        urlItems.items = JSON.stringify(this.items); // Serialize/json-ify the complex items-list
        // clone the params and adjust parts based on partOfPage settings...
        var partOfPage = button.partOfPage();
        var ngDialogParams = new NgUrlValuesWithoutParams(context, partOfPage);
        // initialize root url to dialog
        var rootUrl = this.getDialogUrl(context);
        var items2 = '';
        if (urlMode2 && this.items) {
            try {
                items2 = '&' + window.$2sxc.urlParams.toUrl({ i2: this.items });
                // console.log('items2', items2);
            }
            catch (e) { /* ignore */ }
        }
        return "".concat(rootUrl, "#").concat(NoJQ.param(ngDialogParams).replace(/%2F/g, '/'), "&").concat(NoJQ.param(urlItems)).concat(this.debugUrlParam)
            + items2;
    };
    /**
     * Determine the url to open a dialog, based on the settings which UI version to use
     */
    CommandLinkGenerator.prototype.getDialogUrl = function (context) {
        var env = window.$2sxc.env;
        var customParams = env.dialogQuery();
        if (customParams && !customParams.startsWith('&'))
            customParams = '&' + customParams;
        return urlClean("".concat(env.uiRoot()).concat(C.DialogPaths.eavUi)) + "?pageId=".concat(env.page(), "&sxcver=").concat(context.instance.sxcVersion).concat(customParams);
    };
    CommandLinkGenerator.prototype.addItem = function () {
        var item = {};
        var params = this.context.button.command.params;
        // two ways to name the content-type-name this, v 7.2+ and older
        var ct = params.contentType || params.attributeSetName;
        if (params.entityId)
            item.EntityId = params.entityId;
        if (ct)
            item.ContentTypeName = ct;
        // v12.11 - also support cases where the template includes an edition
        // 2022-05-18 2dm - disable this, seems like old incomplete code
        // if (params )
        // only add if there was stuff to add
        if (item.EntityId || item.ContentTypeName) {
            this.items.push(item);
            // 2022-05-18 2dm - disable this, seems like old code, title shouldn't be used any more
            // this.items.push({ ...item, Title: translate(this.findTranslationKey(this.findPartName(true))) });
        }
    };
    /**
     * this will tell the command to edit a item from the sorted list in the group,
     * optionally together with the presentation item
     */
    CommandLinkGenerator.prototype.addContentGroupItems = function (withPresentation) {
        var _this = this;
        var cl = this.log.call('addContentGroupItems', "".concat(withPresentation));
        // const params = this.context.button.command.params;
        var i = CmdParHlp.getIndex(this.context);
        var isContentAndNotHeader = (i !== -1);
        var index = isContentAndNotHeader ? i : 0;
        var isAdd = this.context.button.command.name === 'new';
        var groupId = this.context.contentBlock.contentGroupId;
        var fields = [this.findPartName(true)];
        if (withPresentation)
            fields.push(this.findPartName(false));
        fields.map(function (f) { return _this.addContentGroupItem(groupId, index, f, isAdd); });
        cl.done();
    };
    /**
     * this adds an item of the content-group, based on the group GUID and the sequence number
     */
    CommandLinkGenerator.prototype.addContentGroupItem = function (guid, index, part, isAdd) {
        var cl = this.log.call('addContentGroupItem', "".concat(guid, ", ").concat(index, ", ").concat(part, ", ").concat(isAdd));
        this.items.push({
            Add: isAdd,
            Index: index,
            Parent: guid,
            Field: part.toLocaleLowerCase(),
        });
        cl.done();
    };
    /**
     * EXPERIMENTAL in 10.27, if a parent is specified, use that
     * this will tell the command to edit a item which also belongs to a list
     * this is relevant when adding new items
     */
    CommandLinkGenerator.prototype.addItemInList = function () {
        var _this = this;
        var params = this.context.button.command.params;
        var index = CmdParHlp.getIndex(params);
        var isAdd = this.context.button.command.name === 'new';
        var groupId = params.parent;
        // New in 10.27 - if params has a field, use that
        if (params.fields)
            params.fields.split(',').map(function (f) { return _this.items.push({
                EntityId: isAdd ? 0 : params.entityId,
                Field: f,
                Parent: groupId,
                Add: isAdd,
                Index: index,
            }); });
    };
    /**
     * find the part name for both the API to give the right item (when using groups) and for i18n
     */
    CommandLinkGenerator.prototype.findPartName = function (content) {
        var isContentAndNotHeader = (CmdParHlp.getIndex(this.context) !== -1);
        return (isContentAndNotHeader ? '' : 'List') + (content ? 'Content' : 'Presentation');
    };
    return CommandLinkGenerator;
}(HasLog));


;// CONCATENATED MODULE: ./src/commands/engine/cms-engine.ts
var cms_engine_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var cms_engine_assign = (undefined && undefined.__assign) || function () {
    cms_engine_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return cms_engine_assign.apply(this, arguments);
};











/**
 * The CMS engine is global, and needs the context to work.
 * @internal
 */
var CmsEngine = /** @class */ (function (_super) {
    cms_engine_extends(CmsEngine, _super);
    function CmsEngine(parentLog) {
        var _this = _super.call(this, 'Cmd.Exec', parentLog, 'start') || this;
        _this.runParamsHelper = new RunParamsHelpers(_this.log);
        return _this;
    }
    CmsEngine.prototype.detectParamsAndRun = function (context, nameOrParams, eventOrParams, event) {
        var cl = this.log.call('detectParamsAndRun', "".concat(arguments.length, " params"));
        var cmdParams;
        var thirdParamIsEvent = !event && eventOrParams && typeof eventOrParams.altKey !== 'undefined';
        cl.add("might cycle parameters. third is event=".concat(thirdParamIsEvent));
        if (thirdParamIsEvent) {
            // no event param, but settings contains the event-object
            cl.add('cycling params; event missing & eventOrSettings seems to be an event; settings assumed empty');
            event = eventOrParams; // move it to the correct variable
            cmdParams = this.runParamsHelper.getParamsFromNameOrParams(nameOrParams);
        }
        else {
            cmdParams = cms_engine_assign(cms_engine_assign({}, (eventOrParams || {})), this.runParamsHelper.getParamsFromNameOrParams(nameOrParams));
        }
        // ensure we have the right event despite browser differences
        event = event || window.event;
        var result = this.run(context, cmdParams, event);
        return cl.return(result);
    };
    /**
     * run a command
     * this method expects a clear order of parameters
     * @param context
     * @param settings
     * @param event
     */
    CmsEngine.prototype.run = function (context, nameOrParams, event, wipParamsWithWorkflow) {
        var cl = this.log.call('run<T>');
        var cmdParams = this.runParamsHelper.getParamsFromNameOrParams(nameOrParams);
        cmdParams = this.runParamsHelper.expandParamsWithDefaults(cmdParams);
        var origEvent = event;
        var name = cmdParams.action;
        // 2dm 2022-07-05 #badContentTypeExtractAndRefill - we seem to extract it, just to put it back on the ButtonCommand
        // const contentType = cmdParams.contentType;
        // cl.add(`run command '${name}' for type ${contentType}`);
        cl.add("run command '".concat(name, "'"));
        // Toolbar API v2
        var btnCommand = new ButtonCommand(name, /* contentType, */ cmdParams);
        var newButtonConfig = new Button(btnCommand, btnCommand.name);
        // merge conf & settings, but settings has higher priority
        var button = cms_engine_assign(cms_engine_assign({}, newButtonConfig), InPageButtonJson.toButton(cmdParams));
        // attach to context for inner calls which might access it
        context.button = button;
        cl.data('button', context.button);
        // New in 11.12 - find commandWorkflow of toolbar or use a dummy so the remaining code will always work
        // note: in cases where the click comes from elsewhere (like from the quick-dialog) there is no event
        // New in 12.10 - Workflow can be provided by run-call
        var wf;
        if (wipParamsWithWorkflow === null || wipParamsWithWorkflow === void 0 ? void 0 : wipParamsWithWorkflow.workflows) {
            wf = new ToolbarWorkflowManager(this.log);
            wf.add(wipParamsWithWorkflow.workflows);
        }
        else
            wf = WorkflowHelper.getWorkflow(origEvent === null || origEvent === void 0 ? void 0 : origEvent.target);
        // Attach to context, so it's available after running the command
        context.commandWorkflow = wf;
        var wrapperPromise = wf.run(new WorkflowStepCodeArguments(name, WorkflowPhases.before, context));
        // In case we don't have special code, use generic code
        var commandPromise = button.code;
        if (!commandPromise) {
            cl.add('button, no code - generating code to open standard dialog');
            commandPromise = CmsEngine.openDialog;
        }
        // get button configuration to detect if it's only a UI action (like the more-button)
        var finalPromise;
        if (new ButtonSafe(button, context).uiActionOnly()) {
            cl.add('UI command, no pre-flight to ensure content-block');
            finalPromise = wrapperPromise.then(function (wfArgs) { return WorkflowHelper.isCancelled(wfArgs)
                ? Promise.resolve(null)
                : commandPromise(context, origEvent); });
        }
        else {
            // if more than just a UI-action, then it needs to be sure the content-group is created first
            cl.add('command might change data, wrap in pre-flight to ensure content-block');
            finalPromise = wrapperPromise.then(function (wfArgs) { return WorkflowHelper.isCancelled(wfArgs)
                ? Promise.resolve(null)
                : ContentBlockEditor.singleton()
                    .prepareToAddContent(context, cmdParams.useModuleList)
                    .then(function () { return commandPromise(context, origEvent); }); });
        }
        // Attach post-command workflow
        var promiseWithAfterEffects = finalPromise.then(function (result) {
            return wf.run(new WorkflowStepCodeArguments(name, WorkflowPhases.after, null, result))
                .then(function () { return result; });
        });
        return cl.return(promiseWithAfterEffects);
    };
    /**
     * Open a new dialog of the angular-ui
     */
    CmsEngine.openDialog = function (context, event) {
        var log = new Log_Log('Cms.OpnDlg');
        insights_Insights.add('cms', 'open-dialog', log);
        // the link contains everything to open a full dialog (lots of params added)
        var link = new CommandLinkGenerator(context, log).getLink();
        var btn = new ButtonSafe(context.button, context);
        var origEvent = event || window.event;
        return new Promise(function (resolve) {
            // prepare promise for callback when the dialog closes
            // to reload the in-page view w/ajax or page reload
            var completePromise = function () {
                // call the normal promise-resolve so the `.then` will be continued
                resolve(context);
                // reload the UI as specified
                renderer.reloadAndReInitialize(context);
            };
            // check if inline window (quick-dialog)
            if (btn.inlineWindow()) {
                // test if it should be full screen (value or resolve-function)
                QuickDialog.singleton()
                    .showOrToggleFromToolbar(context, link, btn.fullScreen(), btn.dialog())
                    .then(function (isChanged) { if (isChanged)
                    completePromise(); });
            }
            else {
                // else it's a normal pop-up dialog
                var isNewWindow = btn.newWindow();
                // check if new-window
                if (isNewWindow || (origEvent === null || origEvent === void 0 ? void 0 : origEvent.shiftKey)) {
                    // resolve promise, as the window won't report when closed
                    resolve(context);
                    window.open(link);
                }
                else {
                    window.$2sxc.totalPopup.open(link, completePromise);
                }
            }
        });
    };
    return CmsEngine;
}(HasLog));


;// CONCATENATED MODULE: ./src/commands/index.ts










;// CONCATENATED MODULE: ./src/contentBlock/render.ts
var render_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var render_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};








/**
 * This is the rendering compontent, responsible to update the page when something changes.
 * Depending on the feature-set it will use ajax or not
 * @internal
 */
var RendererGlobal = /** @class */ (function (_super) {
    render_extends(RendererGlobal, _super);
    function RendererGlobal() {
        var _this = _super.call(this, 'Rnd.Rndrer') || this;
        insights_Insights.add('system', 'renderer', _this.log);
        return _this;
    }
    /**
     * Show a message where the content of a module should be - usually as placeholder till something else happens
     * @param {ContextComplete} context
     * @param newContent
     * @returns {} nothing
     */
    RendererGlobal.prototype.showMessage = function (context, newContent) {
        SxcTools.getTag(context.sxc).innerHTML = newContent;
    };
    /**
     * this one assumes a replace / change has already happened, but now must be finalized...
     * @param {ContextComplete} context
     * @param {boolean} forceAjax
     * @param {boolean} preview
     */
    RendererGlobal.prototype.reloadAndReInitialize = function (context, forceAjax, preview) {
        var _this = this;
        var _a;
        var cl = this.log.call('reloadAndReInitialize', "..., forceAjax: ".concat(forceAjax, ", preview: ").concat(preview), null, { context: context });
        // get workflow engine or a dummy engine
        var wf = (_a = context.commandWorkflow) !== null && _a !== void 0 ? _a : WorkflowHelper.getDummyManager();
        var promiseChain = wf.run(new WorkflowStepCodeArguments(WorkflowCommands.refresh, WorkflowPhases.before, context));
        // 2021-02-21 2dm New in 11.12 enable toolbar to not reload in a SPA scenario
        var finalPromise = promiseChain.then(function (wfArgs) {
            if (WorkflowHelper.isCancelled(wfArgs)) {
                cl.add('Workflow return false, will cancel and not refresh.');
                return Promise.resolve();
            }
            // if ajax is not supported, we must reload the whole page
            if (!forceAjax && !context.app.supportsAjax) {
                cl.done('not ajax - reloading page');
                window.location.reload();
                return Promise.resolve();
            }
            cl.add('is ajax, calling ajaxReload');
            return _this.ajaxLoad(context, C.ContentBlock.UseExistingTemplate, preview)
                .then(function (result) {
                // If Evoq, tell Evoq that page has changed if it has changed (Ajax call)
                if (window.dnn_tabVersioningEnabled) { // this only exists in evoq or on new DNNs with tabVersioning
                    cl.add('system is using tabVersioning - will inform DNN');
                    try {
                        window.dnn.ContentEditorManager.triggerChangeOnPageContentEvent();
                    }
                    catch (e) { /* ignore */ }
                }
                return cl.return(result);
            })
                .catch(function (error) { return console.log('Error in reloadAndReInitialize', error); });
        });
        return finalPromise;
    };
    /**
     * ajax-call, then replace
     * @param {ContextComplete} context
     * @param {number} alternateTemplateId
     * @param {boolean} justPreview
     */
    RendererGlobal.prototype.ajaxLoad = function (context, alternateTemplateId, justPreview) {
        var _this = this;
        var cl = this.log.call('ajaxLoad');
        cl.add('starting promise chain');
        return ContentBlockEditor.singleton().getPreviewWithTemplate(context, alternateTemplateId)
            .then(function (result) {
            cl.add("get preview done, let's replace the content");
            _this.replaceContentBlock(context, result, justPreview);
        })
            .then(function () {
            cl.add('replace done, resetting quickE');
            QuickE.singleton().reset(); // reset quick-edit, because the config could have changed
            cl.done();
        });
    };
    /**
     * ajax update/replace the content of the content-block
     * optionally also initialize the toolbar (if not just preview)
     * @param {ContextComplete} context
     * @param newContent
     * @param {boolean} justPreview
     */
    RendererGlobal.prototype.replaceContentBlock = function (context, newContent, justPreview) {
        var cl = this.log.call('replaceContentBlock');
        try {
            try {
                var newContentObj = JSON.parse(newContent);
                var newHeadHtml = newContentObj.Resources
                    .map(function (resource) {
                    if (resource.Type === 'js') {
                        return "<script type=\"text/javascript\" src=\"".concat(resource.Url, "\"></script>");
                    }
                    if (resource.Type === 'css') {
                        return "<link rel=\"stylesheet\" href=\"".concat(resource.Url, "\">");
                    }
                })
                    .filter(function (resource) { return resource != null; })
                    .join('\n');
                var newHead = NoJQ.domFromString(newHeadHtml);
                var newDom = NoJQ.domFromString(newContentObj.Html)[0];
                NoJQ.append(document.head, newHead, false);
                // Must disable toolbar before we attach to DOM
                if (justPreview)
                    HtmlTools.disable(newDom);
                NoJQ.replaceWith(SxcTools.getTag(context.sxc), newDom, false);
                // run scripts manually to ensure proper timing
                var scripts = render_spreadArray(render_spreadArray([], newHead.filter(function (asset) { return asset.tagName.toLocaleLowerCase() === 'script'; }), true), Array.from(newDom.querySelectorAll('script')), true);
                AssetsLoader.runScripts(scripts, undefined);
            }
            catch (_a) {
                var newDom = NoJQ.domFromString(newContent)[0];
                // Must disable toolbar before we attach to DOM
                if (justPreview)
                    HtmlTools.disable(newDom);
                NoJQ.replaceWith(SxcTools.getTag(context.sxc), newDom, true);
            }
            // reset the cache, so the sxc-object is refreshed
            context.sxc.recreate(true);
        }
        catch (e) {
            console.log('Error while rendering template:', e);
        }
        cl.done();
    };
    return RendererGlobal;
}(HasLog));
/**
 * @internal
 */
var renderer = new RendererGlobal();

;// CONCATENATED MODULE: ./src/contentBlock/content-block-editor.ts
var content_block_editor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




//#region WebApi Endpoints used: 2sxc
var webApiRender = 'cms/block/render';
var webApiSave = 'cms/block/template';
//#endregion
/**
 * @internal
 */
var ContentBlockEditor = /** @class */ (function (_super) {
    content_block_editor_extends(ContentBlockEditor, _super);
    function ContentBlockEditor() {
        var _this = _super.call(this, 'Sys.CbEdit') || this;
        insights_Insights.add('system', 'cb-editor-api', _this.log);
        return _this;
    }
    /** Singleton */
    ContentBlockEditor.singleton = function () {
        var _a;
        return (_a = this._singleton) !== null && _a !== void 0 ? _a : (this._singleton = new ContentBlockEditor());
    };
    /**
     * prepare the instance so content can be added
     * this ensure the content-group has been created, which is required to add content
     * @param {ContextComplete} context
     */
    ContentBlockEditor.prototype.prepareToAddContent = function (context, useModuleList) {
        var cl = this.log.call('prepareToAddContent');
        var isCreated = context.contentBlock.isCreated;
        if (isCreated || !useModuleList)
            return cl.return(Promise.resolve());
        // persist the template
        var promise = this.updateTemplate(context, context.contentBlock.templateId, true);
        return cl.return(promise, 'ok');
    };
    /**
     * Update the template and adjust UI accordingly.
     * @param {ContextComplete} context
     * @param {number} templateId
     * @param {boolean} forceCreate
     */
    ContentBlockEditor.prototype.updateTemplateFromDia = function (context, templateId) {
        var cl = this.log.call('updateTemplateFromDia', "..., ".concat(templateId));
        var wasShowingPreview = HtmlTools.isDisabled(context.sxc);
        cl.add("wasShowingPreview: ".concat(wasShowingPreview));
        var promise = this.updateTemplate(context, templateId, false)
            .then(function () {
            // only reload on ajax, not on app as that was already re-loaded on the preview
            // necessary to show the original template again
            if (wasShowingPreview)
                renderer.reloadAndReInitialize(context);
        });
        return cl.return(promise);
    };
    /**
     * Retrieve the preview from the web-api
     * @param {ContextComplete} context
     * @param {number} templateId
     * @returns {promise} promise with the html in the result
     */
    ContentBlockEditor.prototype.getPreviewWithTemplate = function (context, templateId) {
        var cl = this.log.call('getPreviewWithTemplate', "..., ".concat(templateId));
        templateId = templateId || C.ContentBlock.UseExistingTemplate; // fallback, meaning use saved ID
        var params = {
            templateId: templateId,
            lang: context.app.currentLanguage,
            cbid: context.contentBlockReference.id,
            originalparameters: JSON.stringify(context.instance.parameters),
        };
        cl.data('params', params);
        var promise = context.sxc.webApi.fetchRaw(context.sxc.webApi.url(webApiRender, params))
            .then(function (response) { return response.text(); });
        return cl.return(promise);
    };
    /**
     * Update the template.
     */
    ContentBlockEditor.prototype.updateTemplate = function (context, templateId, forceCreate) {
        var cl = this.log.call('updateTemplate');
        var promise = this.saveTemplate(context, templateId, forceCreate)
            .then(function (data) {
            if (!data)
                return null;
            // fixes a special case where the guid is given with quotes (depends on version of angularjs) issue #532
            var newGuid = data.replace(/[\",\']/g, '');
            if (console)
                console.log("created content group {".concat(newGuid, "}"));
            return context.contentBlock.contentGroupId = newGuid;
        }).catch(function () {
            // error handling
            return alert('error - result not ok, was not able to create ContentGroup');
        });
        return cl.return(promise);
    };
    /**
     * Save the template configuration for this instance
     * @param {ContextComplete} context
     * @param {number} templateId
     * @param {boolean} [forceCreateContentGroup]
     * @returns {promise}
     */
    ContentBlockEditor.prototype.saveTemplate = function (context, templateId, forceCreateContentGroup) {
        var cl = this.log.call('saveTemplate');
        var params = {
            templateId: templateId,
            forceCreateContentGroup: forceCreateContentGroup,
            newTemplateChooserState: false,
        };
        cl.data('params', params);
        var promise = context.sxc.webApi.fetchJson(context.sxc.webApi.url(webApiSave, params), undefined, 'POST');
        return cl.return(promise);
    };
    return ContentBlockEditor;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-dialog/quick-dialog-config.ts
/**
 * @internal
 */
var QuickDialogConfig = /** @class */ (function () {
    function QuickDialogConfig() {
    }
    QuickDialogConfig.fromContext = function (context) {
        var config = new QuickDialogConfig();
        config.appId = context.app.id;
        config.isContent = context.app.isContent;
        config.isInnerContent = context.instance.id !== context.contentBlockReference.id; // if it differs, it's inner
        config.hasContent = context.app.hasContent;
        config.isList = context.contentBlock.isList;
        config.templateId = context.contentBlock.templateId;
        config.contentTypeId = context.contentBlock.contentTypeId;
        // config.user = ContextOfUser.fromContext(context);
        config.supportsAjax = context.app.supportsAjax;
        config.debug = window.$2sxc.debug.load;
        return config;
    };
    return QuickDialogConfig;
}());


;// CONCATENATED MODULE: ./src/quick-dialog/iframe-bridge.ts
var iframe_bridge_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var scrollTopOffset = 80;
var animationTime = 400;
/**
 * @internal
 */
// ReSharper disable once InconsistentNaming
var IFrameBridge = /** @class */ (function (_super) {
    iframe_bridge_extends(IFrameBridge, _super);
    function IFrameBridge(parent) {
        var _this = _super.call(this, 'QDl.IfBrig', parent.log) || this;
        _this.changed = false;
        return _this;
    }
    /**
     * get the sxc-object of this iframe
     */
    IFrameBridge.prototype.uncachedSxc = function () {
        if (!this.instanceSxc)
            throw "can't find sxc-instance of IFrame, probably it wasn't initialized yet";
        return this.instanceSxc.recreate(true);
    };
    IFrameBridge.prototype.getContext = function () {
        var cl = this.log.call('getContext');
        return cl.return(ContextComplete.findContext(this.uncachedSxc()));
    };
    IFrameBridge.prototype.getAdditionalDashboardConfig = function () {
        var cl = this.log.call('getAdditionalDashboardConfig');
        return cl.return(QuickDialogConfig.fromContext(this.getContext()));
    };
    IFrameBridge.prototype.hide = function () {
        QuickDialog.singleton().setVisible(false);
    };
    IFrameBridge.prototype.run = function (verb) {
        this.uncachedSxc().manage.run(verb);
    };
    IFrameBridge.prototype.cancel = function () { QuickDialog.singleton().cancel(this); };
    IFrameBridge.prototype.showMessage = function (message) {
        var cl = this.log.call('showMessage');
        renderer.showMessage(this.getContext(), "<p class=\"no-live-preview-available\">".concat(message, "</p>"));
        this.scrollToTarget(this.tagModule);
        cl.done();
    };
    IFrameBridge.prototype.reloadAndReInit = function () {
        var _this = this;
        this.changed = false;
        return renderer.reloadAndReInitialize(this.getContext(), true, true)
            .then(function () { return _this.scrollToTarget(_this.tagModule); })
            .then(function () { return Promise.resolve(_this.getAdditionalDashboardConfig()); });
    };
    IFrameBridge.prototype.setTemplate = function (templateId, templateName, final) {
        var _this = this;
        var cl = this.log.call('setTemplate', "tid: ".concat(templateId, ", tname: ").concat(templateName, ", final: ").concat(final));
        this.changed = true;
        var config = this.getAdditionalDashboardConfig();
        var context = this.getContext();
        var ajax = config.isContent || config.supportsAjax;
        // add msg on full-reload, as it takes longer
        // don't add this on ajax, as it will have side-effects because sometimes
        // in ajax the content won't be replaced
        if (!ajax)
            this.showMessage("refreshing <b>".concat(templateName, "</b>..."));
        var reallySave = final || !ajax;
        var promise = reallySave
            ? ContentBlockEditor.singleton().updateTemplateFromDia(context, templateId)
            : renderer.ajaxLoad(context, templateId, true);
        if (final)
            promise = promise.then(function () { return QuickDialog.singleton().setVisible(false); });
        promise = ajax
            ? promise.then(function () { return _this.scrollToTarget(_this.tagModule); })
            : promise.then(function () { return window.parent.location.reload(); });
        // return true if ajax, so upstream can update UIs
        return cl.return(promise.then(function () { return ajax; }));
    };
    /**
     * prepare the bridge with the info of the current instance
     */
    IFrameBridge.prototype.setup = function (sxc, dialogName) {
        var cl = this.log.call('setup');
        cl.data('rewire with sxc: ', sxc);
        this.changed = false;
        this.instanceSxc = sxc;
        this.tagModule = SxcTools.getTag(sxc).parentElement;
        this.sxcCacheKey = sxc.cacheKey;
        if (dialogName)
            this.dialogName = dialogName;
        cl.done();
    };
    /**
     * check if the dialog is showing for the current sxc-instance
     * @param dialogName - name of dialog
     * @returns {boolean} true if it's currently showing for this sxc-instance
     */
    IFrameBridge.prototype.isConfiguredFor = function (instanceId, dialogName) {
        var cl = this.log.call('isConfiguredFor', "id:".concat(instanceId, ", dialog:").concat(dialogName));
        var result = this.sxcCacheKey === instanceId // the iframe is showing for the current sxc
            && this.dialogName === dialogName; // the view is the same as previously
        return cl.return(result);
    };
    IFrameBridge.prototype.scrollToTarget = function (target) {
        var cl = this.log.call('scrollToTarget');
        var specs = {
            top: NoJQ.offset(target).top - scrollTopOffset,
            left: 0,
            behavior: 'smooth',
        };
        // debugger; // scrolls to wrong location. Target is wrong
        // window.scrollTo(specs);
        cl.done();
    };
    return IFrameBridge;
}(HasLog));


;// CONCATENATED MODULE: ./src/quick-dialog/index.ts






var quick_dialog_css = __webpack_require__(144);

;// CONCATENATED MODULE: ./src/toolbar/render/svg-icons.ts
var svg_icons_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

var viewBoxAttribute = 'viewBox';
// 2022-08-15 2dm experimental
// must have a bunch of try-catch to prevent failure
// This should handle special SVGs added do the page
function monitorSvgIconsInToolbar() {
    var observer = new MutationObserver(function (m) {
        // Once a change has been made, It's easiest to just find unprocessed SVGs in the document
        // ...inside the svg-wrapper span
        // const svgs = document.querySelectorAll(`${IDs.sel.scMenu} svg:not([${viewBoxAttribute}])`);
        var svgs = document.querySelectorAll("".concat(IDs.sel.scMenu, " svg:not([").concat(viewBoxAttribute, "])"));
        // console.log('2dm svgs', svgs);
        svgs.forEach(function (svg) {
            setSvgViewBox(svg);
        });
    });
    observer.observe(document.body, {
        attributes: false,
        childList: true,
        subtree: true,
    });
}
function setSvgViewBox(svg) {
    // Skip if it already has a viewBox
    var previous = svg.getAttribute(viewBoxAttribute);
    if (previous)
        return;
    // calculate max size of all elements in the SVG
    var _a = svg_icons_spreadArray([], (svg).children, true).reduce(function (acc, el) {
        var _a = el.getBBox(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        if (!acc.xMin || x < acc.xMin)
            acc.xMin = x;
        if (!acc.xMax || x + width > acc.xMax)
            acc.xMax = x + width;
        if (!acc.yMin || y < acc.yMin)
            acc.yMin = y;
        if (!acc.yMax || y + height > acc.yMax)
            acc.yMax = y + height;
        return acc;
    }, {}), xMin = _a.xMin, xMax = _a.xMax, yMin = _a.yMin, yMax = _a.yMax;
    var viewbox = "".concat(xMin, " ").concat(yMin, " ").concat(xMax - xMin, " ").concat(yMax - yMin);
    svg.setAttribute(viewBoxAttribute, viewbox);
}

;// CONCATENATED MODULE: ./src/bootstrap/bootstrap.ts
var bootstrap_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();










/**
 * This contains everything necessary to bootstrap the edit mode.
 * It must be initialized and started at the end in the x-bootstrap code,
 * to ensure everything is already ready and loaded
 * @internal
 */
var BootstrapInPage = /** @class */ (function (_super) {
    bootstrap_extends(BootstrapInPage, _super);
    function BootstrapInPage() {
        var _this = _super.call(this, 'Sys.Bootst', null, 'Building Bootstrapper') || this;
        _this.initializedInstances = [];
        _this.openedTemplatePickerOnce = false;
        _this.diagCancelStateOnStart = cancelled.get();
        insights_Insights.add('system', 'bootstrap', _this.log);
        return _this;
    }
    BootstrapInPage.prototype.initialize = function () {
        var callLog = this.log.call('initialize');
        // reset cancelled state after one reload
        if (this.diagCancelStateOnStart)
            cancelled.remove();
        // initialize all modules
        this.initAllInstances(true);
        // start observing the body for configured mutations
        this.watchDomChanges();
        // start watching the body for toolbar mutations (SVGs)
        monitorSvgIconsInToolbar();
        callLog.return('done');
    };
    /**
     * Scan all instances and initialize them
     * @param isFirstRun should be true only on the very initial call
     */
    BootstrapInPage.prototype.initAllInstances = function (isFirstRun) {
        var _this = this;
        var callLog = this.log.call('initAllInstances');
        // initialize toolbars that are not inside 2sxc modules (e.g. in skin)
        var noModuleToolbars = Array.from(document.querySelectorAll(toolbar_finder_and_initializer_toolbarSelector))
            .filter(function (e) { return !e.closest(C.Sel.SxcDivs); });
        this.log.add("Found ".concat(noModuleToolbars.length, " toolbars outside of 2sxc modules"));
        noModuleToolbars.forEach(function (e) {
            ToolbarManager.singleton().build(e);
        });
        // initialize toolbars inside 2sxc modules
        var modToolbars = document.querySelectorAll(C.Sel.SxcDivs);
        this.log.add("Found ".concat(modToolbars.length, " toolbars inside 2sxc modules"));
        modToolbars.forEach(function (e) {
            _this.initInstance(e, isFirstRun);
        });
        if (isFirstRun)
            this.tryShowTemplatePicker();
        callLog.return('initAllInstances done');
    };
    /**
     * create an observer instance and start observing
     */
    BootstrapInPage.prototype.watchDomChanges = function () {
        var _this = this;
        var callLog = this.log.call('watchDomChanges');
        var observer = new MutationObserver(function (m) {
            // Watch statistics how changes were processed
            window.$2sxc.stats.watchDomChanges++;
            var processed = 0;
            // Loop through each changed item, check if it's something we want to initialize
            m.forEach(function (v) {
                v.addedNodes.forEach(function (n) {
                    // remove #comment and text nodes
                    if (n.matches == null)
                        return;
                    var node = n;
                    // Menus which appear also cause DOM changes, but we want to ignore these for performance reasons
                    if (node.matches(C.IDs.cls.scMenu))
                        return;
                    processed++;
                    // If the added node is a [data-edit-context], it is either a module or a content block which was replaced
                    // re-initialize the module
                    if (node.matches(C.Sel.SxcDivs)) {
                        _this.initInstance(node, false);
                        // in case it has inner content, try to open the picker-dialog
                        if (!QuickDialog.singleton().isVisible())
                            _this.tryShowTemplatePicker();
                    }
                    // If the added node contains [data-edit-context] nodes, it is likely the DNN module drag manager which added
                    // the node. To prevent multiple initialization while dragging modules, we additionally check for the
                    // .active-module class which seems to be applied while dragging the module.
                    else if (node.matches(':not(.active-module)') && node.querySelectorAll(C.Sel.SxcDivs).length > 0) {
                        node.querySelectorAll(C.Sel.SxcDivs).forEach(function (e) {
                            _this.initInstance(e, false);
                        });
                    }
                    else
                        ToolbarManager.singleton().build(node);
                });
            });
            // Clean up orphan tags if nodes have been added
            if (processed)
                TagToolbarManager.CleanupOrphanedToolbars();
        });
        observer.observe(document.body, {
            attributes: false,
            childList: true,
            subtree: true,
        });
        callLog.return('watchDomChanges done');
    };
    /**
     * Show the template picker if
     * - template picker has not yet been opened
     * - dialog has not been cancelled
     * - only one uninitialized module on page
     * @returns
     */
    BootstrapInPage.prototype.tryShowTemplatePicker = function () {
        var _a;
        var cl = this.log.call('tryShowTemplatePicker');
        var sxc;
        // first check if we should show one according to the state-settings
        var openDialogId = state_cbId.get();
        if (openDialogId) {
            // must check if it's on this page, as it could be from another page
            var found = document.querySelectorAll("[".concat(C.AttrNames.ContentBlockId, "=\"").concat(openDialogId, "\"]"));
            if (found.length) {
                // since the CB-ID could also be an inner content (marked as a negative "-" number)
                // we must be sure that we use the right id a.nyhow
                if (openDialogId < 0) {
                    var instanceId = Number(found[0].attributes.getNamedItem(C.AttrNames.InstanceId).value);
                    sxc = window.$2sxc(instanceId, openDialogId);
                }
                else
                    sxc = window.$2sxc(openDialogId);
            }
        }
        if (!sxc) {
            var uninitializedModules = document.querySelectorAll(".".concat(C.ClsNames.UnInitialized));
            if (this.diagCancelStateOnStart || this.openedTemplatePickerOnce)
                return cl.return(false, 'cancelled');
            // already showing a dialog
            if (QuickDialog.singleton().isVisible())
                return cl.return(false, 'should be invisible');
            // not exactly one uninitialized module
            if (uninitializedModules.length !== 1)
                return cl.return(false, 'has un-init modules');
            // show the template picker of this module
            var module_1 = (_a = Array.from(uninitializedModules).find(function (e) { return e.parentElement.matches(C.Sel.SxcDivs); })) === null || _a === void 0 ? void 0 : _a.parentElement;
            sxc = window.$2sxc(module_1);
        }
        if (sxc) {
            sxc.manage.run("layout" /* CommandNames.layout */);
            this.openedTemplatePickerOnce = true;
        }
        return cl.return(true, 'tryShowTemplatePicker() done');
    };
    BootstrapInPage.prototype.initInstance = function (module, isFirstRun) {
        var cl = this.log.call('initInstance', "module: obj, isFirstRun: ".concat(isFirstRun, ") initialized: ").concat(this.initializedInstances));
        // if instance is already in the list of initialized modules, skip
        // otherwise add for next time to prevent recursions
        if (this.initializedInstances.find(function (m) { return m === module; }))
            return;
        this.initializedInstances.push(module);
        var sxc = window.$2sxc(module);
        // check if the sxc must be re-created. This is necessary when modules are dynamically changed
        // because the configuration may change, and that is cached otherwise, resulting in toolbars with wrong config
        if (!isFirstRun)
            sxc = sxc.recreate(true);
        // check if we must show the glasses
        // this must always run because it can be added ajax-style
        var wasEmpty = this.showGlassesButtonIfUninitialized(sxc);
        if (isFirstRun || !wasEmpty) {
            // use a logger for each iteration
            var log = new Log_Log('Bts.Module');
            ToolbarManager.singleton().buildModule(module);
        }
        cl.done();
    };
    BootstrapInPage.prototype.showGlassesButtonIfUninitialized = function (sxci) {
        var callLog = this.log.call('showGlassesButtonIfUninitialized');
        // already initialized
        if (this.isInitialized(sxci))
            return callLog.return(false, 'is initialized');
        // already has a glasses button
        var tag = SxcTools.getTag(sxci);
        if (tag.querySelectorAll(".".concat(C.ClsNames.UnInitialized)).length !== 0)
            return callLog.return(false, 'already has button');
        // note: title is added on mouseover, as the translation isn't ready at page-load
        var btn = NoJQ.domFromString("<div class=\"".concat(C.ClsNames.UnInitialized, "\" onmouseover=\"this.title = $2sxc.translate(this.title)\" title=\"InPage.NewElement\">") +
            '<div class="icon-sxc-glasses"></div>' +
            '</div>')[0];
        btn.addEventListener('click', function () { return sxci.manage.run("layout" /* CommandNames.layout */); });
        tag.append(btn);
        return callLog.return(true, 'ok');
    };
    BootstrapInPage.prototype.isInitialized = function (sxci) {
        var _a;
        var manage = sxci === null || sxci === void 0 ? void 0 : sxci.manage;
        var cg = (_a = manage === null || manage === void 0 ? void 0 : manage.editContext) === null || _a === void 0 ? void 0 : _a.contentBlock;
        return cg && cg.TemplateId !== 0;
    };
    return BootstrapInPage;
}(HasLog));


;// CONCATENATED MODULE: ./src/cms/sxc-global-cms.ts
var sxc_global_cms_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var sxc_global_cms_assign = (undefined && undefined.__assign) || function () {
    sxc_global_cms_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return sxc_global_cms_assign.apply(this, arguments);
};







var logId = 'Cms.Api';
/**
 * Global Content-Management System on the $2sxc.cms.
 *
 * It is only available if the page is in edit mode / the page feature `2sxc.JsCms` has been activated.
 * @public
 */
// Note that it can be used standalone, not just on $2sxc, as it doesn't directly rely on that.
var SxcGlobalCms = /** @class */ (function (_super) {
    sxc_global_cms_extends(SxcGlobalCms, _super);
    /**
     * @internal
     */
    function SxcGlobalCms() {
        var _this = _super.call(this, logId, null) || this;
        /**
         * @internal
         */
        _this.autoDump = C.Debug.cms.autoDump;
        return _this;
    }
    /**
     * reset / clear the log
     * @internal
     */
    SxcGlobalCms.prototype.resetLog = function () {
        this.log = new Log_Log(logId, null, 'log was reset');
        insights_Insights.add('cms', 'run', this.log);
    };
    /**
     * Run - full signature, internal use, not publicly documented; only included because docs-generator needs it.
     * Please use other signatures with more specific parameter types
     */
    SxcGlobalCms.prototype.run = function (context, nameOrSettings, eventOrSettings, event) {
        return this.runInternal(context, nameOrSettings, eventOrSettings, event);
    };
    /**
     * Run a command within a specific context.
     * @param context The context - either an HTML tag which determines a module/instance, or an Sxc instance
     * @param nameOrSettings
     * @param eventOrSettings
     * @param event Optional mouse-event which allows the command to do some optimizations for that case - like a mouse-click
     * @returns A promise which triggers when the command has completed.
     * @internal
     */
    SxcGlobalCms.prototype.runInternal = function (context, nameOrSettings, eventOrSettings, event) {
        var cl = this.log.call('run<T>');
        var cmsEngine = new CmsEngine(this.log);
        // Figure out inner-call based on if context is new RunParams or not (in that case it should be a tag or a full context)
        var innerCall;
        if (RunParamsHelpers.is$sxcRunParams(context)) {
            // V1 which has RunParamsWithContext all in the first parameter
            var contextGiver = (context_identifier_ContextIdentifier.is(context.context) || sxc_Sxc.is(context.context))
                ? window.$2sxc(context.context)
                : context.tag;
            var realCtx_1 = ContextComplete.findContext(contextGiver);
            context.params = sxc_global_cms_assign({ action: context.action }, context.params);
            innerCall = function () { return cmsEngine.run(realCtx_1, context.params, context.event, context); };
        }
        else {
            var realCtx_2 = ContextBundleInstance.is(context)
                ? context
                : ContextComplete.findContext(context);
            innerCall = function () { return cmsEngine.detectParamsAndRun(realCtx_2, nameOrSettings, eventOrSettings, event); };
        }
        var result = this.do(innerCall);
        return cl.return(result, 'ok');
    };
    /**
     * reset/clear the log if alwaysResetLog is true
     * @internal
     */
    SxcGlobalCms.prototype.do = function (innerCall) {
        var cl = this.log.call('do');
        this.resetLog();
        var result = innerCall();
        if (this.autoDump)
            this.log.dump();
        return cl.return(result);
    };
    return SxcGlobalCms;
}(HasLog));


;// CONCATENATED MODULE: ./src/sxc/sxc-cms-real.ts
var sxc_cms_real_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var sxc_cms_real_assign = (undefined && undefined.__assign) || function () {
    sxc_cms_real_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return sxc_cms_real_assign.apply(this, arguments);
};



/**
 * This is in charge of sxc.cms on the instance level.
 * ATM it just has the run command.
 * In future, it may also have dedicated command like `layout` etc.
 * @internal
 */
var SxcCmsReal = /** @class */ (function (_super) {
    sxc_cms_real_extends(SxcCmsReal, _super);
    /** @internal */
    function SxcCmsReal(sxc) {
        return _super.call(this, sxc) || this;
    }
    /**
     * Run a command on this sxc-instance.
     * Requires edit mode to be on, which would enable the edit-JS parts.
     * To use, remember to activate `2sxc.JsCms` on the page
     * @param runParams - real type is actually RunParams
     */
    SxcCmsReal.prototype.run = function (runParams) {
        RunParamsHelpers.ensureRunParamsInstanceOrError(runParams);
        return new SxcGlobalCms().runInternal(sxc_cms_real_assign(sxc_cms_real_assign({}, runParams), { context: this.sxc }));
    };
    return SxcCmsReal;
}(SxcCms));


;// CONCATENATED MODULE: ./src/manage/edit-manager.ts
var edit_manager_assign = (undefined && undefined.__assign) || function () {
    edit_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return edit_manager_assign.apply(this, arguments);
};




/**
 * Instance specific edit manager
 * @internal
 */
var EditManager = /** @class */ (function () {
    function EditManager(editContext, context) {
        var _this = this;
        this.editContext = editContext;
        this.context = context;
        //#endregion official, public properties - everything below this can change
        /**
         * internal method to find out if it's in edit-mode
         */
        this._isEditMode = function () { var _a; return (_a = _this.editContext.Environment.IsEditable) !== null && _a !== void 0 ? _a : false; };
    }
    //#region Official, public properties and commands, which are stable for use from the outside
    /**
     * run a command - command used in toolbars and custom buttons
     * it is publicly used out of inpage, so take a care to preserve function signature
     */
    EditManager.prototype.run = function (nameOrSettings, eventOrSettings, event) {
        // Capture cases where this is called using the new/modern params, which is a mistake
        if (nameOrSettings.context || nameOrSettings.workflows)
            throw "You are calling '.manage.run(...)' with a parameter 'context' or workflows. You should probably be calling the new '.cms.run(...)' instead.";
        var cntx = ContextComplete.findContext(this.context.sxc);
        return new SxcGlobalCms().runInternal(cntx, nameOrSettings, eventOrSettings, event);
    };
    /**
     * Generate a button (an <a>-tag) for one specific toolbar-action.
     * @param {InPageButtonJson} actDef - settings, an object containing the spec for the expected button
     * @param {int} groupIndex - number what button-group it's in'
     * @returns {string} html of a button
     * it is publicly used out of inpage, so take a care to preserve function signature
     */
    EditManager.prototype.getButton = function (actDef, groupIndex) {
        this.context.button = ToolbarManager.singleton().getLoader('getButton')
            .groups.convertToButton(actDef, {}, {}, {});
        var button = new ToolbarRenderer(this.context).button.render(this.context, groupIndex);
        return button.outerHTML;
    };
    /**
     * Builds the toolbar and returns it as HTML
     * @param {Object} tbConfig - general toolbar config
     * @param {ToolbarSettings} moreSettings - additional / override settings
     * @returns {string} html of the current toolbar
     *
     * it is publicly used in Razor scripts of inpage, so take a care to preserve function signature
     */
    EditManager.prototype.getToolbar = function (tbConfig, moreSettings) {
        // if toolbar is an array, use as-is, otherwise assume properties are params
        var toolbar = Array.isArray(tbConfig) ? tbConfig : edit_manager_assign({}, tbConfig);
        tbConfig = { settings: edit_manager_assign(edit_manager_assign({}, tbConfig.settings), moreSettings), toolbar: toolbar };
        var toolbarConfig = ToolbarManager.singleton().loadConfig(this.context, tbConfig);
        this.context.toolbar = toolbarConfig;
        return new ToolbarRenderer(this.context).render();
    };
    /**
     * change config by replacing the guid, and refreshing dependent sub-objects
     */
    EditManager.prototype._updateContentGroupGuid = function (context, newGuid) {
        context.contentBlock.contentGroupId = newGuid;
        this.editContext.contentBlock.Guid = newGuid;
    };
    return EditManager;
}());


;// CONCATENATED MODULE: ./src/manage/sxc-global-manage.ts





/**
 * A helper-controller in charge of opening edit-dialogues + creating the toolbars for it
 * all in-page toolbars etc.
 * if loaded, it's found under the $2sxc(module).manage
 * it has commands to
 * - getButton
 * - getToolbar
 * - run(...)
 * - isEditMode
 * @internal
 */
var SxcGlobalManage = /** @class */ (function () {
    function SxcGlobalManage() {
        /** Internal - ATM only used in dnn-sxc-angular to enable toolbar initialization */
        this._toolbarManager = ToolbarManager.singleton();
    }
    /**
     * Init the manage-object on a just-created sxc-instance
     * we must keep signature of initInstance in sync with the 2sxc.api.js
     * @param sxc
     */
    SxcGlobalManage.prototype.initInstance = function (sxc) {
        try {
            var myContext = ContextComplete.findContext(sxc);
            var editContext = SxcTools.getEditContext(sxc);
            sxc.manage = new EditManager(editContext, myContext);
            // add code for the cms.run command, which doesn't exist until editing is enabled
            sxc.cms = new SxcCmsReal(sxc);
        }
        catch (e) {
            console.error('error in 2sxc - will log but not throw', e);
        }
    };
    return SxcGlobalManage;
}());


;// CONCATENATED MODULE: ./src/system/2sxc.system.ts
//#region WebApi Endpoints used: 2sxc
var webApiInstallComplete = 'sys/install/resume';
//#endregion
/**
 * @internal
 */
var SystemUpgrader = /** @class */ (function () {
    function SystemUpgrader() {
    }
    // upgrade command - started when an error contains a link to start this
    SystemUpgrader.prototype.finishUpgrade = function (domElement) {
        var mc = window.$2sxc(domElement);
        mc.webApi.fetchRaw(webApiInstallComplete)
            .then(function () {
            alert('Upgrade ok, restarting the CMS and reloading...');
            location.reload();
        });
        alert('starting upgrade. This could take a few minutes. You\'ll see an \'ok\' when it\'s done. Please wait...');
    };
    return SystemUpgrader;
}());


;// CONCATENATED MODULE: ./src/system/index.ts


;// CONCATENATED MODULE: ./src/cms/index.ts




;// CONCATENATED MODULE: ./src/sxc/index.ts




;// CONCATENATED MODULE: ./src/toolbar/toolbar-global-enable-shake.ts

// tslint:disable-next-line: no-var-requires
var Shake = __webpack_require__(249);
// ReSharper disable once InconsistentNaming
// enable shake detection on all toolbars
NoJQ.ready(function () {
    // this will add a css-class to auto-show all toolbars (or remove it again)
    function toggleAllToolbars() {
        document.body.classList.toggle('sc-tb-show-all');
    }
    // debugger; // shake is not working, neither on ios nor android. Might be because of http and might work with https
    var shake = new Shake({ callback: toggleAllToolbars });
    // start shake-event monitoring, which will then generate a window-event
    shake.start();
});

// EXTERNAL MODULE: ./src/dnn/dnn-08.00.04.ts
var dnn_08_00_04 = __webpack_require__(79);
;// CONCATENATED MODULE: ./src/dnn/index.ts
// Apply DNN Bugfixes


;// CONCATENATED MODULE: ./src/index.ts








// Exports for Docs





/**
 * @internal
 */

// #1 Note that $2sxc must always exist, the server ensures the load order
var $2sxc = window.$2sxc;
// #2 Now attach initialization helpers and global objects, so that $2sxc always has these
$2sxc.context = ContextComplete.findContext; // primary API to get the context
$2sxc._translateInit = function (manage) { return translator_Translator.initManager(manage); }; // reference in ./2sxc-api/js/ToSic.Sxc.Instance.ts
$2sxc.translate = translate; // provide an official translate API for 2sxc
$2sxc._manage = new SxcGlobalManage(); // used out of this project in ToSic.Sxc.Instance and 2sxc.api.js
window.$quickE = QuickE.singleton(); // note: not sure if this is needed as a global object...
$2sxc.cms = new SxcGlobalCms();
// #3 Initialize all objects as needed
function loadInpage() {
    // check if already initialized - just in case these scripts were loaded multiple times
    var bootstrapper = new BootstrapInPage();
    bootstrapper.initialize();
    QuickE.singleton().start();
    /** this enhances the $2sxc client controller with stuff only needed when logged in */
    if (!$2sxc.system)
        $2sxc.system = new SystemUpgrader();
}
NoJQ.ready(loadInpage);
// Apply Dnn Bugfixes

// Tell Webpack to load CSS
var cssEdit = __webpack_require__(361);
var cssIcons = __webpack_require__(576);

})();

$2sxcInpage = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=https://sources.2sxc.org/14.12.00/inpage/inpage.min.js.map