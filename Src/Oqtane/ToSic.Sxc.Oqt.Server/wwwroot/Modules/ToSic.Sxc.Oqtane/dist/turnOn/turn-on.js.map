{"version":3,"sources":["webpack://turn-on/./src/constants.ts","webpack://turn-on/./src/debug.ts","webpack://turn-on/./src/status/status.ts","webpack://turn-on/./src/status/status-summary.ts","webpack://turn-on/./src/conditions/condition-name.ts","webpack://turn-on/./src/conditions/condition-function.ts","webpack://turn-on/./src/conditions/condition-function-name.ts","webpack://turn-on/./src/conditions/condition-maker.ts","webpack://turn-on/./src/conditions/exists-progress.ts","webpack://turn-on/./src/configuration/configuration.ts","webpack://turn-on/./src/tags/config-tag.ts","webpack://turn-on/./src/turnOn/settings.ts","webpack://turn-on/./src/configuration/config-helper.ts","webpack://turn-on/./src/tags/config-tag-manager.ts","webpack://turn-on/./src/tags/config-to-turn-on.ts","webpack://turn-on/./src/tags/tag-loader.ts","webpack://turn-on/./src/watch-promise/condition-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on.ts","webpack://turn-on/./src/watch-promise/promise-boolean-as-promise.ts","webpack://turn-on/./src/turnOn/turn-on-root.ts","webpack://turn-on/./src/index.ts","webpack://turn-on/webpack/bootstrap","webpack://turn-on/webpack/runtime/define property getters","webpack://turn-on/webpack/runtime/hasOwnProperty shorthand","webpack://turn-on/webpack/startup"],"names":["AttributeTurnOn","AttributeSkip","windowName","logPrefix","log","message","obj1","obj2","window","debugTurnOn","console","type","ready","name","result","attempts","details","Array","isArray","filter","stat","length","detectIfAllOk","Status","statusType","createNameCondition","key","exists","ExistsProgress","test","success","matchedKey","createFnCondition","fn","toString","substr","namedFnType","make","condition","endsWith","fnCondition","nameCondition","substring","statusOfName","createFunctionNameCondition","parent","lastName","parts","partsFound","split","partName","current","match","i","ProgressError","tag","config","turnOn","this","syncDom","getAttribute","setAttribute","currentSerialized","JSON","stringify","progress","prog","error","LogError","LogDebug","FailReject","DefaultName","interval","failure","createError","await","debug","run","load","value","pretyped","configuration","parse","ex","ConfigHelper","stabilize","raw","startsWith","awaits","push","logMode","data","settings","Settings","root","tags","tryToLoadTag","node","attr","skip","add","ConfigTag","configTag","new","promise","then","checkExists","convertConfigToTurnOn","updateTags","forEach","t","queryForUnprocessedTags","tagManager","attributes","childList","subtree","scanExistingDom","activateObserver","document","documentElement","checkAndLoadChildren","children","querySelectorAll","observer","MutationObserver","mutations","m","from","addedNodes","n","nodeType","observe","promiseType","checkFunction","lastStatus","innerCheck","check","asPromise","checkCondition","resolve","reject","setTimeout","Promise","nameOrSettings","_conditionMaker","ConditionMaker","TurnOn","count","conditions","loadedCheckers","map","c","boolPromise","r","catch","reason","ConditionAsPromise","thisKs","instanceCount","all","list","summary","StatusSummary","logStatusList","id","statusList","ConfigTagManager","loader","TagLoader","TurnOnRoot","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"mappings":"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","file":"turn-on.js","sourcesContent":["\r\nexport const AttributeTurnOn = 'turn-on';\r\nexport const AttributeSkip = 'turn-on-skip';\r\n\r\nexport const windowName = 'window';\r\n\r\nexport const logPrefix = 'turn-on: ';","\r\n// const debug = true;\r\n\r\nimport { logPrefix } from './constants';\r\n\r\nexport function log(message: string, obj1?: unknown, obj2?: unknown): void {\r\n  if(!window.debugTurnOn) return;\r\n  if(obj2) console.log(logPrefix + message, obj1, obj2);\r\n  else if(obj1)  console.log(logPrefix + message, obj1);\r\n  else console.log(logPrefix + message);\r\n}","\r\nconst nameNotDefined = 'not set';\r\n\r\nexport class Status {\r\n  constructor(\r\n    /** The status type, like window-key, function, summary etc. */\r\n    public type: string,\r\n\r\n    /** Status if the check has been successful */\r\n    public ready: boolean,\r\n\r\n    /** Status message if provided */\r\n    public message: string, \r\n    \r\n    /** name of this status, to better point to which rule failed */\r\n    public name: string = nameNotDefined,\r\n    \r\n    /** result of a check - in some cases needed for next steps */\r\n    public result?: unknown\r\n    ) {\r\n  }\r\n\r\n  /** Amount of attempts tried till this  */\r\n  attempts? = 0;\r\n\r\n}\r\n","import { Status } from '.';\r\n\r\n\r\nexport class StatusSummary extends Status {\r\n\r\n  constructor(details: Status[]) {\r\n    // no details provided, then assume ok\r\n    if (!details) details = [];\r\n\r\n    const ready = detectIfAllOk(details);\r\n\r\n    const message = details.length === 0\r\n      ? 'no conditions provided'\r\n      : ready\r\n        ? 'all ok'\r\n        : 'some conditions did not complete';\r\n    super('summary', ready, message, 'Summary');\r\n    this.details = details;\r\n  }\r\n\r\n  /** Details of each of the status received */\r\n  details: Status[]\r\n}\r\n\r\nfunction detectIfAllOk(details: Status[]) {\r\n  // some kind of error appeared, shouldn't be ok\r\n  if (!Array.isArray(details)) return false;\r\n\r\n  // count if all details have a ready-state\r\n  return (details.filter(stat => stat.ready).length == details.length)\r\n}","import { Condition, ExistsProgress } from '.';\r\nimport { Status, windowName } from '..';\r\n\r\nconst statusType = 'window-key';\r\n\r\n/**\r\n * Create a checker which verifies if a key or key-sequence on window exists\r\n */\r\nexport function createNameCondition(key: string): Condition {\r\n  // empty-ish strings - always say it's done\r\n  if (!key) return () => new Status(statusType, true, 'empty key', key);\r\n  if (key === windowName) return () => new Status(statusType, true, 'no keys except maybe windows found', key);\r\n\r\n  return () => {\r\n    const exists = ExistsProgress.test(key);\r\n    if(exists.success) return new Status(statusType, true, 'all keys matched', key, exists.result);\r\n    return new Status(statusType, false, `Not all keys matched yet. So far '${exists.matchedKey}' worked.`, key);\r\n  }\r\n}","import { Condition } from '.';\r\nimport { Status } from '..';\r\n\r\n/**\r\n * Create a condition based on a function which will be polled till it returns truthy\r\n */\r\nexport function createFnCondition(fn: () => boolean): Condition {\r\n  let name = fn.toString();\r\n  if (name && name.length > 25) name = name.substr(0, 25);\r\n  return () => { \r\n    return new Status('fn', fn(), '', name);\r\n  }\r\n}","import { Condition } from '.';\r\nimport { createNameCondition } from './condition-name';\r\nimport { createFnCondition } from './condition-function';\r\n\r\nconst namedFnType = 'named fn';\r\n\r\n/**\r\n * Create a condition which waits for a function to exist, and then polls it till the result is ok.\r\n */\r\nexport function createFunctionNameCondition(key: string): Condition {\r\n  if(!key.endsWith('()')) throw `Tried to create Function-Name condition but that requires it to end with (), got ${key}`;\r\n\r\n  const keyWithoutBrackets = key.substring(0, key.length - 2);\r\n  let fnCondition: Condition;\r\n  const nameCondition = createNameCondition(keyWithoutBrackets);\r\n  return () => {\r\n\r\n    // As long as the name doesn't exist, check that and return that status\r\n    // But only do this till we have the fnCondition once, then skip\r\n    if(!fnCondition) {\r\n      const statusOfName = nameCondition();\r\n      if(!statusOfName.ready) return { ...statusOfName, type: namedFnType} ;\r\n\r\n      // Check if we really got a function - if not, assume all is ok and don't try to call\r\n      if(typeof(statusOfName.result) !== 'function') return { ...statusOfName, type: namedFnType };\r\n      \r\n      // Create the function-condition to use from now on. \r\n      fnCondition = createFnCondition(statusOfName.result as () => boolean);\r\n    }\r\n\r\n    // once the name exists, try to get the function\r\n    return { ...fnCondition(), type: namedFnType };\r\n  }\r\n}","import { Condition, ConditionRaw, createFnCondition, createNameCondition } from '.';\r\nimport { createFunctionNameCondition } from './condition-function-name';\r\n\r\n/**\r\n * Internal class to generate is-it-ready checkers\r\n */\r\nexport class ConditionMaker {\r\n\r\n  /**\r\n   * Make a new condition checker\r\n   */\r\n  public make(condition: ConditionRaw): Condition {\r\n    if (typeof(condition) === 'function')\r\n      return createFnCondition(condition);\r\n    \r\n    if (typeof(condition) === 'string')\r\n      return condition.endsWith('()')\r\n        ? createFunctionNameCondition(condition)\r\n        : createNameCondition(condition);\r\n  }\r\n}","import { windowName } from '..';\r\n\r\n/**\r\n * Internal Class which will check if a object path like `window.something.other` exists and report back how much of it works.\r\n */\r\nexport class ExistsProgress {\r\n  constructor(\r\n    /** true/talse if it succeeded till the end */\r\n    public success: boolean,\r\n\r\n    /** resulting object or method it would call */\r\n    public result: unknown,\r\n\r\n    /** The parent of the resulting object - in case the result was a method which needs to be rebound */\r\n    public parent: unknown,\r\n\r\n    /** name of the last element found - important if the last thing is a function*/\r\n    public lastName: string,\r\n\r\n    /** Amount of parts in the full identifier */\r\n    public parts: number,\r\n\r\n    /** Amount of parts found */\r\n    public partsFound: number,\r\n\r\n    /** Part-path which already worked */\r\n    public matchedKey: string,\r\n  ) { }\r\n\r\n  static test(key: string): ExistsProgress {\r\n    if(!key) return new ExistsProgress(true, null, null, null, 0, 0, \"\");\r\n\r\n    const parts = key.split('.');\r\n    if(parts[0] !== windowName) throw `Key must start with '${windowName}.' but it's '${key}'`;\r\n\r\n    // Only contains window, stop here\r\n    if (parts.length == 1) return new ExistsProgress(true, window, null, windowName, 1, 1, windowName);\r\n\r\n    let current = window as any;\r\n    let parent = null as any;\r\n    let match = windowName;\r\n    let partName: string;\r\n    for (let i = 1; i < parts.length; i++) {\r\n      partName = parts[i];\r\n      parent = current;\r\n      current = current[partName];\r\n      // found, so let's add to list of successful matches\r\n      match += '.' + partName;\r\n\r\n      // if node not found, stop checking\r\n      if (!current) return new ExistsProgress(false, null, parent, partName, parts.length, i, match);\r\n    }\r\n    return new ExistsProgress(true, current, parent, partName, parts.length, parts.length, match);\r\n  }\r\n}","import { Settings } from '../turnOn/settings';\r\nexport const Progress1Loaded = '1-loaded';\r\nexport const Progress2Watching = '2-watching';\r\nexport const Progress3Running = '3-running';\r\nexport const Progress4Completed = '4-completed';\r\nexport const Progress9Cancelled = '9-cancelled';\r\nexport const ProgressError = '9-error';\r\n\r\nexport type TurnOnProgres = typeof Progress1Loaded | typeof Progress2Watching  | typeof Progress3Running | typeof Progress4Completed | typeof Progress9Cancelled | typeof ProgressError ;\r\n\r\nexport interface TurnOnConfiguration {\r\n  /** Things to wait for - names on window (or sub-objects) or functions on window or sub-objects */\r\n  await: string[];\r\n\r\n  /** Special flag to log everything that's happening for extensive debugging */\r\n  debug: boolean;\r\n\r\n  /**\r\n   * What to run when all awaits have succeeded. \r\n   * The system will also wait for this to exist before it runs it. \r\n   */\r\n  run: string;\r\n\r\n  /** Information how far processing of this configuration has commenced */\r\n  progress: TurnOnProgres;\r\n\r\n  /** Possible error information */\r\n  error?: string;\r\n\r\n  /** Optional data to give the function once it starts */\r\n  data?: unknown;\r\n\r\n  /** Settings used for this turn-on */\r\n  settings?: Settings\r\n}\r\n","import { TurnOnConfiguration, TurnOnProgres } from '../configuration';\r\nimport { AttributeTurnOn, AttributeSkip } from '..';\r\nimport { log } from '../debug';\r\nimport { TurnOn } from '../turnOn/turn-on';\r\nimport { ProgressError } from '../configuration/configuration';\r\n\r\n\r\nexport class ConfigTag {\r\n\r\n  constructor(\r\n    public tag: HTMLElement,\r\n    public config: TurnOnConfiguration,\r\n    public turnOn?: TurnOn\r\n  ) \r\n  { \r\n    this.syncDom();\r\n  }\r\n\r\n  syncDom(): void {\r\n    log('syncDom', this);\r\n    const tag = this.tag;\r\n    // set skip if missing and update json in html if not current\r\n    // Do these checks to avoid to many DOM changes\r\n    if(!tag.getAttribute(AttributeSkip)) tag.setAttribute(AttributeSkip, \"skip\");\r\n    const currentSerialized = JSON.stringify(this.config);\r\n    if(tag.getAttribute(AttributeTurnOn) !== currentSerialized)\r\n      tag.setAttribute(AttributeTurnOn, currentSerialized);\r\n  }\r\n\r\n  progress(prog: TurnOnProgres): void {\r\n    this.config.progress = prog;\r\n    this.syncDom();\r\n  }\r\n\r\n  error(message: string): void {\r\n    this.config.progress = ProgressError;\r\n    this.config.error = message;\r\n    this.syncDom();\r\n    throw this.config.error;\r\n  }\r\n}","\r\n// this must be a simple const, otherwise the anotation below with typeof won't work\r\n// https://stackoverflow.com/questions/56263200/how-to-define-string-literal-union-type-from-constants-in-typescript\r\nexport const LogError = 'error';\r\nexport const LogDebug = 'debug';\r\nexport const LogSilent = 'silent';\r\n\r\nexport const FailSilent = 'silent';\r\nexport const FailResolve = 'resolve';\r\nexport const FailReject = 'reject';\r\nexport const DefaultName = 'turnOn';\r\n\r\nexport type LogMode = typeof LogError | typeof LogDebug | typeof LogSilent;\r\n\r\nexport class Settings {\r\n  /** the polling interval - defaults to 100 */\r\n  interval = 100;\r\n\r\n  /** polling attempts, defaults to 100 */\r\n  attempts = 100;\r\n \r\n  /** What to log into the console */\r\n  log: LogMode = LogError;\r\n\r\n  /**\r\n   * Failure mode, if by timeout it's not successful\r\n   * - reject (default)= use promise reject (which will throw an error if not handled)\r\n   * - resolve = use promise resolve and give a status back which says it's not complete\r\n   * - silent = don't complete the promise\r\n   */\r\n  failure: typeof FailReject | typeof FailResolve | typeof FailSilent = FailReject;\r\n\r\n  /** The name of this turnOn - to better track issues */\r\n  name = DefaultName;\r\n}","import { Progress1Loaded, ProgressError, TurnOnConfiguration } from '.';\r\nimport { TurnOnConfigurationRaw } from '..';\r\nimport { LogMode, Settings, LogError, LogDebug } from '../turnOn/settings';\r\n\r\nexport class ConfigHelper {\r\n\r\n  /**\r\n   * Create a configuration object which just contains an error\r\n   */\r\n  static createError(message: string): TurnOnConfiguration {\r\n    const result: TurnOnConfiguration = {\r\n      await: [],\r\n      debug: false,\r\n      run: '',\r\n      progress: ProgressError,\r\n      error: message\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Load a configuration from a string usually from an Html attribute\r\n   */\r\n  static load(value: string): TurnOnConfiguration {\r\n    let pretyped: TurnOnConfigurationRaw;\r\n    try {\r\n      pretyped = JSON.parse(value);\r\n    }\r\n    catch (ex) {\r\n      return ConfigHelper.createError(`detected configuration but cannot parse to json.`);\r\n    }\r\n    let configuration: TurnOnConfiguration;\r\n    try {\r\n      configuration = ConfigHelper.stabilize(pretyped);\r\n    }\r\n    catch (ex) { \r\n      return ConfigHelper.createError(`Error loading configuration, reason unknown.`)\r\n    }\r\n  \r\n    return configuration;\r\n  }\r\n\r\n  /**\r\n   * Import a raw configuration and make sure it's fully compliant\r\n   */\r\n  private static stabilize(raw: TurnOnConfigurationRaw): TurnOnConfiguration {\r\n    if(!raw) return ConfigHelper.createError('No config data found to process');\r\n    if(!raw.run) return ConfigHelper.createError(`Config didn't contain 'run' - it's required.`);\r\n    if(!raw.run.startsWith('window')) return ConfigHelper.createError(`run command must start with 'window.' but is:` + raw.run);\r\n    if(!raw.run.endsWith('()')) return ConfigHelper.createError(`run must be a function name and end with () but it's:` + raw.run);\r\n  \r\n    const awaits = Array.isArray(raw.await) \r\n          ? raw.await\r\n          : raw.await \r\n            ? [raw.await]\r\n            : [];\r\n  \r\n    // also always await the run command, but without the () as it shouldn't be called to detect if it's ready    \r\n    awaits.push(raw.run.substring(0, raw.run.length-2));\r\n  \r\n    const logMode: LogMode = (raw?.debug ?? false) ? LogDebug : LogError;\r\n\r\n    const stable: TurnOnConfiguration = {\r\n      await: awaits,\r\n      debug: raw.debug ?? false,\r\n      run: raw.run,\r\n      progress: Progress1Loaded,\r\n      data: raw.data || { }, // give empty object so a developer can see this would exist as an option\r\n      settings: { ...new Settings(), log: logMode, ...raw.settings }\r\n    }\r\n    return stable;\r\n  }\r\n}","import { TurnOnConfiguration } from '../configuration';\r\nimport { AttributeTurnOn, AttributeSkip, log } from '..';\r\nimport { TurnOnRoot } from '../turnOn';\r\nimport { ConfigTag, convertConfigToTurnOn } from '.';\r\nimport { ConfigHelper, ProgressError } from '../configuration';\r\n\r\nexport class ConfigTagManager {\r\n  \r\n  public tags = new Array<ConfigTag>();\r\n\r\n  constructor(public root: TurnOnRoot) {\r\n    \r\n  }\r\n\r\n\r\n  tryToLoadTag(node: HTMLElement): void {\r\n    // Get config and skip if not relevant, or skip if already marked as in the queue\r\n    const attr = node?.getAttribute?.(AttributeTurnOn);\r\n    if(!attr) return;\r\n    const skip = node?.getAttribute?.(AttributeSkip);\r\n    log('skip', skip);\r\n    if(skip) return log('skip');\r\n\r\n    log('attr', attr);\r\n    const config = ConfigHelper.load(attr);\r\n    if(config.progress === ProgressError) {\r\n      console.error(config.error, node, attr);\r\n      return;\r\n    }\r\n    log('stable config')\r\n    this.add(node, config);\r\n  }\r\n  \r\n  /**\r\n   * \r\n   */\r\n  add(node: HTMLElement, config: TurnOnConfiguration): void {\r\n    log('add', node, config);\r\n    const tag = new ConfigTag(node, config);\r\n    this.tags.push(tag);\r\n    convertConfigToTurnOn(this.root, tag);\r\n  }\r\n\r\n  updateTags(): void {\r\n    log(`updateTags: ${this.tags.length}`);\r\n    this.tags.forEach((t) => t.syncDom())\r\n  }\r\n\r\n}","import { ConfigTag } from '.';\r\nimport { log, Status } from '..';\r\nimport { Progress2Watching, Progress3Running, Progress4Completed } from '../configuration';\r\nimport { TurnOnRoot } from '../turnOn';\r\nimport { ExistsProgress } from '../conditions/exists-progress';\r\nimport { ContextData } from './context-data';\r\n\r\n/**\r\n * \r\n */\r\nexport function convertConfigToTurnOn(root: TurnOnRoot, configTag: ConfigTag): Promise<Status> {\r\n  const config = configTag.config;\r\n  log('convert to turnon');\r\n  const turnOn = root.new(config.settings);\r\n  config.settings = turnOn.settings;\r\n  const promise = turnOn.await(config.await);\r\n  configTag.progress(Progress2Watching);\r\n\r\n  promise.then(() => {\r\n    const run = config.run;\r\n    log('turn on success - will try to run ' + run);\r\n    configTag.progress(Progress3Running);\r\n    if(!run.endsWith('()')) {\r\n      configTag.error(`run should end with () but doesn't - can't continue`);\r\n      return;\r\n    }\r\n\r\n    // check exists without trailing \"()\"\"\r\n    const checkExists = ExistsProgress.test(run.substr(0, run.length - 2));\r\n\r\n    // if node not found, stop checking\r\n    if (!checkExists.success) {\r\n      configTag.error(`Tried to find object parts for ${checkExists.matchedKey} but didn't get anything.`);\r\n      return;\r\n    }\r\n    if (typeof(checkExists.result) !== 'function') {\r\n      configTag.error(`Got ${checkExists.partsFound} but it's not a function`);\r\n      return;\r\n    }\r\n\r\n    // now run it!\r\n    // Special: we can't just run the function we got back\r\n    // because that loses the `this`. So we must run it as a property of the parent\r\n    const fnScopeObject = checkExists.parent as any;\r\n    fnScopeObject[checkExists.lastName](config.data, { tag: configTag.tag, config: config } as ContextData);\r\n    // const fn = checkExists.result as (x: unknown) => unknown;\r\n    // fn({ ...config, tag: tag });\r\n    configTag.progress(Progress4Completed);\r\n  });\r\n  return promise;\r\n}\r\n","import { ConfigTagManager, log, AttributeTurnOn, AttributeSkip } from '..';\r\n\r\nconst queryForUnprocessedTags = `[${AttributeTurnOn}]:not([${AttributeSkip}])`;\r\n\r\nconst ELEMENT_NODE = 1; // see https://developer.mozilla.org/en-US/docs/Web/API/Node\r\n\r\n/**\r\n * In charge of loading all turn-on tags from the DOM, both at first load as well as on DOM changes\r\n */\r\nexport class TagLoader {\r\n\r\n  /** Options for the observer (which mutations to observe) */\r\n  public config : MutationObserverInit = { \r\n    attributes: false, \r\n    childList: true, \r\n    subtree: true \r\n  };\r\n\r\n  /** The observer, in case we need to debug */\r\n  public observer: MutationObserver;\r\n\r\n  constructor(public tagManager: ConfigTagManager) {\r\n    this.scanExistingDom();\r\n    this.activateObserver();\r\n  }\r\n\r\n  public scanExistingDom(): void {\r\n    log('scanExistingDom');\r\n    if(document.documentElement)\r\n      this.checkAndLoadChildren(document.documentElement);\r\n  }\r\n\r\n  private checkAndLoadChildren(parent: HTMLElement) {\r\n    log('checkAndLoadChildren', parent);\r\n    if(!parent?.children?.length) return;\r\n    const tags = parent.querySelectorAll(queryForUnprocessedTags);\r\n    tags.forEach((t: HTMLElement) => this.tagManager.tryToLoadTag(t));\r\n  }\r\n\r\n  public activateObserver(): void {\r\n    log('activateObserver');\r\n  \r\n    this.observer = new MutationObserver((mutations) => {\r\n      log('mutations detected', mutations);\r\n      // Loop through each changed item, check if it's something we want to initialize\r\n      mutations.forEach((m) => {\r\n        // Nodes added - let's check if it is a turn-on\r\n        if(m.type != 'childList') return;\r\n        log('childList changes');\r\n\r\n        Array.from(m.addedNodes)\r\n          // nodes can contain text and stuff as well, so we must filter first\r\n          .filter(n => n.nodeType === ELEMENT_NODE)\r\n          .forEach((node: HTMLElement) => {\r\n            if(node?.getAttribute?.(AttributeTurnOn))\r\n              this.tagManager.tryToLoadTag(node);\r\n            else \r\n              this.checkAndLoadChildren(node);\r\n          });\r\n      });\r\n    });\r\n  \r\n    // observe document for tags which include this. ATM don't observe header\r\n    this.observer.observe(document.documentElement, this.config);\r\n  }\r\n}\r\n","import { Status } from '..';\r\nimport { Settings } from '../turnOn';\r\n\r\nconst promiseType = 'promise';\r\nexport class ConditionAsPromise {\r\n\r\n  public settings: Settings;\r\n\r\n  constructor(checkFunction: () => Status, settings: Settings) {\r\n    this.innerCheck = checkFunction;\r\n    this.settings = settings;\r\n  }\r\n\r\n  public lastStatus: Status = new Status(promiseType, false, 'condition not checked yet');\r\n  public attempts = 0;\r\n\r\n  /**\r\n   * Dummy innerCheck function - should be replaced in the constructor\r\n   */\r\n  public innerCheck(): Status { return new Status(promiseType, true, 'no condition defined') }\r\n\r\n  public check(): Status {\r\n    if (this.lastStatus.ready === true) return this.lastStatus;\r\n\r\n    // check and store\r\n    this.lastStatus = this.innerCheck();\r\n\r\n    return this.lastStatus;\r\n  }\r\n\r\n  public asPromise(): Promise<Status> {\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const parent = this;\r\n    const checkCondition = function(resolve: (value: Status) => void, reject: (reason: unknown | null) => void) {\r\n      // If the condition is met, we're done! \r\n      const result = parent.check();\r\n\r\n      // if all is ok (true) then complete the promise\r\n      if(result.ready === true) {\r\n        resolve( { ...result, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      if(parent.attempts++ >= parent.settings.attempts) {\r\n        resolve({ ...result, message: 'tried up to max attempts: ' + result.message, attempts: parent.attempts });\r\n        return;\r\n      }\r\n\r\n      // If the condition isn't met but the timeout hasn't elapsed, go again\r\n      setTimeout(checkCondition, parent.settings.interval, resolve, reject);\r\n    };\r\n\r\n    return new Promise(checkCondition)\r\n  }\r\n}\r\n","import { Settings, LogDebug, LogSilent } from '.';\r\nimport { DefaultName, FailReject, FailResolve, FailSilent } from './settings';\r\nimport { promiseBoolToStatus } from '../watch-promise/promise-boolean-as-promise';\r\nimport { ConditionAsPromise, ConditionMaker, ConditionRaw, Status, StatusSummary } from '..';\r\nimport { logPrefix } from '../constants';\r\n\r\nexport class TurnOn {\r\n\r\n  /** The settings applied to this turnOn */\r\n  public settings = new Settings();\r\n\r\n  /** Constructor with optional settings */\r\n  constructor(nameOrSettings?: Partial<Settings> | string) {\r\n    if (typeof nameOrSettings === 'string') {\r\n      nameOrSettings = {\r\n        name: nameOrSettings\r\n      };\r\n    }\r\n\r\n    if (nameOrSettings)\r\n      this.settings = { ...this.settings, ...nameOrSettings };\r\n\r\n    TurnOn.count++;\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n\r\n  public await(conditions: ConditionRaw | ConditionRaw[]): Promise<Status> {\r\n\r\n    // re-wrap to ensure we always work with an array\r\n    const conditionsArray = (Array.isArray(conditions)) ? conditions : [conditions];\r\n\r\n    // convert conditions to promises\r\n    const loadedCheckers = conditionsArray.map(c => {\r\n      // do this for non-promise conditions\r\n      if (Promise.resolve(c as unknown) === c) {\r\n        return promiseBoolToStatus(c);\r\n      } else {\r\n        const condition = this._conditionMaker.make(c);\r\n        const loaded = new ConditionAsPromise(condition, this.settings);\r\n        return loaded.asPromise();  \r\n      }\r\n    });\r\n\r\n    // keep the current turnOn-object for reference in methods\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    const thisKs = this;\r\n\r\n    // keep count as it was on start, to ensure it doesn't change any more till we log the error\r\n    const instanceCount = TurnOn.count;\r\n\r\n    const flattened = new Promise<StatusSummary>((resolve, reject) => { \r\n      // return a single promise for all inner promises which either fail or resolve\r\n      Promise.all(loadedCheckers).then(list => {\r\n\r\n        // get summary of all details infos\r\n        const summary = new StatusSummary(list);\r\n\r\n        // by default, log details about what failed\r\n        if (window.debugTurnOn || thisKs.settings.log === LogDebug || (!summary.ready && thisKs.settings.log !== LogSilent))\r\n          thisKs.logStatusList(summary.ready, instanceCount, thisKs.settings, list);\r\n\r\n        // if all is ok, resolve now\r\n        if (summary.ready === true) {\r\n          resolve(new StatusSummary(list));\r\n          return;\r\n        }\r\n\r\n        // depending on the need, either reject/error (default) or resolve with false\r\n        switch (thisKs.settings.failure){\r\n          case FailReject: reject(summary); break;\r\n          case FailResolve: resolve(summary); break;\r\n          case FailSilent: return;\r\n        }\r\n      })\r\n    });\r\n      \r\n    return flattened;\r\n  }\r\n\r\n  public logStatusList(success: boolean, id: number, settings: Settings, statusList: Status[]): void {\r\n    console.log(logPrefix + `#${id} `\r\n    + (settings.name !== DefaultName ? `\"${settings.name}\" ` : '')\r\n    + (success ? 'success!' : `couldn't complete because some conditions were not met. See details: `),\r\n     statusList);\r\n  }\r\n\r\n  private _conditionMaker = new ConditionMaker();\r\n\r\n  private static count = 0;\r\n}","import { Status } from '..';\r\n\r\nexport function promiseBoolToStatus(boolPromise: Promise<boolean>): Promise<Status> {\r\n  return new Promise<Status>((resolve, reject) => {\r\n    boolPromise\r\n      .then(r => {\r\n        const result = r !== false;\r\n        resolve(new Status('bool-promise', result, 'from promise'));\r\n    })\r\n      .catch(reason => reject(reason));\r\n  });\r\n}\r\n","import { Settings, TurnOn } from '.';\r\nimport { TagLoader } from '..';\r\nimport { ConfigTagManager } from '../tags/config-tag-manager';\r\n\r\nexport class TurnOnRoot {\r\n  \r\n  tagManager: ConfigTagManager;\r\n\r\n  loader: TagLoader;\r\n\r\n  constructor()\r\n  {\r\n    this.tagManager = new ConfigTagManager(this);\r\n    this.loader = new TagLoader(this.tagManager);\r\n    console.log('turnOn v0.1.2 active - it will help boot scripts when ready - set window.debugTurnOn = true for debugging')\r\n  }\r\n\r\n  /**\r\n   * Create a new turnOn object.\r\n   * Mainly usefuly in global scenarios, to give it a separate name\r\n   */\r\n  new(nameOrSettings?: Partial<Settings>): TurnOn {\r\n    return new TurnOn(nameOrSettings);\r\n  }\r\n}","\r\nexport * from './constants';\r\nexport * from './debug';\r\n\r\nexport * from './status';\r\nexport * from './conditions';\r\nexport * from './tags';\r\nexport * from './watch-promise';\r\n\r\nimport { TurnOnRoot } from './turnOn';\r\nexport * from './window';\r\n\r\nif (!window.turnOn) window.turnOn = new TurnOnRoot();\r\n// const turnOn = window.turnOn as TurnOnRoot;\r\n\r\n// turnOn.loader.activateObserver();\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// startup\n// Load entry module\n__webpack_require__(309);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}