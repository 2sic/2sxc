using System.Runtime.CompilerServices;
using ToSic.Eav.Models.Factory;
using ToSic.Sxc.Data.Models.Sys;
using ToSic.Sxc.Data.Sys.Factory;

namespace ToSic.Sxc.Data.Models;


/// <summary>
/// BETA / WIP: Base class for **plain** data models and can be used in Razor Components.
/// It wraps an <see cref="IEntity"/> and provides a simple way to access the data.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **plain** data model:
/// 
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : DataModel
///   {
///     public int Id => _entity.EntityId;
///     public string Name => _entity.Get&lt;string&gt; ("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// <span>@person.Name</span>
/// ```
/// </example>
/// <remarks>
/// This is much lighter than the [](xref:Custom.Data.CustomItem) which also wraps data, as it doesn't have any predefined properties and doesn't have the <see cref="ITypedItem"/> APIs.
/// 
/// History
/// 
/// - Released in v19.01 (BETA)
/// </remarks>
[InternalApi_DoNotUse_MayChangeWithoutNotice("Still beta, name may change")]
public abstract partial class ModelFromEntity: IDataWrapperNeedingFactoryWip<IEntity>, ICanBeEntity, IModelSetup<IEntity>, IModelFactoryRequired
{
    #region Explicit Interfaces for internal use - Setup, etc.

    public bool SetupModel(IEntity? source)
    {
        _entity = source;
        return true;
    }

    void IDataWrapperNeedingFactoryWip<IEntity>.Setup(IEntity source, IModelFactory modelFactory)
    {
        _entity = source;
        _modelFactory = modelFactory;
    }

    private IModelFactory _modelFactory = null!;

    /// <summary>
    /// This is necessary so the object can be used in places where an IEntity is expected,
    /// like toolbars.
    ///
    /// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    /// </summary>
    [PrivateApi]
    [ShowApiWhenReleased(ShowApiMode.Never)]
    IEntity ICanBeEntity.Entity => _entity;

    #endregion

    /// <summary>
    /// The underlying entity - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// * this property is protected, not public, as it should only be used internally.
    /// * this also prevents it from being serialized in JSON, which is good.
    /// * it uses an unusual name `_entity` to avoid naming conflicts with properties generated in inheriting classes.
    /// </remarks>
#pragma warning disable IDE1006
    // ReSharper disable once InconsistentNaming
    protected internal IEntity _entity { get; private set; } = null!;
#pragma warning restore IDE1006

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(ModelFromEntity)} Data Model {GetType().FullName} " + (_entity == null! ? "without backing data (null)" : $"for id:{_entity.EntityId} ({_entity})");


    #region As...

    /// <inheritdoc cref="DataModelHelpers.As{TCustom}"/>
    protected T? As<T>(object? item)
        where T : class, IDataWrapper
        => DataModelHelpers.As<T>(_modelFactory, item);

    /// <inheritdoc cref="DataModelHelpers.AsList{T}"/>
    protected IEnumerable<T>? AsList<T>(object source, NoParamOrder npo = default, bool nullIfNull = false)
        where T : class, IDataWrapper
        => DataModelHelpers.AsList<T>(_modelFactory, source, new() { ItemIsStrict = true }, npo, nullIfNull);

    #endregion

    #region GetThis


    /// <summary>
    /// Get a value from the underlying entity, whose name matches the property requesting this.
    /// So if your C# property is called `Birthday` it will also get the field `Birthday` in the entity.
    /// </summary>
    /// <typeparam name="T">Optional type, usually auto-detected because of the `fallback` value</typeparam>
    /// <param name="fallback">Value to provide if nothing was found - required</param>
    /// <param name="propertyName">The property name - will be autofill by the compiler</param>
    /// <returns>The typed value</returns>
    //[return: NotNullIfNotNull(nameof(fallback))]
    protected T? GetThis<T>(T? fallback, [CallerMemberName] string? propertyName = default)
        => _entity.Get<T>(propertyName!, fallback: fallback);


    #endregion

}