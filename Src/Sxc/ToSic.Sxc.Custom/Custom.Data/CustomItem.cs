using System.Text.Json.Serialization;
using ToSic.Eav.Data.Sys;
using ToSic.Eav.Data.Sys.PropertyLookup;
using ToSic.Razor.Blade;
using ToSic.Razor.Markup;
using ToSic.Sxc.Adam;
using ToSic.Sxc.Cms.Data;
using ToSic.Sxc.Data;
using ToSic.Sxc.Data.Models;
using ToSic.Sxc.Data.Options;
using ToSic.Sxc.Data.Sys.Factory;
using ToSic.Sxc.Images;
using ToSic.Sxc.Services.Tweaks;
using ToSic.Sys.GetByName;

namespace Custom.Data;

/// <summary>
/// Base class for custom data objects, which extend the <see cref="ITypedItem"/> for use in Razor Components.
/// </summary>
/// <example>
///
/// Usage ca. like this:
///
/// 1. A custom data model in `AppCode.Data` which inherits from this class (usually generated by 2sxc Copilot)
/// 2. Razor code which uses it to convert typed items into this custom data model
/// 
/// Example trivial custom **ITyped** data model:
/// ```c#
/// namespace AppCode.Data
/// {
///   class MyPerson : Custom.Data.CustomItem
///   {
///     // New custom property
///     public string Name => _item.String("Name");
///   }
/// }
/// ```
///
/// Example usage in Razor:
///
/// ```razor#
/// @inherits Custom.Hybrid.RazorTyped
/// @using AppCode.Data
/// @{
///   var person = As&lt;MyPerson&gt;(MyItem);
/// }
/// @* Now you can use the custom properties *@
/// <span>@person.Name</span>
/// @* But also all the standard properties like Id, Guid, Title, Type, etc. *@
/// <span>@person.Id / @person.Guid</span>
/// ```
/// </example>
/// <remarks>
/// It is used by 2sxc Copilot when generating base classes for custom data objects.
///
/// History
/// 
/// * Released in v17.06
/// * It's not abstract, even if the most common case is to inherit, as there are cases where you want to use it directly.
/// </remarks>
[PublicApi]
[ModelSource(ContentTypes = ModelSourceAttribute.ForAnyContentType)]
public partial class CustomItem: ITypedItem, ICanWrap<ITypedItem>, IHasPropLookup
{
    #region Explicit Interfaces for internal use - Setup, etc.


    void ICanWrap<ITypedItem>.Setup(ITypedItem source, IModelFactory modelFactory)
    {
        _item = source;
        _modelFactory = modelFactory;
    }
    private IModelFactory _modelFactory = null!;

    /// <summary>
    /// The actual item which is being wrapped, in rare cases where you must access it.
    ///
    /// It's only on the explicit interface, so it is not available from outside or inside, unless you cast to it.
    /// Goal is that inheriting classes don't access it to keep API surface small.
    /// </summary>
    ITypedItem ICanBeItem.Item
        => _item;

    /// <summary>
    /// This is necessary so the object can be used in places where an IEntity is expected,
    /// like toolbars.
    ///
    /// It's an explicit interface implementation, so that the object itself doesn't broadcast this.
    /// </summary>
    [PrivateApi]
    [ShowApiWhenReleased(ShowApiMode.Never)]
    IEntity ICanBeEntity.Entity => _item.Entity;

    // #RemoveBlocksIRenderService
    //object? ICanBeItem.TryGetBlock()
    //    => _item.TryGetBlock();

    [field: AllowNull, MaybeNull]
    IPropertyLookup IHasPropLookup.PropertyLookup
        => field ??= ((IHasPropLookup)((ICanBeItem)this).Item).PropertyLookup;

    #endregion

    /// <summary>
    /// The item - for inheriting classes to access.
    /// </summary>
    /// <remarks>
    /// * this property is protected, not public, as it should only be used internally.
    /// * this also prevents it from being serialized in JSON, which is good.
    /// * it uses an unusual name `_item` to avoid naming conflicts with properties generated in inheriting classes.
    /// </remarks>
#pragma warning disable IDE1006
    // ReSharper disable once InconsistentNaming
    protected internal ITypedItem _item { get; private set; } = null!;
#pragma warning restore IDE1006

    /// <summary>
    /// Override ToString to give more information about the current object
    /// </summary>
    public override string ToString() 
        => $"{nameof(CustomItem)} Data Model {GetType().FullName} "
           + (_item == null! ? "without backing data (null)" : $"for id:{Id} ({_item})");


    #region Keys and Empty-Checks

    /// <inheritdoc cref="IHasKeys.ContainsKey"/>
    public bool ContainsKey(string name)
        => ((IHasKeys)_item).ContainsKey(name);

    /// <inheritdoc cref="IHasKeys.Keys"/>
    public IEnumerable<string> Keys(NoParamOrder npo = default, IEnumerable<string>? only = default)
        => _item.Keys(npo, only);

    /// <inheritdoc cref="IHasKeys.IsEmpty"/>
    public bool IsEmpty(string name, NoParamOrder npo = default, string? language = default)
        => _item.IsEmpty(name, npo, language: language);

    /// <inheritdoc cref="IHasKeys.IsNotEmpty"/>
    public bool IsNotEmpty(string name, NoParamOrder npo = default, string? language = default)
        => _item.IsNotEmpty(name, npo, language: language);

    #endregion


    #region Basic Get

    /// <inheritdoc />
    public object? Get(string name, NoParamOrder npo = default, bool? required = default, string? language = default)
        => _item.Get(name: name, npo: npo, required: required, language: language);

    /// <inheritdoc />
    public TValue? Get<TValue>(string name, NoParamOrder npo = default, TValue? fallback = default, bool? required = default, string? language = default)
        => _item.Get(name: name, npo: npo, fallback: fallback, required: required, language: language);

    #endregion

    #region Typed Get

    /// <inheritdoc />
    public bool Bool(string name, NoParamOrder npo = default, bool fallback = default, bool? required = default) => _item.Bool(name, npo, fallback, required);

    /// <inheritdoc />
    public DateTime DateTime(string name, NoParamOrder npo = default, DateTime fallback = default,
        bool? required = default) =>
        _item.DateTime(name, npo, fallback, required);

    /// <inheritdoc />
    public string? String(string name, NoParamOrder npo = default, string? fallback = default, bool? required = default, object? scrubHtml = default)
        => _item.String(name, npo, fallback, required, scrubHtml);

    /// <inheritdoc />
    public int Int(string name, NoParamOrder npo = default, int fallback = default, bool? required = default) => _item.Int(name, npo, fallback, required);

    /// <inheritdoc />
    public long Long(string name, NoParamOrder npo = default, long fallback = default, bool? required = default) => _item.Long(name, npo, fallback, required);

    /// <inheritdoc />
    public float Float(string name, NoParamOrder npo = default, float fallback = default, bool? required = default) => _item.Float(name, npo, fallback, required);

    /// <inheritdoc />
    public decimal Decimal(string name, NoParamOrder npo = default, decimal fallback = default, bool? required = default) => _item.Decimal(name, npo, fallback, required);

    /// <inheritdoc />
    public double Double(string name, NoParamOrder npo = default, double fallback = default, bool? required = default) => _item.Double(name, npo, fallback, required);

    /// <inheritdoc />
    public string? Url(string name, NoParamOrder npo = default, string? fallback = default, bool? required = default) => _item.Url(name, npo, fallback, required);

    #endregion


    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public bool IsDemoItem => _item.IsDemoItem;

    #region Advanced Get Methods: Attribute, Html, File, Folder etc.

    /// <inheritdoc />
    public IRawHtmlString? Attribute(string name, NoParamOrder npo = default, string? fallback = default,
        bool? required = default) =>
        _item.Attribute(name, npo, fallback, required);

    /// <inheritdoc />
    public IHtmlTag? Html(string name, NoParamOrder npo = default, object? container = default, bool? toolbar = default,
        object? imageSettings = default, bool? required = default, bool debug = default, Func<ITweakInput<string>, ITweakInput<string>>? tweak = default) =>
        _item.Html(name, npo, container, toolbar, imageSettings, required, debug, tweak);

    /// <inheritdoc />
    public IResponsivePicture? Picture(string name, NoParamOrder npo = default,
        Func<ITweakMedia, ITweakMedia>? tweak = default,
        object? settings = default,
        object? factor = default, object? width = default, string? imgAlt = default, string? imgAltFallback = default,
        string? imgClass = default, object? imgAttributes = default, string? pictureClass = default,
        object? pictureAttributes = default, object? toolbar = default, object? recipe = default) =>
        _item.Picture(name, npo, tweak, settings, factor, width, imgAlt, imgAltFallback, imgClass, imgAttributes, pictureClass, pictureAttributes, toolbar, recipe);

    /// <inheritdoc />
    public IResponsiveImage? Img(string name, NoParamOrder npo = default, Func<ITweakMedia, ITweakMedia>? tweak = default, object? settings = default, object? factor = default, object? width = default,
        string? imgAlt = default, string? imgAltFallback = default, string? imgClass = default, object? imgAttributes = default, object? toolbar = default, object? recipe = default) =>
        _item.Img(name, npo, tweak, settings, factor, width, imgAlt, imgAltFallback, imgClass, imgAttributes, toolbar, recipe);

    /// <inheritdoc />
    public IFolder? Folder(string name, NoParamOrder npo = default, bool? required = default)
        => _item.Folder(name, npo, required);

    /// <inheritdoc />
    public IFile? File(string name, NoParamOrder npo = default, bool? required = default)
        => _item.File(name, npo, required);

    #endregion

    #region Children and Parents

    /// <inheritdoc />
    public ITypedItem? Child(string name, NoParamOrder npo = default, bool? required = default, GetRelatedOptions? options = default)
        => _item.Child(name, npo, required, options: options);

    /// <inheritdoc />
    public IEnumerable<ITypedItem> Children(string? field, NoParamOrder npo = default, string? type = default, bool? required = default, GetRelatedOptions? options = default)
        => _item.Children(field, npo, type, required, options);

    /// <inheritdoc />
    public ITypedItem? Parent(NoParamOrder npo = default, bool? current = default, string? type = default, string? field = default, GetRelatedOptions? options = default)
        => _item.Parent(npo, current, type, field, options: options);

    /// <inheritdoc />
    public IEnumerable<ITypedItem> Parents(NoParamOrder npo = default, string? type = default, string? field = default, GetRelatedOptions? options = default)
        => _item.Parents(npo, type, field, options: options);

    #endregion

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public bool IsPublished => _item.IsPublished;

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public IPublishing Publishing => _item.Publishing;

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public ITypedItem? Presentation => _item.Presentation;

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public ITypedMetadata Metadata => _item.Metadata;

    /// <inheritdoc />
    public IField? Field(string name, NoParamOrder npo = default, bool? required = default)
        => _item.Field(name, npo, required);


    #region Core Data: Id, Guid, Title, Type

    /// <inheritdoc />
    [JsonPropertyOrder(-100)]
    public int Id => _item.Id;

    /// <inheritdoc />
    [JsonPropertyOrder(-99)]
    public Guid Guid => _item.Guid;

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it maps to a property which could be different; better let the inheriting class define it
    public string? Title => _item.Title;

    /// <inheritdoc />
    [JsonIgnore] // prevent serialization as it's not a normal property
    public IContentType Type => _item.Type;

    #endregion


    #region New Child<T> / Children<T>

    /// <inheritdoc />
    public T? Child<T>(string name, NoParamOrder npo = default, bool? required = default, GetRelatedOptions? options = default)
        where T : class, ICanWrapData, new()
        => _item.Child<T>(name, npo: npo, required: required, options: options);

    /// <inheritdoc />
    public IEnumerable<T> Children<T>(string? field, NoParamOrder npo = default, string? type = default, bool? required = default, GetRelatedOptions? options = default)
        where T : class, ICanWrapData, new()
        => _item.Children<T>(field: field, npo: npo, type: type, required: required, options: options);

    /// <inheritdoc />
    public T? Parent<T>(NoParamOrder npo = default, bool? current = default, string? type = default, string? field = default, GetRelatedOptions? options = default)
        where T : class, ICanWrapData, new()
        => _item.Parent<T>(npo: npo, current: current, type: type, field: field, options: options);

    /// <inheritdoc />
    public IEnumerable<T> Parents<T>(NoParamOrder npo = default, string? type = default, string? field = default, GetRelatedOptions? options = default)
        where T : class, ICanWrapData, new()
        => _item.Parents<T>(npo: npo, type: type ?? typeof(T).Name, field: field, options: options);

    /// <inheritdoc />
    public GpsCoordinates Gps(string name, NoParamOrder npo = default, bool? required = default)
        => _item.Gps(name: name, npo: npo, required: required);

    #endregion

    #region As...

    /// <summary>
    /// Convert an Entity or TypedItem into a strongly typed object.
    /// Typically, the type will be from your `AppCode.Data`.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="item"></param>
    /// <returns></returns>
    /// <remarks>
    /// New in v17.03
    /// </remarks>
    protected T As<T>(ITypedItem item)
        where T : class, ICanWrapData
        => _modelFactory.AsCustomFrom<T, ITypedItem>(item);

    /// <summary>
    /// Convert a list of Entities or TypedItems into a strongly typed list.
    /// Typically, the type will be from your `AppCode.Data`.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="source"></param>
    /// <param name="npo">see [](xref:NetCode.Conventions.NamedParameters)</param>
    /// <param name="nullIfNull"></param>
    /// <returns></returns>
    /// <remarks>
    /// New in v17.03
    /// </remarks>
    protected IEnumerable<T> AsList<T>(IEnumerable<ITypedItem>? source, NoParamOrder npo = default, bool nullIfNull = false)
        where T : class, ICanWrapData
        => (source ?? (nullIfNull ? null : []))
            ?.Select(item => _modelFactory.AsCustomFrom<T, ITypedItem>(item))
            .ToList()!;

    #endregion

    /// <summary>
    /// Get by name should never throw an error, as it's used to get null if not found.
    /// </summary>
    object? ICanGetByName.Get(string name)
        => (this as ITypedItem).Get(name, required: false);

}